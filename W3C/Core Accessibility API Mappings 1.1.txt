（訳注：英単語で表記すべき所もほとんどを日本語に翻訳して、英単語は必要と思われる所でカッコ内に示しています。）

W3C

Core Accessibility API Mappings 1.1
コアアクセシビリティ API マッピング 1.1

W3C Recommendation 14 December 2017 
W3C 勧告 2017年12月14日

This version:
このバージョン： 

    https://www.w3.org/TR/2017/REC-core-aam-1.1-20171214/

Latest published version:
最新の公開バージョン：

    https://www.w3.org/TR/core-aam-1.1/

Latest editor's draft:
最新の編集者の下書き：

    https://w3c.github.io/core-aam/

Implementation report:
実装報告：

    https://w3c.github.io/test-results/core-aam/

Previous version:
前のバージョン：

    https://www.w3.org/TR/2017/PR-core-aam-1.1-20171102/

Previous Recommendation:
以前の勧告：

    https://www.w3.org/TR/wai-aria-implementation-1.0/

Editors:
編集者：

    Joanmarie Diggs, Igalia, S.L., jdiggs@igalia.com

    Joseph Scheuhammer, Inclusive Design Research Centre, OCAD University

    Richard Schwerdtfeger, Knowbility, richschwer@gmail.com

    Michael Cooper, W3C

    Andi Snow-Weaver (until December 2012), IBM

    Aaron Leventhal (until January 2009), IBM

Platform Mapping Maintainers:
プラットフォームマッピングの管理者：

    Bogdan Brinza, Microsoft Corp. (UIA)

    James Craig, Apple, Inc. (AX API)

    Joanmarie Diggs, Igalia, S.L., jdiggs@igalia.com (ATK / AT-SPI)

    Alexander Surkov, Mozilla Foundation (MSAA, IAccessible2)

Please check the errata for any errors or issues reported since publication.
公開以降に報告されたエラーや問題については、エラッタを確認してください。

See also translations.
翻訳も参照してください。

Copyright © 2014-2017 W3C® (MIT, ERCIM, Keio, Beihang). W3C liability, trademark and document use rules apply.
Copyright © 2014-2017 W3C®（MIT、ERCIM、慶應義塾大学、北京航空航天大学）。 W3C の責任、商標、および文書の使用規則が適用されます。 




Abstract
概要

This document describes how user agents should expose semantics of web content languages to accessibility APIs. This helps users with disabilities to obtain and interact with information using assistive technologies. Documenting these mappings promotes interoperable exposure of roles, states, properties, and events implemented by accessibility APIs and helps to ensure that this information appears in a manner consistent with author intent.
この文書では、ユーザーエージェントがウェブコンテンツ言語の意味論をアクセシビリティ API に公開する方法について説明します。 これは、障害を持つユーザーが支援技術を使用して情報を取得し、相互作用するのに役立ちます。 これらのマッピングを文書化すると、アクセシビリティ API によって実装されたロール（roles、役割）、状態（states）、プロパティ（properties）、およびイベント（events）の相互運用可能な公開が促進され、この情報が作成者の意図と一致する方法で表示されるようになります。

This Core Accessibility API Mappings specification defines support that applies across multiple content technologies, including general keyboard navigation support and mapping of general-purpose roles, states, and properties provided in Web content via WAI-ARIA [wai-aria-1.1]. Other Accessibility API Mappings specifications depend on and extend this Core specification for specific technologies, including native technology features and WAI-ARIA extensions. This document updates and supercedes the guidance in the WAI-ARIA 1.0 User Agent Implementation Guide [wai-aria-implementation-1.0] W3C Recommendation. It is part of the WAI-ARIA suite described in the WAI-ARIA Overview.
このコアアクセシビリティ API マッピング仕様は、一般的なキーボードナビゲーションのサポートや、WAI-ARIA [wai-aria-1.1] を介してウェブコンテンツで提供される汎用のロール、状態、プロパティのマッピングなど、複数のコンテンツ技術に適用されるサポートを定義します。 その他のアクセシビリティ API マッピング仕様は、ネイティブな技術機能や WAI-ARIA 拡張機能など、特定の技術向けにこのコア仕様に依存し、拡張しています。 この文書は、「WAI-ARIA 1.0 ユーザーエージェント実装ガイド [wai-aria-implementation-1.0] W3C 勧告」のガイダンスを更新して置き換えます。 これは、WAI-ARIA の概要で説明されている WAI-ARIA スイートの一部です。




Status of This Document
この文書のステータス

This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at https://www.w3.org/TR/.
このセクションでは、発行時のこの文書のステータスについて説明します。 他の文書がこの文書に取って代わる場合があります。 現在の W3C 出版物のリストとこのテクニカルレポートの最新リビジョンは、https://www.w3.org/TR の W3C テクニカルレポートインデックスにあります。

This is the Core-AAM 1.1 W3C Recommendation by the Accessible Rich Internet Applications Working Group. The Working Group create a Core-AAM 1.1 Implementation Report to demonstrate that the specification is implementable. A history of changes to Core-AAM 1.1 is available in the appendix.
これは、Accessible Rich Internet Applications ワーキンググループによる Core-AAM 1.1 W3C 勧告です。 ワーキンググループは、仕様が実装可能であることを示すために Core-AAM 1.1 実装報告を作成します。 Core-AAM 1.1 への変更の履歴は、付録に記載されています。

To comment on this document, file an issue in the W3C core-aam GitHub repository. If this is not feasible, send email to public-aria@w3.org (comment archive). Comments received on the Core-AAM 1.1 Recommendation cannot result in changes to this version of the specification, but may be addressed in errata or future versions of Core-AAM. The Working Group may not make formal responses to comments but future work undertaken by the Working Group may address comments received on this document. In-progress updates to the technology may be viewed in the publicly visible editors' draft.
この文書にコメントするには、W3C core-aam GitHub リポジトリに問題を報告してください。 これが不可能な場合は、public-aria@w3.org（コメントアーカイブ）に電子メールを送信してください。 Core-AAM 1.1 勧告について受け取ったコメントは、このバージョンの仕様を変更することはできませんが、Core-AAM の正誤表または将来のバージョンで対処される可能性があります。 ワーキンググループはコメントに対して正式な回答をしないかもしれませんが、ワーキンググループによって行われる将来の作業はこの文書で受け取ったコメントに対処するかもしれません。 技術の進行中の更新は、公開されている編集者のドラフトで確認できます。

This document was published by the Accessible Rich Internet Applications Working Group as a Recommendation.
この文書は、Accessible Rich Internet Applications ワーキンググループによって勧告として公開されました。

Please see the Working Group's implementation report.
ワーキンググループの実装報告をご覧ください。

This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its widespread deployment. This enhances the functionality and interoperability of the Web.
この文書は、W3C メンバー、ソフトウェア開発者、および他の W3C グループと利害関係者によってレビューされており、W3C 勧告としてディレクターによって承認されています。 これは安定した文書であり、参考資料として使用したり、別の文書から引用したりできます。 勧告の作成における W3C の役割は、仕様に注意を引き、その広範な展開を促進することです。 これにより、ウェブの機能と相互運用性が強化されます。

This document was produced by a group operating under the W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.
この文書は、W3C 特許ポリシーに基づいて運営されているグループによって作成されました。 W3C は、グループの成果物に関連して行われた特許開示の公開リストを維持しています。 そのページには、特許を開示するための指示も含まれています。 エッセンシャルクレームが含まれていると個人が信じる特許について実際の知識を持っている個人は、W3C 特許ポリシーのセクション 6 に従って情報を開示する必要があります。

This document is governed by the 1 March 2017 W3C Process Document.
この文書は、2017年3月1日の W3C プロセス文書に準拠しています。




Table of Contents 
目次










    Abstract
    概要

    Status of This Document
    この文書のステータス

    1. Introduction
    1. 序文

        1.1 Accessibility APIs
        1.1 アクセシビリティ API

        1.2 The Accessibility Tree and the DOM Tree
        1.2 アクセシビリティツリーと DOM ツリー

        1.3 Comparing Accessibility APIs
        1.3 アクセシビリティ API の比較

            1.3.1 ATK/AT-SPI
            1.3.1 ATK / AT-SPI

            1.3.2 UIA (UI Automation)
            1.3.2 UIA（UI オートメーション）

            1.3.3 Accessible Names and Descriptions
            1.3.3 アクセス可能な名前と説明

    2. Conformance
    2. 準拠

        2.1 RFC-2119 Keywords
        2.1 RFC-2119 キーワード

        2.2 Normative and Informative Sections
        2.2 規範的なセクションと情報的なセクション

        2.3 Features Deprecated in WAI-ARIA
        2.3 WAI-ARIA で非推奨となった機能

    3. Important Terms
    3. 重要な用語

    4. Supporting Keyboard Navigation
    4. キーボードナビゲーションのサポート

        4.1 Focus States and Events Table
        4.1 フォーカスの状態とイベントの表

        4.2 Controlling focus with tabindex
        4.2 tabindex によるフォーカスの制御

        4.3 Controlling focus with aria-activedescendant
        4.3 aria-activedescendant によるフォーカスの制御

        4.4 Handling focus changes from the Assistive Technology
        4.4 支援技術からのフォーカス変更の処理

    5. Mapping WAI-ARIA to Accessibility APIs
    5. WAI-ARIA のアクセシビリティ API へのマッピング

        5.1 General rules for exposing WAI-ARIA semantics
        5.1 WAI-ARIA 意味論を公開するための一般的な規則

            5.1.1 Excluding Elements from the Accessibility Tree
            5.1.1 アクセシビリティツリーからの要素の除外

            5.1.2 Including Elements in the Accessibility Tree
            5.1.2 アクセシビリティツリーに要素を含める

            5.1.3 Notification of State Changes
            5.1.3 状態変化の通知

        5.2 Conflicts between native markup semantics and WAI-ARIA
        5.2 ネイティブなマークアップの意味論と WAI-ARIA の間の競合

        5.3 Exposing attributes that do not directly map to accessibility API properties
        5.3 アクセシビリティ API のプロパティに直接マップされない属性の公開

        5.4 Role mapping
        5.4 ロールのマッピング

            5.4.1 General rules
            5.4.1 一般規則

            5.4.2 Role Mapping Table
            5.4.2 ロールのマッピング表

        5.5 State and Property Mapping
        5.5 状態とプロパティのマッピング

            5.5.1 General rules
            5.5.1 一般規則

            5.5.2 State and Property Mapping Table
            5.5.2 状態とプロパティのマッピング表

                5.5.2.1 Not Mapped
                5.5.2.1 マップされていない

        5.6 Special Processing Requiring Additional Computation
        5.6 追加の計算を必要とする特別な処理

            5.6.1 Name and Description
            5.6.1 名前と説明

            5.6.2 Widget Values
            5.6.2 ウィジェット値

            5.6.3 Relations
            5.6.3 関係

                5.6.3.1 ID Reference Error Processing
                5.6.3.1 ID 参照エラー処理

                5.6.3.2 Reverse Relations
                5.6.3.2 逆の関係

                5.6.3.3 Implied reverse relations
                5.6.3.3 暗黙の逆の関係

            5.6.4 Group Position
            5.6.4 グループ位置

        5.7 Actions
        5.7 アクション

        5.8 Events
        5.8 イベント

            5.8.1 State and Property Change Events
            5.8.1 状態とプロパティの変更イベント

            5.8.2 Changes to document content or node visibility
            5.8.2 文書コンテンツやノードの可視性の変更

            5.8.3 Selection
            5.8.3 選択

            5.8.4 Special Events for Menus
            5.8.4 メニューの特別イベント

    6. Special Document Handling Procedures
    6. 特別な文書処理手順

        6.1 CSS Selectors
        6.1 CSS セレクター

        6.2 Author Errors
        6.2 作成者エラー

    A. Appendices
    A. 付録

        A.1 Change Log: substantive changes since the WAI-ARIA 1.0 User Agent Implementation Guide Recommendation
        A.1 変更ログ：「WAI-ARIA 1.0 ユーザーエージェント実装ガイドの勧告」以降の実質的な変更

        A.2 Acknowledgments
        A.2 謝辞

            A.2.1 Participants active in the ARIA WG at the time of publication
            A.2.1 発行時に ARIA WG で活動している参加者

            A.2.2 Other ARIA contributors, commenters, and previously active participants
            A.2.2 その他の ARIA 寄稿者、コメント投稿者、および以前にアクティブだった参加者

            A.2.3 Enabling funders
            A.2.3 可能にする資金提供者

    B. References
    B. 参考文献

        B.1 Normative references
        B.1 規範的な参考文献

        B.2 Informative references
        B.2 情報的な参考文献





1. Introduction §
1. 序文 §

This section is non-normative.
このセクションは非規範的です。

In traditional desktop graphical user interface (GUI) applications, components of the user interface (UI) are displayed when needed and hidden when not needed based on user interactions. Accessibility application programming interfaces (APIs) are used to communicate semantic information about the user interface to assistive technology software used by people with disabilities. These APIs constitute a contract between applications and assistive technologies, such as screen readers, magnifiers, alternate input devices, and speech command and control, to enable them to access the appropriate semantics needed to produce a usable alternative to interactive applications. For example, screen reading software for blind users can determine whether a particular UI component is a menu, button, text field, list box, etc.
従来のデスクトップのグラフィカルユーザーインターフェイス（graphical user interface、GUI）アプリケーションでは、ユーザーインターフェイス（UI）コンポーネントは、ユーザーとの相互作用に基づいて、必要なときに表示され、不要なときに非表示になります。 アクセシビリティのアプリケーションプログラミングインターフェイス（application programming interfaces、API）は、ユーザーインターフェイスに関する意味論的な情報を、障害を持つ人々が使用する支援技術ソフトウェアに伝達するために使用されます。 これらの API は、アプリケーションと、スクリーンリーダー、拡大鏡、代替入力デバイス、音声コマンドおよび制御などの支援技術との間の契約を構成し、相互作用的なアプリケーションの使用可能な代替を生成するために必要な適切な意味論にアクセスできるようにします。 たとえば、目の不自由なユーザー向けの画面読み上げソフトウェアは、特定の UI コンポーネントがメニュー、ボタン、テキストフィールド、リストボックスなどであるかどうかを判断できます。

In traditional static Web pages, the HTML elements provided the necessary semantic information. The user agent provides keyboard navigation but only to the HTML elements that are known to be interactive, specifically links and form elements. Assistive technologies obtain the semantic information from the Document Object Model (DOM) or, in the case of links and form elements, through the Accessibility API. In both cases, the assistive technology expects that nothing changes until a new page is loaded based on a user action.
従来の静的ウェブページでは、HTML 要素が必要な意味論的な情報を提供していました。 ユーザーエージェントはキーボードナビゲーションを提供しますが、相互作用的であることがわかっている HTML 要素、特にリンクとフォーム要素にのみ提供します。 支援技術は、文書オブジェクトモデル（Document Object Model、DOM）から、またはリンクやフォーム要素の場合はアクセシビリティ API を介して意味論的な情報を取得します。 どちらの場合も、支援技術は、ユーザーの操作に基づいて新しいページが読み込まれるまで何も変更されないことを想定しています。

Yet technologies such as JavaScript, Ajax, and CSS have enabled Web pages to look and behave more like interactive desktop GUI applications, without the need to reload the page with each user interaction. Developers can now re-purpose HTML elements into UI components not previously defined in HTML. For example, Javascript can be used with CSS to modify a <div> element based on user interactions to make it look and behave like a popup menu. Unfortunately, the <div> element does not provide the author with a vehicle to add semantic metadata that can be exposed through the DOM and mapped to Accessibility APIs. These accessibility deficiencies in traditional markup render rich Internet applications unusable by people who use assistive technologies or who rely on keyboard navigation.
それでも、JavaScript、Ajax、CSS などの技術により、ユーザーが相互作用するたびにページをリロードすることなく、ウェブページを相互作用的なデスクトップ GUI アプリケーションのように見せたり振る舞わさせたりすることができます。 開発者は、HTML 要素を以前は HTML で定義されていなかった UI コンポーネントに再利用できるようになりました。 たとえば、Javascript を CSS とともに使用して、ユーザーとの相互作用に基づいて <div> 要素を変更し、ポップアップメニューのように表示および振る舞わさせることができます。 残念ながら、<div> 要素は、DOM を介して公開し、アクセシビリティ API にマップできる意味論的なメタデータを追加する手段を作成者に提供しません。 従来のマークアップにおけるこれらのアクセシビリティの欠陥により、支援技術を使用する人々やキーボードナビゲーションに依存する人々はリッチなインターネットアプリケーションを使用できなくなります。

The W3C Web Accessibility Initiative's (WAI) Protocols and Formats working group (PFWG) has addressed these deficiencies through several W3C standards efforts, with a focus on the Accessible Rich Internet Applications [wai-aria-1.1] specification.
W3C Web Accessibility Initiative（WAI）のプロトコルおよびフォーマットワーキンググループ（Protocols and Formats working group、PFWG）は、「アクセス可能でリッチなインターネットアプリケーション（Accessible Rich Internet Applications） [wai-aria-1.1]」仕様に焦点を当てて、いくつかの W3C 標準の取り組みを通じてこれらの欠陥に対処しました。

WAI-ARIA enables rich Internet applications to have the same accessibility features as desktop GUI applications by adding metadata to markup technologies such as (X)HTML. Authors include WAI-ARIA in their markup and user agents translate the WAI-ARIA markup to the platform accessibility APIs.
WAI-ARIA は、(X)HTML などのマークアップ技術にメタデータを追加することにより、リッチなインターネットアプリケーションがデスクトップ GUI アプリケーションと同じアクセシビリティ機能を持つことを可能にします。 作成者はマークアップに WAI-ARIA を含め、ユーザーエージェントは WAI-ARIA マークアップをプラットフォームのアクセシビリティ API に変換します。

For an introduction to WAI-ARIA, see the WAI-ARIA Overview. The User Agent Implementation Guide describes how WAI-ARIA roles, states, and properties should be supported in user agents using platform accessibility APIs. It is part of a set of resources that define and support the WAI-ARIA specification which includes the following documents:
WAI-ARIA の概要については、「WAI-ARIA の概要」を参照してください。 「ユーザーエージェント実装ガイド」では、プラットフォームのアクセシビリティ API を使用して、ユーザーエージェントで WAI-ARIA のロール、状態、およびプロパティをサポートする方法について説明しています。 これは、次の文書を含む WAI-ARIA 仕様を定義およびサポートする一連のリソースの一部です。

    Accessible Rich Internet Applications (WAI-ARIA) 1.0 [wai-aria-1.1], a W3C recommendation, defines the WAI-ARIA standard.
    「アクセス可能でリッチなインターネットアプリケーション（WAI-ARIA）1.0 [wai-aria-1.1]」は、W3C 勧告であり、WAI-ARIA 標準を定義しています。

    WAI-ARIA Authoring Practices Guide [wai-aria-practices-1.1], a W3C Working Group Note, describes how web content developers can develop accessible rich internet applications using WAI-ARIA. It provides detailed advice and examples directed primarily to web application developers, yet also useful to user agent and developers of assistive technologies.
    「WAI-ARIA オーサリングプラクティスガイド [wai-aria-practices-1.1]」は、W3C ワーキンググループノートであり、ウェブコンテンツ開発者が WAI-ARIA を使用してアクセス可能でリッチなインターネットアプリケーションを開発する方法について説明しています。 主にウェブアプリケーション開発者向けの詳細なアドバイスと例を提供しますが、ユーザーエージェントや支援技術の開発者にも役立ちます。

    Roadmap for Accessible Rich Internet Applications (WAI-ARIA Roadmap) [wai-aria-roadmap], a W3C Working Group Note, defines the path to make rich web content accessible, including steps already taken, remaining future steps, and a time line.
    「アクセス可能でリッチなインターネットアプリケーションのロードマップ（WAI-ARIA Roadmap）[wai-aria-roadmap]」は、W3C ワーキンググループノートであり、リッチなウェブコンテンツをアクセス可能にするための道筋を定義します。 これには、すでに実行した手順、残りの今後の手順、タイムラインが含まれます。

The WAI-ARIA User Agent Implementation Guide begins by providing a general overview of accessibility APIs and the accessible object hierarchy known as the accessibility tree. The following sections give guidance on supporting keyboard navigation and mapping WAI-ARIA roles, states, and properties to accessibility APIs. Other sections give guidance on calculating text alternatives, mapping actions to events, event processing, special document handling procedures, and error handling.
「WAI-ARIA ユーザーエージェント実装ガイド」ではまず、アクセシビリティ API と、アクセシビリティツリーと呼ばれるアクセス可能なオブジェクト階層の一般的な概要を説明します。 次のセクションでは、キーボードナビゲーションのサポートと、WAI-ARIA のロール、状態、およびプロパティのアクセシビリティ API へのマッピングに関するガイダンスを提供します。 他のセクションでは、代替テキストの計算、アクションのイベントへのマッピング、イベント処理、特別な文書処理手順、およびエラー処理に関するガイダンスを提供します。

This guide assumes that a user agent already exposes static content to assistive technology via the accessibility API on a given platform. Most of the additional work to enable WAI-ARIA can be divided into three parts:
このガイドでは、ユーザーエージェントが、特定のプラットフォームのアクセシビリティ API を介して静的コンテンツを支援技術に既に公開していることを前提としています。 WAI-ARIA を有効にするための追加作業のほとんどは、次の3つの部分に分けることができます。

    Enabling keyboard navigation on elements that previously were not focusable
    以前はフォーカスできなかった要素でキーボードナビゲーションを有効にする

    Mapping the WAI-ARIA roles and attributes into the roles, states and other property getters in the accessibility API
    WAI-ARIA のロールと属性を、アクセシビリティ API のロール、状態、その他のプロパティゲッターにマッピングする

    Computing text alternatives and managing states and events
    代替テキストの計算と状態およびイベントの管理

In general, WAI-ARIA attributes should only affect how content is mapped to platform accessibility APIs. They should not affect the visual rendering of content nor behavior of mainstream desktop browsers, except when style sheets are deliberately keyed off of WAI-ARIA attributes as recommended in the specification. This allows one of the primary principles of WAI-ARIA to be upheld—that content still renders and behaves the same for the majority of users.
一般に、WAI-ARIA 属性は、コンテンツがプラットフォームのアクセシビリティ API にマップされる方法にのみ影響する必要があります。 仕様で推奨されているようにスタイルシートが WAI-ARIA 属性を意図的に利用している場合を除いて、コンテンツの視覚的レンダリングや主流のデスクトップブラウザーの振る舞いに影響を与えるべきではありません。 これにより、WAI-ARIA の主要な原則の1つを維持することができます。 つまり、コンテンツは大多数のユーザーに対して同じようにレンダリングされ、同じように振る舞います。

This document includes information for user agents specifying how to map WAI-ARIA roles, states, and properties to platform accessibility APIs. It also includes host-language specific requirements where necessary to complete the accessibility model. Examples of host languages include HTML and SVG. However, in order to provide the basic, core mappings of WAI-ARIA, discussion of host-language features are generally avoided. How host languages modify or override the core mappings is specified in separate documents.
この文書には、WAI-ARIA のロール、状態、およびプロパティをプラットフォームのアクセシビリティ API にマッピングする方法を指定するユーザーエージェント向けの情報が含まれています。 また、アクセシビリティモデルを完成させるために必要な場合は、ホスト言語固有の要件も含まれています。 ホスト言語の例には、HTML や SVG が含まれます。 ただし、WAI-ARIA の基本的なコアマッピングを提供するために、ホスト言語機能の説明は一般的に避けられます。 ホスト言語がコアマッピングを変更またはオーバーライドする方法は、別の文書で指定されています。 




1.1 Accessibility APIs  §
1.1 アクセシビリティ API §

To provide access to desktop GUI applications, assistive technologies originally used heuristic techniques to determine the meaning of the user interface and build an alternative off-screen model. For example, a row of labels displayed horizontally near the top of an application window might be a menu. Labels with a border drawn around them might be buttons. Heuristic techniques are not always accurate, however, and require assistive technologies to be updated whenever the software application is updated.
デスクトップ GUI アプリケーションへのアクセスを提供するために、支援技術は元々ヒューリスティックな手法を使用してユーザーインターフェイスの意味を判断し、代替のオフスクリーンモデルを構築しました。 たとえば、アプリケーションウィンドウの上部近くに水平に表示されるラベルの行はメニューである可能性があります。 周囲に境界線が引かれたラベルはボタンの場合があります。 ただし、ヒューリスティックな手法は常に正確であるとは限らず、ソフトウェアアプリケーションが更新されるたびに支援技術を更新する必要があります。

A much better technique is for the software application to provide the necessary information for interoperability with assistive technology. To meet this need, platform owners have developed specialized interfaces, called accessibility APIs, which can be used to communicate accessibility information about user interfaces to assistive technologies. Accessibility APIs allow developers to express the function of controls and text to assistive technologies. Accessibility APIs include a tree of accessible objects (controls and text) and information about each of them:
はるかに優れた手法は、ソフトウェアアプリケーションが支援技術との相互運用性に必要な情報を提供することです。 このニーズを満たすために、プラットフォームの所有者は、ユーザーインターフェイスに関するアクセシビリティ情報を支援技術に伝達するために使用できるアクセシビリティ API と呼ばれる特殊なインターフェイスを開発しました。 アクセシビリティ API を使用すると、開発者はコントロールとテキストの機能を支援技術に表現できます。 アクセシビリティ API には、アクセス可能なオブジェクト（コントロールとテキスト）のツリーと、次のそれぞれに関する情報が含まれています。

    Descriptive properties (role, name, value, position, etc.),
    記述的プロパティ（ロール、名前、値、位置など）、

    Transient states (pressed, focusable, etc.),
    一時的な状態（押された、フォーカス可能など）、

    Events (text changed, button was clicked, checkbox was toggled),
    イベント（テキストが変更された、ボタンがクリックされた、チェックボックスが切り替えられた）、

    Actions the user might take (click, check/toggle, drag, etc.),
    ユーザーが取りうるアクション（クリック、チェック/トグル、ドラッグなど）、

    Relationships (parent/child in the tree, controls, flowsto, etc.), and
    関係性（ツリー内の親/子、コントロール、読み上げ順序など）、および

    Textual content.
    テキストコンテンツ。

In the case of Web pages, the Document Object Model (DOM) is used to represent the structure and state of the elements in the document being rendered by a user agent. The elements of the document are organized into a hierarchy of nodes known as the DOM tree. To interact with static Web content, assistive technologies, such as screen readers, have tended to rely on the DOM provided by the user agent. However, platform accessibility APIs provide a quicker and more comprehensive way for assistive technologies to learn about and interact with Web page content. Especially with UI elements that are known to be interactive, such as HTML form elements and desktop applications, accessibility APIs allow the more complex roles, properties, states, and relationships of those elements to be communicated to assistive technology in a way that the DOM cannot provide on its own.
ウェブページの場合、文書オブジェクトモデル（Document Object Model、DOM）は、ユーザーエージェントによってレンダリングされる文書内の要素の構造と状態を表すために使用されます。 文書の要素は、DOM ツリーと呼ばれるノードの階層に編成されています。 静的なウェブコンテンツと相互作用するために、スクリーンリーダーなどの支援技術は、ユーザーエージェントによって提供される DOM に依存する傾向があります。 ただし、プラットフォームのアクセシビリティ API は、支援技術がウェブページのコンテンツについて学習して相互作用するためのより迅速で包括的な方法を提供します。 特に、HTML フォーム要素やデスクトップアプリケーションなど、相互作用的であることがわかっている UI 要素の場合、アクセシビリティ API を使用すると、これらの要素のより複雑なロール、プロパティ、状態、および関係性を、DOM だけでは提供できない方法で支援技術に伝達できます。

In the case of rich Internet applications, developers use DOM APIs to manipulate objects in the DOM tree to make them behave like interactive desktop GUI applications. In order to make a Web application understandable to assistive technologies, the user agent needs to map accessibility information from the elements in the DOM tree to the Accessibility APIs of the underlying operating system or software platform throughout the lifecycle of the application. The information needed is provided when developers use WAI-ARIA to supply semantic role, state, and property information for elements. The screen reader or other assistive technology uses the semantic information exposed via the accessibility API to provide an alternative rendering of an application that is meaningful to a user.
リッチなインターネットアプリケーションの場合、開発者は DOM API を使用して DOM ツリー内のオブジェクトを操作し、相互作用的なデスクトップ GUI アプリケーションのように振る舞わさせます。 ウェブアプリケーションを支援技術に理解できるようにするために、ユーザーエージェントは、アプリケーションのライフサイクル全体を通じて、「DOM ツリーの要素」から「基盤となるオペレーティングシステムまたはソフトウェアプラットフォームのアクセシビリティ API」にアクセシビリティ情報をマッピングする必要があります。 必要な情報は、開発者が WAI-ARIA を使用して要素の意味論的なロール、状態、およびプロパティの情報を提供するときに提供されます。 スクリーンリーダーまたはその他の支援技術は、アクセシビリティ API を介して公開された意味論的な情報を使用して、ユーザーにとって意味のあるアプリケーションの代替レンダリングを提供します。

Accessibility APIs covered by this document are:
この文書が対象とするアクセシビリティ API は次のとおりです。

    MSAA with IAccessible2 1.3 [IAccessible2]
    IAccessible2 1.3 を使用した MSAA [IAccessible2]

    User Interface Automation [UI-AUTOMATION]
    ユーザーインターフェイスの自動化 [UI-AUTOMATION]

    Linux/GNOME ATK - Accessibility Toolkit [ATK] and Assistive Technology Service Provider Interface [AT-SPI], referred to hereafter as "ATK/AT-SPI"
    Linux / GNOME ATK - アクセシビリティツールキット [ATK] および支援技術サービスプロバイダーインターフェイス [AT-SPI]、以降「ATK / AT-SPI」と呼びます

    macOS Accessibility Protocol [AXAPI]
    macOS アクセシビリティプロトコル [AXAPI] 

The WAI-ARIA 1.0 User Agent Implementation Guide included mappings for UIA Express, also known as IAccessibleEx, which was implemented in Microsoft Internet Explorer 8.0 - 11. New implementations are strongly encouraged to use User Interface Automation instead.
「WAI-ARIA 1.0 ユーザーエージェント実装ガイド」には、Microsoft Internet Explorer 8.0 - 11 で実装された IAccessibleEx とも呼ばれる UIA Express のマッピングが含まれていました。 新しい実装では、代わりに「ユーザーインターフェイスの自動化」を使用することを強くお勧めします。

If user agent developers need to expose information using other accessibility APIs, it is recommended that they work closely with the developer of the platform where the API runs, and assistive technology developers on that platform.
ユーザーエージェントの開発者が他のアクセシビリティ API を使用して情報を公開する必要がある場合は、API が実行されるプラットフォームの開発者、およびそのプラットフォームの支援技術開発者と緊密に連携することをお勧めします。 




1.2 The Accessibility Tree and the DOM Tree §
1.2 アクセシビリティツリーと DOM ツリー §

The accessibility tree and the DOM tree are parallel structures. Roughly speaking the accessibility tree is a subset of the DOM tree. It includes the user interface objects of the user agent and the objects of the document. Accessible objects are created in the accessibility tree for every DOM element that should be exposed to an assistive technology, either because it may fire an accessibility event or because it has a property, relationship or feature which needs to be exposed. Generally if something can be trimmed out it will be, for reasons of performance and simplicity. For example, a <span> with just a style change and no semantics may not get its own accessible object, but the style change will be exposed by other means.
アクセシビリティツリーと DOM ツリーは並列構造です。 大まかに言えば、アクセシビリティツリーは DOM ツリーのサブセットです。 これには、ユーザーエージェントのユーザーインターフェイスオブジェクトと文書のオブジェクトが含まれます。 アクセス可能なオブジェクトは、アクセシビリティイベントを発火させる可能性があるため、または公開する必要のあるプロパティ、関係性、機能があるため、支援技術に公開する必要があるすべての DOM 要素についてアクセシビリティツリーに作成されます。 一般に、パフォーマンスと単純さの理由から、何かをトリミングできる場合は、そうします。 たとえば、スタイルが変更されただけで意味論がない <span> は、独自のアクセス可能なオブジェクトを取得できない場合がありますが、スタイルの変更は他の手段で公開されます。 




1.3 Comparing Accessibility APIs §
1.3 アクセシビリティ API の比較 §

For various technological and historical reasons, accessibility APIs do not all work in the same way. In many cases, there is no simple one-to-one relationship between how each of them names or exposes roles, states, and properties to user agents. The following subsections describe a few of the distinguising characteristics of some of the APIs.
さまざまな技術的および歴史的な理由により、アクセシビリティ API はすべて同じように機能するわけではありません。 多くの場合、それぞれがロール、状態、およびプロパティをユーザーエージェントに命名または公開する方法の間には、単純な1対1の関係性はありません。 次のサブセクションでは、いくつかの API の特徴的な特性のいくつかについて説明します。 




1.3.1 ATK/AT-SPI §

MSAA, IAccessible2, UIA, and AX API each define an API that is shared by both the software application exposing information about its content and interactive components, and the user agent (assistive technology) consuming that information. Conversely, Linux/GNOME separates that shared interface into its two aspects, each represented by a different accessibility API, ATK or AT-SPI.
MSAA、IAccessible2、UIA、および AX API はそれぞれ、コンテンツと相互作用的なコンポーネントに関する情報を公開するソフトウェアアプリケーションと、その情報を消費するユーザーエージェント（支援技術）の両方によって共有される API を定義します。 逆に、Linux / GNOME は、その共有インターフェイスを2つの側面に分け、それぞれが異なるアクセシビリティ API、ATK または AT-SPI によって表されます。

ATK defines an interface that is implemented by software in order to expose accessibility information, whereas AT-SPI is a desktop service that gathers accessibility information from active applications and relays it to other interested applications, usually assistive technologies.
ATK は、アクセシビリティ情報を公開するためにソフトウェアによって実装されるインターフェイスを定義しますが、AT-SPI は、アクティブなアプリケーションからアクセシビリティ情報を収集し、それを他の関心のあるアプリケーション（通常は支援技術）に中継するデスクトップサービスです。

For example, the GNOME GUI toolkit [GTK], implements the relevant aspects of ATK for each widget (menu, ---comobox---+++combobox+++, checkbox, etc.) in order that GTK widgets expose accessibility information about themselves. AT-SPI then acquires the information from applications built with GTK and makes it available to interested parties.
たとえば、GNOME GUI ツールキット [GTK] は、GTK ウィジェットが自身に関するアクセシビリティ情報を公開するために、各ウィジェット（メニュー、コンボボックス、チェックボックスなど）に ATK の関連する側面を実装します。 AT-SPI は、GTK で構築されたアプリケーションから情報を取得し、関係者が利用できるようにします。

ATK is most relevant to implementors, wherease AT-SPI is relevant to consumers. In the context of mapping WAI-ARIA roles, states and properties, user agents are implementors and use ATK. Asisstive Technologies are consumers, and use AT-SPI.
ATK は実装者に最も関連があり、AT-SPI は消費者に関連しています。 WAI-ARIA のロール、状態、およびプロパティのマッピングのコンテキストでは、ユーザーエージェントは実装者であり、ATK を使用します。 支援技術は消費者であり、AT-SPI を使用します。




1.3.2 UIA (UI Automation) §
1.3.2 UIA（UI の自動化） §

UI Automation expresses every element of the application user interface as an automation element. Automation elements form the nodes of the application accessibility tree, that can be queried, traversed and interacted with by automation clients.
UI の自動化（UI Automation）は、アプリケーションのユーザーインターフェイスのすべての要素を自動化要素として表現します。 自動化要素は、アプリケーションのアクセシビリティツリーのノードを形成し、自動化クライアントが照会したり、トラバースしたり、相互作用したりできます。 

There are several concepts central to UI Automation:
UI の自動化の中心となるいくつかの概念があります。

    Automation element - controls and some application content is presented as automation elements.
    自動化要素（Automation element） - コントロールと一部のアプリケーションコンテンツは、自動化要素として表されます。

    Element properties - Automation elements have several common properties describing native framework element characteristics in an agnostic way that all automation clients can understand. There are several ways to access element property values, described below.
    要素のプロパティ（Element properties） - 自動化要素には、すべての自動化クライアントが理解できる不可知論的な方法でネイティブなフレームワーク要素の特性を説明するいくつかの共通のプロパティがあります。 以下に説明するように、要素のプロパティ値にアクセスする方法はいくつかあります。

    Control Patterns - Some common interactivity in different frameworks is expressed as control patterns in UIA, allowing different automation client to interact with controls using common programmatic interfaces.
    コントロールパターン（Control Patterns） - さまざまなフレームワークでのいくつかの一般的な相互作用性は、UIA でコントロールパターンとして表され、さまざまな自動化クライアントが共通のプログラムインターフェイスを使用して制御と相互作用できるようにします。

    Events - Similarly to other accessibility APIs, automation elements support various events that allow automation providers notify clients on important state changes.
    イベント（Events） - 他のアクセシビリティ API と同様に、自動化要素は、自動化プロバイダーが重要な状態変化についてクライアントに通知できるようにするさまざまなイベントをサポートします。

All automation elements inherit from the IUIAutomationElement interface and all properties that are not specific to a particular control pattern can be queried through that interface. There are several ways to access UI Automation element properties:
すべての自動化要素は IUIAutomationElement インターフェイスから継承し、特定のコントロールパターンに固有ではないすべてのプロパティは、そのインターフェイスを介して照会できます。 UI 自動化要素のプロパティにアクセスするには、いくつかの方法があります。

    Direct property accessors to the current values - Current{PropertyName}, e.g. IUIAutomationElement::CurrentName for the Name property
    現在の値への直接プロパティアクセサー - Current{PropertyName}、例： Name プロパティの IUIAutomationElement::CurrentName

    Cached property accessors - Cached{PropertyName}, e.g. IUIAutomationElement::CachedName for the Name property. Using cached values is preferred when providers and clients are used in remote environments.
    キャッシュされたプロパティアクセサー - Cached{PropertyName}、例： Name プロパティの IUIAutomationElement::CachedName。プロバイダーとクライアントがリモート環境で使用される場合は、キャッシュされた値を使用することをお勧めします。

    GetCurrentPropertyValue and passing the UIA Property ID enumeration value corresponding to that property to get the current value, e.g. IUIAutomationElement::GetCurrentPropertyValue(UIA_NamePropertyId) for the Name property.
    GetCurrentPropertyValue に、そのプロパティに対応する UIA プロパティ ID 列挙値を渡して、現在の値を取得します。 例： Name プロパティの IUIAutomationElement::GetCurrentPropertyValue(UIA_NamePropertyId)。

    GetCachedPropertyValue and passing the UIA Property ID enumeration value corresponding to that property to get the cached value, e.g. IUIAutomationElement::GetCachedPropertyValue(UIA_NamePropertyId) for the Name property.
    GetCachedPropertyValue に、そのプロパティに対応する UIA プロパティ ID 列挙値を渡して、キャッシュされた値を取得します。 例： Name プロパティの IUIAutomationElement::GetCachedPropertyValue(UIA_NamePropertyId)。

Properties for specific UIA control patterns are queried the same way using relevant control pattern interfaces. Taking Toggle Pattern as an example, to query the ToggleState property clients can use IUIAutomationTogglePattern::CurrentToggleState or IUIAutomationTogglePattern::GetCurrentPropertyValue(UIA_ToggleToggleStatePropertyId) to get the current value.
特定の UIA コントロールパターンのプロパティは、関連するコントロールパターンインターフェイスを使用して同じ方法で照会されます。 Toggle Pattern を例にとると、ToggleState プロパティを照会するには、クライアントは IUIAutomationTogglePattern::CurrentToggleState または IUIAutomationTogglePattern::GetCurrentPropertyValue(UIA_ToggleToggleStatePropertyId) を使用して現在の値を取得できます。

The property mapping in this specification provide the {PropertyName} and do not specify all specific ways to access the property value. Automation clients can access current or cached values using conventions described above, depending on specific needs and coding style conventions.
この仕様のプロパティマッピングは {PropertyName} を提供し、プロパティ値にアクセスするためのすべての特定の方法を指定するわけではありません。 自動化クライアントは、特定のニーズとコーディングスタイルの規則に応じて、上記の規則を使用して現在の値またはキャッシュされた値にアクセスできます。 




1.3.3 Accessible Names and Descriptions §
1.3.3 アクセス可能な名前と説明 §

Each platform accessibility API includes a way to assign and retrieve accessible name and accessible description properties for each accessible object created in the accessibility tree. How these the relevant properties are implemented and what they are called vary depending on the API.
各プラットフォームのアクセシビリティ API には、アクセシビリティツリーで作成された各アクセス可能なオブジェクトにアクセス可能な名前とアクセス可能な説明のプロパティを割り当てて取得する方法が含まれています。 これらの関連するプロパティがどのように実装され、それらが何と呼ばれるかは、API によって異なります。

For instance, in MSAA, all accessible objects support the accName property, which stores the object's accessible name. Where the object also supports having an accessible description, MSAA stores this property in the object's accDescription property.
たとえば、MSAA では、すべてのアクセス可能なオブジェクトは、オブジェクトのアクセス可能な名前を格納する accName プロパティをサポートします。 オブジェクトがアクセス可能な説明を持つこともサポートしている場合、MSAA はこのプロパティをオブジェクトの accDescription プロパティに格納します。

Software using ATK can read and write to an object's accessible-name and accessible-description properties. In turn, AT-SPI can query the values of those properties through its atspi_accessible_get_name and atspi_accessible_get_description functions.
ATK を使用するソフトウェアは、オブジェクトの accessible-name プロパティと accessible-description プロパティの読み取りと書き込みを行うことができます。 次に、AT-SPI は、atspi_accessible_get_name 関数と atspi_accessible_get_description 関数を介してこれらのプロパティの値を照会できます。

Automation elements in the UIA accessibility tree have a Name property. Where the object also supports having an accessible description, UIA stores this property in the object's FullDescription property.
UIA アクセシビリティツリーの自動化要素には、Name プロパティがあります。 オブジェクトがアクセス可能な説明を持つこともサポートしている場合、UIA はこのプロパティをオブジェクトの FullDescription プロパティに格納します。

The approach to accessible names and accessible descriptions in AX API is somewhat different to the other platform APIs. Accessible names are exposed using the AXTitle property when the name is visually rendered, while the AXDescription property is used when the object's name is not rendered visually. An object's accessible description, where provided, should always be exposed in the AXHelp property.
AX API でのアクセス可能な名前とアクセス可能な説明へのアプローチは、他のプラットフォーム API とは多少異なります。 アクセス可能な名前は、名前が視覚的にレンダリングされるときに AXTitle プロパティを使用して公開され、AXDescription プロパティは、オブジェクトの名前が視覚的にレンダリングされないときに使用されます。 オブジェクトのアクセス可能な説明が提供されている場合は、常に AXHelp プロパティで公開する必要があります。

For more detail, see the Accessible Name and Description Computation and API Mappings specification.
詳細については、「アクセス可能な名前と説明の計算と API マッピング（Accessible Name and Description Computation and API Mappings）」の仕様を参照してください。（訳注：文書名が変更されている）




2. Conformance §
2. 準拠　§

As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.
非規範的としてマークされたセクションと同様に、この仕様のすべてのオーサリングガイドライン、図、例、および注記は非規範的です。 この仕様の他のすべては規範的です。

The key words MAY, MUST, MUST NOT, OPTIONAL, SHOULD, and SHOULD NOT are to be interpreted as described in [RFC2119].
キーワード MAY、MUST、MUST NOT、OPTIONAL、SHOULD、SHOULD NOT は、[RFC2119] で説明されているように解釈されます。 




2.1 RFC-2119 Keywords §
2.1 RFC-2119 キーワード §


RFC-2119 keywords are formatted in uppercase and contained in a strong element with class="rfc2119". When the keywords shown above are used, but do not share this format, they do not convey formal information in the RFC 2119 sense, and are merely explanatory, i.e., informative. As much as possible, such usages are avoided in this specification.
RFC-2119 キーワードは大文字でフォーマットされ、class="rfc2119" の strong 要素に含まれています。 上記のキーワードが使用されているが、この形式を共有していない場合、RFC 2119 の意味での正式な情報は伝達されず、単なる説明、つまり情報的なものにすぎません。 この仕様では、このような使用は可能な限り回避されています。 




2.2 Normative and Informative Sections §
2.2 規範的なセクションと情報的なセクション §

The indication whether a section is normative or non-normative (informative) applies to the entire section including sub-sections.
セクションが規範的（normative）であるか非規範的（non-normative。 情報的、informative）であるかの表示は、サブセクションを含むセクション全体に適用されます。

Informative sections provide information useful to understanding the specification. Such sections may contain examples of recommended practice, but it is not required to follow such recommendations in order to conform to this specification.
情報的なセクションは、仕様を理解するのに役立つ情報を提供します。 このようなセクションには、推奨される方法の例が含まれている場合がありますが、この仕様に準拠するためにこのような勧告に従う必要はありません。 




2.3 Features Deprecated in WAI-ARIA §
2.3 WAI-ARIA で非推奨となった機能 §


The WAI-ARIA specification lists some features as deprecated. Although this means authors are encouraged not to use such features, it is expected that the features could still be used in legacy content. Therefore, it is important that user agents continue to map these features to accessibility APIs, and doing so is part of conformance to this specification. When future versions of the WAI-ARIA specification change such features from deprecated to removed, they will be removed from the mappings as well and user agents will no longer be asked to continue support for those features.
WAI-ARIA 仕様には、一部の機能が非推奨（deprecated）としてリストされています。 これは、作成者がそのような機能を使用しないことを推奨していることを意味しますが、機能は引き続きレガシーコンテンツで使用されると予想されます。 したがって、ユーザーエージェントが引き続きこれらの機能をアクセシビリティ API にマッピングすることが重要であり、そうすることはこの仕様への準拠の一部です。 WAI-ARIA 仕様の将来のバージョンでこのような機能が非推奨から削除（removed）に変更されると、それらもマッピングから取り除かれ、ユーザーエージェントはこれらの機能のサポートを継続するように求められなくなります。 




3. Important Terms §
3. 重要な用語 §

While some terms are defined in place, the following definitions are used throughout this document.
いくつかの用語はその場で定義されていますが、この文書全体を通じて次の定義が使用されています。 




Accessibility API
アクセシビリティ API（Accessibility API）

    Operating systems and other platforms provide a set of interfaces that expose information about objects and events to assistive technologies. Assistive technologies use these interfaces to get information about and interact with those widgets. Examples of accessibility APIs are Microsoft Active Accessibility [MSAA], Microsoft User Interface Automation [UI-AUTOMATION], MSAA with UIA Express [UIA-EXPRESS], the Mac OS X Accessibility Protocol [AXAPI], the Linux/Unix Accessibility Toolkit [ATK] and Assistive Technology Service Provider Interface [AT-SPI], and IAccessible2 [IAccessible2].
     オペレーティングシステムおよびその他のプラットフォームは、オブジェクトおよびイベントに関する情報を支援技術に公開する一連のインターフェイスを提供します。 支援技術は、これらのインターフェイスを使用して、これらのウィジェットに関する情報を取得し、それらと相互作用します。 アクセシビリティ API の例としては、Microsoft Active Accessibility [MSAA]、Microsoft User Interface Automation [UI-AUTOMATION]、MSAA with UIA Express [UIA-EXPRESS]、Mac OS X Accessibility Protocol [AXAPI]、Linux / Unix Accessibility Toolkit [ATK] と Assistive Technology Service Provider Interface [AT-SPI]、および IAccessible2 [IAccessible2] などがあります。




Accessibility Subtree
アクセシビリティサブツリー（Accessibility Subtree）

    An accessible object in the accessibility tree and its descendants in that tree. It does not include objects which have relationships other than parent-child in that tree. For example, it does not include objects linked via aria-flowto unless those objects are also descendants in the accessibility tree.
     アクセシビリティツリー内のアクセス可能なオブジェクトとそのツリー内のその子孫。 そのツリーに親子以外の関係性を持つオブジェクトは含まれません。 たとえば、それらのオブジェクトがアクセシビリティツリーの子孫でもない限り、aria-flowto を介してリンクされたオブジェクトは含まれません。 




Accessibility Tree
アクセシビリティツリー（Accessibility Tree）

    Tree of accessible objects that represents the structure of the user interface (UI). Each node in the accessibility tree represents an element in the UI as exposed through the accessibility API; for example, a push button, a check box, or container.
     ユーザーインターフェイス（UI）の構造を表すアクセス可能なオブジェクトのツリー。 アクセシビリティツリーの各ノードは、アクセシビリティ API を介して公開される UI の要素を表します。 たとえば、プッシュボタン、チェックボックス、またはコンテナなどです。



Accessible Description
アクセス可能な説明（Accessible Description）

    An accessible description provides additional information, related to an interface element, that complements the accessible name. The accessible description might or might not be visually perceivable.
     アクセス可能な説明は、アクセス可能な名前を補完する、インターフェイス要素に関連する追加情報を提供します。 アクセス可能な説明は、視覚的に認識できる場合とできない場合があります。 




Accessible Name
アクセス可能な名前（Accessible Name）

    The accessible name is the name of a user interface element. Each platform accessibility API provides the accessible name property. The value of the accessible name may be derived from a visible (e.g., the visible text on a button) or invisible (e.g., the text alternative that describes an icon) property of the user interface element. See related accessible description.
     アクセス可能な名前は、ユーザーインターフェイス要素の名前です。 各プラットフォームのアクセシビリティ API は、アクセス可能な名前のプロパティを提供します。 アクセス可能な名前の値は、ユーザーインターフェイス要素の表示（ボタンの表示テキストなど）または非表示（アイコンを説明する代替テキストなど）のプロパティから取得できます。 関連するアクセス可能な説明を参照してください。

    A simple use for the accessible name property may be illustrated by an "OK" button. The text "OK" is the accessible name. When the button receives focus, assistive technologies may concatenate the platform's role description with the accessible name. For example, a screen reader may speak "push-button OK" or "OK button". The order of concatenation and specifics of the role description (e.g., "button", "push-button", "clickable button") are determined by platform accessibility APIs or assistive technologies.
     アクセス可能な名前のプロパティの簡単な使用法は、「OK」ボタンで示されます。 「OK」というテキストはアクセス可能な名前です。 ボタンがフォーカスを受け取ると、支援技術がプラットフォームのロールの説明をアクセス可能な名前に連結する場合があります。 たとえば、スクリーンリーダーは「プッシュボタン OK」または「OK ボタン」と話すことができます。 連結の順序とロールの説明の詳細（「ボタン」、「プッシュボタン」、「クリック可能なボタン」など）は、プラットフォームのアクセシビリティ API または支援技術によって決定されます。 




Accessible object
アクセス可能なオブジェクト（Accessible object）

    A node in the accessibility tree of a platform accessibility API. Accessible objects expose various states, properties, and events for use by assistive technologies. In the context of markup languages (e.g., HTML and SVG) in general, and of WAI-ARIA in particular, markup elements and their attributes are represented as accessible objects.
     プラットフォームのアクセシビリティ API のアクセシビリティツリー内のノード。 アクセス可能なオブジェクトは、支援技術で使用するためのさまざまな状態、プロパティ、およびイベントを公開します。 一般にマークアップ言語（HTML や SVG など）、特に WAI-ARIA のコンテキストでは、マークアップ要素とその属性はアクセス可能なオブジェクトとして表されます。 




Assistive Technologies
支援技術（Assistive Technologies）

    Hardware and/or software that:
    次のようなハードウェアおよび/またはソフトウェア：

        relies on services provided by a user agent to retrieve and render Web content
        ウェブコンテンツの取得とレンダリングは、ユーザーエージェントが提供するサービスに依存し、

        works with a user agent or web content itself through the use of APIs, and
        API を使用して、ユーザーエージェントまたはウェブコンテンツ自体と連携し、

        provides services beyond those offered by the user agent to facilitate user interaction with web content by people with disabilities
        ユーザーエージェントが提供するサービス以外のサービスを提供して、障害を持つ人々によるウェブコンテンツとのユーザーとの相互作用を促進します

    This definition may differ from that used in other documents.
    この定義は、他の文書で使用されているものとは異なる場合があります。

    Examples of assistive technologies that are important in the context of this document include the following:
    この文書のコンテキストで重要な支援技術の例には、次のものがあります。

        screen magnifiers, which are used to enlarge and improve the visual readability of rendered text and images;
        画面拡大鏡（screen magnifiers）。 レンダリングされたテキストや画像の視覚的な読みやすさを拡大および改善するために使用されます。

        screen readers, which are most-often used to convey information through synthesized speech or a refreshable Braille display;
        スクリーンリーダー（screen readers）。 合成音声または点字ディスプレイを介して情報を伝達するために最もよく使用されます。

        text-to-speech software, which is used to convert text into synthetic speech;
        テキストを合成音声に変換するために使用されるテキスト読み上げソフトウェア（text-to-speech software）。

        speech recognition software, which is used to allow spoken control and dictation;
        音声制御と口述を可能にするために使用される音声認識ソフトウェア（speech recognition software）。

        alternate input technologies (including head pointers, on-screen keyboards, single switches, and sip/puff devices), which are used to simulate the keyboard;
        キーボードのシミュレーションに使用される代替入力技術（ヘッドポインター（head pointers）、オンスクリーンキーボード（on-screen keyboards）、シングルスイッチ（single switches）、および息操作（Sip-and-puff）デバイスを含む）。

        alternate pointing devices, which are used to simulate mouse pointing and clicking.
        マウスのポインティングとクリックをシミュレートするために使用される代替ポインティングデバイス。





Attribute
属性（Attribute、アトリビュート）

    In this specification, attribute is used as it is in markup languages. Attributes are structural features added to elements to provide information about the states and properties of the object represented by the element.
    この仕様では、属性はマークアップ言語のものをそのまま使用します。 属性は、要素によって表されるオブジェクトの状態とプロパティに関する情報を提供するために要素に追加される構造的な特徴です。




Class
クラス（Class）

    A set of instance objects that share similar characteristics.
    同様の特性を共有する一連のインスタンスオブジェクト。 




Desktop focus event
デスクトップフォーカスイベント（Desktop focus event）

    Event from/to the host operating system via the accessibility API, notifying of a change of input focus.
    アクセシビリティ API を介したホストオペレーティングシステムとの間のイベント。 入力フォーカスの変更を通知します。 




Element
要素（Element）

    In this specification, element is used as it is in markup languages. Elements are the structural elements in markup language that contains the data profile for objects.
    この仕様では、要素はマークアップ言語のものをそのまま使用します。 要素は、オブジェクトのデータプロファイルを含むマークアップ言語の構造要素です。 




Event
イベント（Event）

    A programmatic message used to communicate discrete changes in the state of an object to other objects in a computational system. User input to a web page is commonly mediated through abstract events that describe the interaction and can provide notice of changes to the state of a document object. In some programming languages, events are more commonly known as notifications.
    オブジェクトの状態の個別の変化を計算システム内の他のオブジェクトに伝達するために使用されるプログラムメッセージ。 ウェブページへのユーザー入力は、通常、相互作用を説明し、文書オブジェクトの状態の変更を通知できる抽象的なイベントによって仲介されます。 一部のプログラミング言語では、イベントはより一般的に通知（notifications）として知られています。 




Hidden
非表示（Hidden）

    Indicates that the element is not visible, perceivable, or interactive to any user. An element is considered hidden if it or any one of its ancestor elements is not rendered or is explicitly hidden.
    要素がどのユーザーにも可視、認識可能、または相互作用的ではないことを示します。 要素またはその祖先要素のいずれかがレンダリングされていないか、明示的に非表示になっている場合、その要素は非表示と見なされます。 




Informative
情報的（Informative）

    Content provided for information purposes and not required for conformance. Content required for conformance is referred to as normative.
    情報提供を目的として提供され、準拠のために必要とされないコンテンツ。 準拠に必要なコンテンツは規範的と呼ばれます。 




Keyboard Accessible
キーボードでアクセス可能（Keyboard Accessible）

    Accessible to the user using a keyboard or assistive technologies that mimic keyboard input, such as a sip and puff tube. References in this document relate to WCAG 2.0 Guideline 2.1: Make all functionality available from a keyboard [WCAG20].
    キーボードまたはキーボード入力を模倣する支援技術（息操作チューブなど）を使用して、ユーザーがアクセスできます。 この文書の参照は、「WCAG 2.0 ガイドライン 2.1：すべての機能をキーボードから利用できるようにする [WCAG20]」に関連しています。 




Live Region
ライブリージョン（Live Region）

    Live regions are perceivable regions of a web page that are typically updated as a result of an external event when user focus may be elsewhere. These regions are not always updated as a result of a user interaction. This practice has become commonplace with the growing use of Ajax. Examples of live regions include a chat log, stock ticker, or a sport scoring section that updates periodically to reflect game statistics. Since these asynchronous areas are expected to update outside the user's area of focus, assistive technologies such as screen readers have either been unaware of their existence or unable to process them for the user. WAI-ARIA has provided a collection of properties that allow the author to identify these live regions and process them: aria-live, aria-relevant, aria-atomic, and aria-busy.
    ライブリージョンは、ユーザーフォーカスが他の場所にある可能性がある場合に、外部イベントの結果として通常更新されるウェブページの認識可能なリージョンです。 これらのリージョンは、ユーザーとの相互作用の結果として常に更新されるとは限りません。 この慣行は、Ajax の使用が増えるにつれて当たり前になっています。 ライブリージョンの例には、チャットログ、株式相場表示、または試合の統計を反映するために定期的に更新されるスポーツの得点のセクションが含まれます。 これらの非同期領域はユーザーのフォーカス領域外で更新されることが予想されるため、スクリーンリーダーなどの支援技術は、それらの存在を認識していないか、ユーザーのためにそれらを処理できませんでした。 WAI-ARIA は、作成者がこれらのライブリージョンを識別して処理できるようにする aria-live、aria-relevant、aria-atomic、および aria-busy というプロパティのコレクションを提供しています。 




Managed State
管理された状態（Managed State）

    Accessibility API state that is controlled by the user agent, such as focus and selection. These are contrasted with "unmanaged states" that are typically controlled by the author. Nevertheless, authors can override some managed states, such as aria-posinset and aria-setsize. Many managed states have corresponding CSS pseudo-classes, such as :focus, and pseudo-elements, such as ::selection, that are also updated by the user agent.
    フォーカスや選択など、ユーザーエージェントによって制御されるアクセシビリティ API の状態。 これらは、通常、作成者によって制御される「管理されていない状態」とは対照的です。 それでも、作成者は aria-posinset や aria-setsize などの一部の管理された状態をオーバーライドできます。 多くの管理された状態には、対応する CSS の :focus などの疑似クラスと、::selection などの疑似要素があり、これらもユーザーエージェントによって更新されます。 




Node
ノード（Node）

    Basic type of object in the DOM tree or accessibility tree. DOM nodes are further specified as Element or Text nodes, among other types. The nodes of an accessibility tree are accessible objects.
    DOM ツリーまたはアクセシビリティツリーの中のオブジェクトの基本的なタイプ。 DOM ノードは、さらに要素ノードまたはテキストノードなどのタイプに分けられます。 アクセシビリティツリーのノードはアクセス可能なオブジェクトです。 




Normative
規範的（Normative）

    Required for conformance. By contrast, content identified as informative or "non-normative" is not required for conformance.
    準拠に必要です。 対照的に、情報的または「非規範的」と識別されたコンテンツは、準拠のために必要ではありません。 




Object
オブジェクト（Object）

    In the context of user interfaces, an item in the perceptual user experience, represented in markup languages by one or more elements, and rendered by user agents.
    ユーザーインターフェイスのコンテキストでは、1つ以上の要素によってマークアップ言語で表され、ユーザーエージェントによってレンダリングされる、知覚的なユーザーエクスペリエンスの項目。

    In the context of programming, the instantiation of one or more classes and interfaces which define the general characteristics of similar objects. An object in an accessibility API may represent one or more DOM objects. Accessibility APIs have defined interfaces that are distinct from DOM interfaces.
    プログラミングのコンテキストでは、類似したオブジェクトの一般的な特性を定義する1つ以上のクラスとインターフェイスのインスタンス化。 アクセシビリティ API のオブジェクトは、1つ以上の DOM オブジェクトを表す場合があります。 アクセシビリティ API には、DOM インターフェイスとは異なるインターフェイスが定義されています。 




Owned Element
所有要素（Owned Element）

    An 'owned element' is any DOM descendant of the element, any element specified as a child via aria-owns, or any DOM descendant of the owned child.
     「所有要素」とは、要素の DOM 子孫、aria-owns を介して子として指定された要素、または所有された子の DOM 子孫です。 




Perceivable
知覚可能（Perceivable）

    Presentable to users in ways they can sense. References in this document relate to WCAG 2.0 Principle 1: Content must be perceivable [WCAG20].
    ユーザーが感知できる方法でユーザーに提示できます。 この文書での参照は、「WCAG 2.0 原則 1：コンテンツは知覚可能でなければならない [WCAG20]」に関連しています。




Property
プロパティ（Property）

    Attributes that are essential to the nature of a given object, or that represent a data value associated with the object. A change of a property may significantly impact the meaning or presentation of an object. Certain properties (for example, aria-multiline) are less likely to change than states, but note that the frequency of change difference is not a rule. A few properties, such as aria-activedescendant, aria-valuenow, and aria-valuetext are expected to change often. See clarification of states versus properties.
    特定のオブジェクトの性質に不可欠な属性、またはオブジェクトに関連付けられたデータ値を表す属性。 プロパティの変更は、オブジェクトの意味や表現（presentation、プレゼンテーション）に大きな影響を与える可能性があります。 特定のプロパティ（たとえば、aria-multiline）は、状態（states）よりも変更される可能性が低くなりますが、変更の頻度の違いは規則ではないことに注意してください。 aria-activedescendant、aria-valuenow、aria-valuetext などのいくつかのプロパティは頻繁に変更されると予想されます。 状態とプロパティの明確化を参照してください。 




Relationship
関係性（Relationship、リレーションシップ）

   A connection between two distinct things. Relationships may be of various types to indicate which object labels another, controls another, etc.
    2つの異なるものの間の接続。 関係性には、どのオブジェクトが別のオブジェクトにラベルを付けるかや、別のオブジェクトを制御するかなどを示すために、さまざまなタイプがあります。


Role
ロール（Role、役割）

    Main indicator of type. This semantic association allows tools to present and support interaction with the object in a manner that is consistent with user expectations about other objects of that type.
    タイプの主なインジケーター。 この意味論的な関連付けにより、ツールは、そのタイプの他のオブジェクトに関するユーザーの期待と一致する方法で、オブジェクトとの相互作用を提示およびサポートできます。




Semantics
意味論（Semantics、セマンティックス）

    The meaning of something as understood by a human, defined in a way that computers can process a representation of an object, such as elements and attributes, and reliably represent the object in a way that various humans will achieve a mutually consistent understanding of the object.
     コンピュータが要素や属性などのオブジェクトの表現を処理し、さまざまな人間がオブジェクトの相互に一貫した理解を達成する方法でオブジェクトを確実に表現できるように定義された、人間が理解するものの意味。 




State
状態（State、ステート）


    A state is a dynamic property expressing characteristics of an object that may change in response to user action or automated processes. States do not affect the essential nature of the object, but represent data associated with the object or user interaction possibilities. See clarification of states versus properties.
    状態は、ユーザーのアクションまたは自動化されたプロセスに応じて変化する可能性のあるオブジェクトの特性を表す動的なプロパティです。 状態はオブジェクトの本質的な性質には影響しませんが、オブジェクトまたはユーザーとの相互作用の可能性に関連するデータを表します。 状態とプロパティの明確化を参照してください。 




Text node
テキストノード（Text node）

    Type of DOM node that represents the textual content of an attribute or an element. A Text node has no child nodes.
    属性または要素のテキストコンテンツを表す DOM ノードのタイプ。 テキストノードには子ノードがありません。 




Understandable
理解可能（Understandable）

    Presentable to users in ways they can construct an appropriate meaning. References in this document relate to WCAG 2.0 Principle 3: Information and the operation of user interface must be understandable [WCAG20].
    適切な意味を構築できる方法でユーザーに提示できます。 この文書での参照は、「WCAG 2.0 原則 3：ユーザーインターフェイスの情報と操作が理解できる必要がある [WCAG20]」に関連しています。 




User Agent
ユーザーエージェント（User Agent）

    Any software that retrieves, renders and facilitates end user interaction with Web content. This definition may differ from that used in other documents.
    ウェブコンテンツを取得し、レンダリングし、エンドユーザーとの相互作用を容易にするソフトウェア。 この定義は、他の文書で使用されているものとは異なる場合があります。 




Valid IDREF
有効な IDREF（Valid IDREF）

    A reference to a target element in the same document that has a matching ID
    ID が一致する同じ文書内の対象要素への参照 




Widget
ウィジェット（Widget）

    Discrete user interface object with which the user can interact. Widgets range from simple objects that have one value or operation (e.g., check boxes and menu items), to complex objects that contain many managed sub-objects (e.g., trees and grids).
    ユーザーが相互作用できる個別のユーザーインターフェイスオブジェクト。 ウィジェットは、1つの値または操作を持つ単純なオブジェクト（チェックボックスやメニュー項目など）から、多数の管理されたサブオブジェクトを含む複雑なオブジェクト（ツリーやグリッドなど）までさまざまです。 





4. Supporting Keyboard Navigation §
4. キーボードナビゲーションのサポート §

Enabling keyboard navigation in web applications is a necessary step toward making them accessible. User agents MUST provide a mechanism for authors to specify that any renderable element may be focusable without placing the element in a pre-defined tabbing order.
ウェブアプリケーションでキーボードナビゲーションを有効にすることは、それらにアクセスできるようにするために必要なステップです。 ユーザーエージェントは、事前定義されたタブ順序で要素を配置せずに、レンダリング可能な要素がフォーカス可能であることを指定するメカニズムを作成者に提供する必要があります（MUST）。

User agents MUST also provide programmatic access to all focusable elements. This allows for device-independent access, is needed to conform to the User Agent Accessibility Guidelines [UAAG10], and is vital for a successful implementation of WAI-ARIA.
ユーザーエージェントは、すべてのフォーカス可能な要素へのプログラムによるアクセスも提供する必要があります（MUST）。 これは、デバイスに依存しないアクセスを可能にするもので、「ユーザーエージェントアクセシビリティガイドライン [UAAG10]」に準拠するために必要であり、WAI-ARIA の実装を成功させるために不可欠なものです。

Usable keyboard navigation in a rich Internet application is different from the tabbing paradigm among interactive elements, such as links and form controls, in a static document. In rich internet applications, the user tabs to significantly complex widgets, such as a menu or spreadsheet, and uses the arrow keys to navigate within the widget. The changes that WAI-ARIA introduces to keyboard navigation make this enhanced accessibility possible. In WAI-ARIA, any element can be keyboard focusable. In addition to host language mechanisms such as tabindex, aria-activedescendant provides another mechanism for keyboard operation. Most other aspects of WAI-ARIA widget development depend on keyboard navigation functioning properly.
リッチなインターネットアプリケーションで使用できるキーボードナビゲーションは、静的な文書内のリンクやフォームコントロールなどの相互作用的な要素間のタブ移動パラダイムとは異なります。 リッチなインターネットアプリケーションでは、ユーザーはメニューやスプレッドシートなどの非常に複雑なウィジェットにタブ移動し、矢印キーを使用してウィジェット内をナビゲートします。 WAI-ARIA がキーボードナビゲーションに導入した変更により、この強化されたアクセシビリティが可能になります。 WAI-ARIA では、どの要素でもキーボードでフォーカスできます。 tabindex などのホスト言語メカニズムに加えて、aria-activedescendant はキーボード操作のための別のメカニズムを提供します。 WAI-ARIA ウィジェット開発の他のほとんどの側面は、キーボードナビゲーションが正しく機能することに依存しています。

Assistive technologies often need to set the focus. For example, voice input software, onscreen keyboards and screen readers supply their own structured navigation modes, providing additional commands for moving to elements in a page. User agents need to allow assistive technologies to set the focus. See the section titled "Handling focus changes from the Assistive Technology" for details.
多くの場合、支援技術はフォーカスを設定する必要があります。 たとえば、音声入力ソフトウェア、オンスクリーンキーボード、スクリーンリーダーは、独自の構造化されたナビゲーションモードを提供し、ページ内の要素に移動するための追加のコマンドを提供します。 ユーザーエージェントは、支援技術がフォーカスを設定できるようにする必要があります。 詳細については、「支援技術からのフォーカス変更の処理」というタイトルのセクションを参照してください。




4.1 Focus States and Events Table §
4.1 フォーカスの状態とイベントの表 §

The following table defines the accessibility API keyboard focus states and events used in later sections of the document.
次の表は、文書の後のセクションで使用されるアクセシビリティ API のキーボードのフォーカスの状態とイベントを定義しています。

    If the context is controlling focus with tabindex, the DOM focus (document.activeElement) is in sync with the focus states and events listed in the table.
    コンテキストが tabindex によりフォーカスを制御している場合、DOM フォーカス（document.activeElement）は、表にリストされているフォーカスの状態およびイベントと同期しています。

    If the context is controlling focus with aria-activedescendant, the DOM focus is separate from the focus states and events for the MSAA, Microsoft UIA, and ATK/AT-SPI columns of the table.
    コンテキストが aria-activedescendant によりフォーカスを制御している場合、DOM フォーカスは、表の MSAA、Microsoft UIA、および ATK / AT-SPI 列のフォーカスの状態およびイベントとは別のものです。

    Note
    注

    An example is a single-selection listbox that controls focus using aria-activedescendant instead of tabindex. The option children are all marked with the focusable state in the accessibility API. As the user navigates from one option child to the next, DOM focus is maintained on the listbox parent, but the accessibility API emits a focus event and exposes the focused state for the option child that the listbox references as the active descendant.
    例として、tabindex の代わりに aria-activedescendant を使用してフォーカスを制御する単一選択リストボックスがあります。 オプションの子はすべて、アクセシビリティ API でフォーカス可能な状態でマークされます。 ユーザーが1つのオプションの子から次のオプションの子にナビゲートすると、DOM フォーカスはリストボックスの親に維持されますが、アクセシビリティ API はフォーカスイベントを発行し、リストボックスがアクティブな子孫（active descendant）として参照するオプションの子のフォーカスされた状態を公開します。


Table of accessibility APIs for focus states and events   	MSAA 	Microsoft UIA 	ATK/AT-SPI 	AX API
フォーカスの状態とイベントのアクセシビリティ API の表   	MSAA 	Microsoft UIA 	ATK/AT-SPI 	AX API


Focusable state 	STATE_SYSTEM_FOCUSABLE 	Current state reflected in IUIAutomationElement::CurrentIsKeyboardFocusable, can be retrieved with IUIAutomationElement::GetCurrentPropertyValue method using UIA_IsKeyboardFocusablePropertyId property identifier. 	STATE_FOCUSABLE 	boolean AXFocused: the AXUIElementIsAttributeSettable method returns YES.
フォーカス可能な状態 	STATE_SYSTEM_FOCUSABLE 	IUIAutomationElement::CurrentIsKeyboardFocusable に反映されている現在の状態は、UIA_IsKeyboardFocusablePropertyId プロパティ識別子を使用して IUIAutomationElement::GetCurrentPropertyValue メソッドで取得できます。 	STATE_FOCUSABLE 	boolean AXFocused：AXUIElementIsAttributeSettable メソッドは YES を返します。


Focused state 	STATE_SYSTEM_FOCUSED 	Current state reflected in IUIAutomationElement::CurrentHasKeyboardFocus, can be retrieved with IUIAutomationElement::GetCurrentPropertyValue method using UIA_HasKeyboardFocusPropertyId property identifier. 	STATE_FOCUSED 	boolean AXFocused
フォーカスされた状態 	STATE_SYSTEM_FOCUSED 	IUIAutomationElement::CurrentHasKeyboardFocus に反映されている現在の状態は、UIA_HasKeyboardFocusPropertyId プロパティ識別子を使用して IUIAutomationElement::GetCurrentPropertyValue メソッドで取得できます。 
 	STATE_FOCUSED 	boolean AXFocused


Focus event 	EVENT_OBJECT_FOCUS 	Clients can subscribe with IUIAutomation::AddFocusChangedEventHandler using callback interface is IUIAutomationFocusChangedEventHandler 	object:state-changed:focused and:
フォーカスイベント 	EVENT_OBJECT_FOCUS 	クライアントは、IUIAutomationFocusChangedEventHandler であるコールバックインターフェイスを使用して、IUIAutomation::AddFocusChangedEventHandler で購読できます。 	object:state-changed:focused および:

    detail1 = 1 for the accessible object which just gained focus.
    フォーカスを取得したばかりのアクセス可能なオブジェクトでは detail1 = 1。

    detail1 = 0 for the accessible object which just lost focus.
    フォーカスを失ったばかりのアクセス可能なオブジェクトでは detail1 = 0。 

	AXFocusedUIElementChanged




4.2 Controlling focus with tabindex §
4.2 tabindex によるフォーカスの制御 §

User agents that support WAI-ARIA expand the usage of tabindex, focus, and blur to allow them on all elements. Authors may add any element such as a div, span or img to the default tab order by setting tabindex="0". In addition, any item with tabindex equal to a negative integer is focusable via script or a mouse click, but is not part of the default tab order. This is not supported in the HTML4 specification but is in compliance with HTML5 and SVG2.
WAI-ARIA をサポートするユーザーエージェントは、tabindex、focus、blur の使用法を拡張して、すべての要素でそれらを許可します。 作成者は、tabindex="0" を設定することにより、div、span、img などの要素をデフォルトのタブ順序に追加できます。 さらに、tabindex が負の整数に等しい項目は、スクリプトまたはマウスクリックでフォーカスできますが、デフォルトのタブ順序の一部ではありません。 これは HTML4 仕様ではサポートされていませんが、HTML5 および SVG2 に準拠しています。

The tabindex system provides one way to develop custom widgets which are keyboard accessible, from simple widgets like a slider to container widgets like a menubar, treeview or grid.
tabindex システムは、スライダーのような単純なウィジェットから、メニューバー、ツリービュー、グリッドのようなコンテナーウィジェットまで、キーボードでアクセス可能なカスタムウィジェットを開発する1つの方法を提供します。

Note
注

Refer to the Table of accessibility APIs for focus states and events for the rules in this section.
このセクションの規則については、「フォーカスの状態とイベントのアクセシビリティ API の表」を参照してください。 

The user agent MUST do the following to enable accessible tabindex usage on all elements:
ユーザーエージェントは、すべての要素でアクセス可能な tabindex の使用を有効にするために、以下を行う必要があります（MUST）。

    Where tabindex equals a negative integer, set the focusable state, but do not include the element in the sequential tab order.
    tabindex が負の整数に等しい場合、フォーカス可能な状態を設定しますが、要素をタブ順序に含めません。

    Where tabindex="0", set the focusable state and include it in the sequential tab order.
    tabindex="0" の場合、フォーカス可能な状態を設定し、それを順番にタブ順序に含めます。

    Where tabindex is greater than zero, set the focusable state, and include the element in the sequential tab order according to the value of the tabindex attribute and before any elements with tabindex either omitted or with a value of zero. See Sequential focus navigation [html5] for details.
    tabindex がゼロより大きい場合は、フォーカス可能な状態を設定し、tabindex 属性の値に従って、tabindex が省略されているか、値がゼロの要素の前に、要素を順番にタブ順序に含めます。 詳細については、「シーケンシャルフォーカスナビゲーション（Sequential focus navigation） [html5]」を参照してください。

    Expose the element.tabIndex property for every element that supports the tabindex attribute.
    tabindex 属性をサポートするすべての要素の element.tabIndex プロパティを公開します。

    Support the focus() and blur() methods on element interfaces that support the tabindex attribute, e.g., HTMLElement and SVGElement. This allows scripts to move the focus to the element.
    HTMLElement や SVGElement など、tabindex 属性をサポートする要素のインターフェイスで focus() メソッドと blur() メソッドをサポートします。 これにより、スクリプトはフォーカスを要素に移動できます。

    Fire focus, blur, DOMFocusIn, and DOMFocusOut events for any element that can receive focus.
    フォーカスを受け取ることができるすべての要素に対して、focus、blur、DOMFocusIn、および DOMFocusOut のイベントを発火させます。

    When a keydown event is cancelled, also cancel the keypress event.
    keydown イベントがキャンセルされた場合は、keypress イベントもキャンセルしてください。

    Expose the focusable states for any element in the accessibility tree.
    アクセシビリティツリーの任意の要素のフォーカス可能な状態を公開します。

    When any object has focus, expose the focused state. When it loses focus, remove the focused state.
    オブジェクトにフォーカスがある場合は、フォーカスされた状態を公開します。 フォーカスを失ったら、フォーカスされた状態を取り除きます。





4.3 Controlling focus with aria-activedescendant §
4.3 aria-activedescendant によるフォーカスの制御 §

When implementing aria-activedescendant as described below, the user agent keeps the DOM focus on the container element but communicates desktop focus events and states to the assistive technology as if the active descendant has focus. User agents are not expected to validate that the active descendant is a descendant of the focused container, as noted in the Author Errors section. It is the responsibility of the user agent to ensure that keyboard events are processed at the container element that has DOM focus. Any keyboard events directed at the active descendant bubble up to the DOM element with focus, the container element, for processing.
以下で説明するように aria-activedescendant を実装する場合、ユーザーエージェントは DOM フォーカスをコンテナー要素に保持しますが、アクティブな子孫がフォーカスを持っているかのように、デスクトップフォーカスイベントと状態を支援技術に伝達します。 「作成者エラー」のセクションに記載されているように、ユーザーエージェントは、アクティブな子孫がフォーカスされたコンテナーの子孫であることを検証することは期待されていません。 キーボードイベントが DOM フォーカスを持つコンテナ要素で処理されるようにするのはユーザーエージェントの責任です。 アクティブな子孫に向けられたキーボードイベントは、処理のために、フォーカスのある DOM 要素であるコンテナー要素までバブルします。

The aria-activedescendant property may be used to enable keyboard accessibility on WAI-ARIA elements that support this attribute. It is often a more convenient way of creating container widget keyboard navigation (where the entire widget is in the tab order just once, but the user can use other keys, typically arrow keys, to navigate to descendant items of the container).
aria-activedescendant プロパティを使用して、この属性をサポートする WAI-ARIA 要素でキーボードのアクセシビリティを有効にすることができます。 多くの場合、これはコンテナーウィジェットのキーボードナビゲーションを作成するためのより便利な方法です（ウィジェット全体が1度だけタブ順序に入りますが、ユーザーは他のキー（通常は矢印キー）を使用してコンテナーの子孫項目にナビゲートできます）。

Typically, the author will use host language semantics to put the container element in the sequential tab order (e.g., tabindex="0" in HTML) and aria-activedescendant to point to the ID of the currently active descendant. The author, not the user agent, is responsible for styling the currently active descendant to show it has keyboard focus. The author cannot use :focus to style the currently active descendant since actual focus is on the container.
通常、作成者はホスト言語の意味論を使用してコンテナー要素を順番にタブ順序に配置し（HTML では tabindex="0" など）、aria-activedescendant を使用して現在アクティブな子孫の ID を指します。 ユーザーエージェントではなく作成者が、現在アクティブな子孫のスタイルを設定して、キーボードフォーカスがあることを示す責任があります。 実際のフォーカスはコンテナーにあるため、作成者は :focus を使用して現在アクティブな子孫のスタイルを設定することはできません。

Note
注

Refer to the Table of accessibility APIs for focus states and events for the rules in this section.
このセクションの規則については、「フォーカスの状態とイベントのアクセシビリティ API の表」を参照してください。

The user agent MUST do the following to implement aria-activedescendant:
ユーザーエージェントは、aria-activedescendant を実装するために以下を行う必要があります（MUST）。

    Implement the host language method for keyboard navigation so that the container widget may be included in the tab order. See Controlling focus with tabindex.
    キーボードナビゲーションのホスト言語メソッドを実装して、コンテナーウィジェットがタブ順序に含まれるようにします。 「tabindex によるフォーカスの制御」を参照してください。

    For platforms that expose desktop focus or accessibility API focus separately from DOM focus, do not expose the focused state in the accessibility API for any element when it has DOM focus and also has aria-activedescendant which points to a valid ID.
    デスクトップフォーカスまたはアクセシビリティ API フォーカスを DOM フォーカスとは別に公開するプラットフォームの場合、DOM フォーカスがあり、有効な ID を指す aria-activedescendant がある要素については、アクセシビリティ API でフォーカスされた状態を公開しないでください。

    When the aria-activedescendant attribute changes on an element that currently has DOM focus, remove the focused state from the previously focused object and fire an accessibility API desktop focus event on the new active descendant. If aria-activedescendant is cleared or does not point to an element in the current document, fire a desktop focus event for the container object that had the attribute change.
    現在 DOM フォーカスがある要素で aria-activedescendant 属性が変更された場合、以前にフォーカスされたオブジェクトからフォーカスされた状態を取り除き、新しいアクティブな子孫でアクセシビリティ API のデスクトップフォーカスイベントを発火させます。 aria-activedescendant がクリアされているか、現在の文書の要素を指していない場合は、属性が変更されたコンテナーオブジェクトに対してデスクトップフォーカスイベントを発火させます。

    For any element with an ID attribute, where the element is a descendant of an element with the aria-activedescendant attribute, apply the following accessibility API states to the target to ensure the object is accessible:
    ID 属性を持つ要素（要素が aria-activedescendant 属性を持つ要素の子孫である場合）については、次のアクセシビリティ API の状態を対象に適用して、オブジェクトにアクセスできるようにします。

        Focusable, if the element also has a WAI-ARIA role — because the aria-activedescendant of the container can potentially point to it. It is not absolutely necessary to check this when there is no role, because elements that would be focusable would already have the focusable state.
        要素に WAI-ARIA のロールもある場合は、フォーカス可能です。 これは、コンテナーの aria-activedescendant が潜在的にそれを指す可能性があるためです。 フォーカス可能な要素はすでにフォーカス可能な状態になっているため、ロールがない場合は、これを確認する必要はありません。

        Focused, whenever the container element sets aria-activedescendant to match the ID of this descendant and the container widget with aria-activedescendant has DOM focus.
        コンテナー要素がこの子孫の ID と一致するように aria-activedescendant を設定し、aria-activedescendant を持つコンテナーウィジェットが DOM フォーカスを持っている場合は常にフォーカスされます。





4.4 Handling focus changes from the Assistive Technology §
4.4 支援技術からのフォーカス変更の処理 §

Assistive technologies, such as screen readers, voice input software and on-screen keyboards, might request that the keyboard focus be moved using the following accessibility APIs:
スクリーンリーダー、音声入力ソフトウェア、オンスクリーンキーボードなどの支援技術では、次のアクセシビリティ API を使用してキーボードのフォーカスを移動するように要求される場合があります。 

    MSAA: accSelect(SELFLAG_TAKEFOCUS)
    MSAA：accSelect(SELFLAG_TAKEFOCUS)

    UIA: RaiseAutomationEvent
    UIA：RaiseAutomationEvent

    ATK/AT-SPI: AtkComponent::grab_focus
    ATK / AT-SPI：AtkComponent::grab_focus

    AX API: Notification: AXFocusedUIElementChanged
    AX API：通知：AXFocusedUIElementChanged

Note
注

Refer to the Table of accessibility APIs for focus states and events for the rules in this section.
このセクションの規則については、「フォーカスの状態とイベントのアクセシビリティ API の表」を参照してください。 

When an assistive technology requests a change of focus using one of the above APIs, user agents MUST do the following:
支援技術が上記の API のいずれかを使用してフォーカスの変更を要求する場合、ユーザーエージェントは次のことを行う必要があります（MUST）。

    Remove the focused state from the previously focused object.
    以前にフォーカスされたオブジェクトからフォーカスされた状態を取り除きます。

    If the element can take DOM focus, the user agent MUST set the DOM focus to it. Otherwise, if the current element has an ID and an ancestor with the aria-activedescendant attribute present, the user agent MUST set DOM focus to that ancestor. When it is not possible for the user agent to set DOM focus to the containing element with aria-activedescendant, the user agent MAY attempt to set DOM focus to the child element itself.
    要素が DOM フォーカスを取得できる場合、ユーザーエージェントは DOM フォーカスをその要素に設定する必要があります（MUST）。 それ以外の場合、現在の要素に ID があり、aria-activedescendant 属性が存在する祖先がある場合、ユーザーエージェントは DOM フォーカスをその祖先に設定する必要があります。 ユーザーエージェントが aria-activedescendant を使用して DOM フォーカスを包含要素に設定できない場合、ユーザーエージェントは DOM フォーカスを子要素自体に設定できます（MAY）。

    If the current element has an ID and an ancestor with the aria-activedescendant attribute present, the user agent MUST set the accessibility API focused state and fire an accessibility API desktop focus event on the new active descendant.
    現在の要素に ID があり、aria-activedescendant 属性が存在する祖先がある場合、ユーザーエージェントはアクセシビリティ API のフォーカスされた状態を設定し、新しいアクティブな子孫でアクセシビリティ API のデスクトップフォーカスイベントを発火させる必要があります（MUST）。

Note
注

The inability to set DOM focus to the containing element indicates an author error.
包含要素に DOM フォーカスを設定できないことは、作成者エラーを示します。 




5. Mapping WAI-ARIA to Accessibility APIs §
5. WAI-ARIA のアクセシビリティ API へのマッピング §




5.1 General rules for exposing WAI-ARIA semantics §
5.1 WAI-ARIA 意味論を公開するための一般的な規則 §

Where supported by the platform Accessibility API, user agents expose WAI-ARIA semantics through the standard mechanisms of the desktop accessibility API. For example, for WAI-ARIA widgets, compare how the widget is exposed in a similar desktop widget. In general most WAI-ARIA widget capabilities are exposed through the role, value, Boolean states, and relations of the accessibility API.
プラットフォームのアクセシビリティ API でサポートされている場合、ユーザーエージェントはデスクトップのアクセシビリティ API の標準メカニズムを通じて WAI-ARIA 意味論を公開します。 たとえば、WAI-ARIA ウィジェットの場合、ウィジェットが同様のデスクトップウィジェットでどのように公開されるかを比較します。 一般に、ほとんどの WAI-ARIA ウィジェット機能は、アクセシビリティ API のロール、値、ブール状態、および関係を通じて公開されます。

With respect to WAI-ARIA 1.0 and 1.1, accessibility APIs operate in one direction only. User agents publish WAI-ARIA information (roles, states, and properties) via an accessibility API, and an AT can acquire that information using the same API. However, the other direction is not supported. WAI-ARIA 1.0 and 1.1 do not define mechanisms for assistive technologies to directly modify WAI-ARIA information.
WAI-ARIA 1.0 および 1.1 に関して、アクセシビリティ API は一方向でのみ動作します。 ユーザーエージェントはアクセシビリティ API を介して WAI-ARIA 情報（ロール、状態、およびプロパティ）を公開し、AT は同じ API を使用してその情報を取得できます。 ただし、他の方向はサポートされていません。 WAI-ARIA 1.0 および 1.1 は、WAI-ARIA 情報を直接変更する支援技術のメカニズムを定義していません。

The terms "exposing", "mapping", and "including" refer to the creation of accessible object nodes within the accessibility tree, and populating these objects with Accessibility API specific states and properties. The accessibility tree is a sub-set of the DOM since not every DOM element is exposed as an accessible object. Whether or not a DOM element is exposed depends on whether it has any semantic import. If it has none, no accessible object is needed, and it is excluded from the accessibility tree. For example, authors might create a nested set of DOM elements solely for visual layout. Those DOM elements are not included as they contain no semantic information. In addtion, some host markup langauges elements have no semantics and are excluded from the accessibility tree. For example, the HTML <base> element is used to define a base URL for all relative URLs within the document. It is important to the browser, which uses the information to resolve relative URLs. But, it has no meaning to end users, is not rendered on screen by the browser, and is excluded from the accessibility tree.
「公開（exposing）」、「マッピング（mapping）」、および「含む（including）」という用語は、アクセシビリティツリー内にアクセス可能なオブジェクトのノードを作成し、これらのオブジェクトにアクセシビリティ API 固有の状態とプロパティを設定することを指します。 すべての DOM 要素がアクセス可能なオブジェクトとして公開されているわけではないため、アクセシビリティツリーは DOM のサブセットです。 DOM 要素が公開されるかどうかは、意味論的なインポートがあるかどうかによって異なります。 ない場合、アクセス可能なオブジェクトは不要であり、アクセシビリティツリーから除外されます。 たとえば、作成者は、視覚的なレイアウトのためだけに DOM 要素のネストされたセットを作成する場合があります。 これらの DOM 要素には意味論的な情報が含まれていないため、含まれていません。 さらに、一部のホストマークアップ言語要素には意味論がなく、アクセシビリティツリーから除外されています。 たとえば、HTML の <base> 要素は、文書内のすべての相対 URL のベース URL を定義するために使用されます。 これは、相対 URL を解決するためにこの情報を使用するブラウザーにとって重要です。 しかし、エンドユーザーにとっては意味がなく、ブラウザーによって画面に表示されず、アクセシビリティツリーから除外されます。

A DOM element is included if it has semantic significance. As a first approximation, it is significant if it has an explicit or implicit WAI-ARIA role, state, or property, is focusable or interactive, or bears a relationship with some other element (e.g., controller-for). It is not semantically significant if it is purely presentational, or is not rendered in any medium. The details and exceptions are described below, but a procedure that provides the gist of how to build the accessibility tree is as follows:
DOM 要素は、意味論的に重要な場合に含まれます。 最初の概算として、明示的または暗黙的な WAI-ARIA のロール、状態、またはプロパティがあるか、フォーカス可能または相互作用的であるか、または他の要素との関係性（controller-for など）があるかどうかが重要です。 それが純粋に表現的であるか、またはどの媒体でもレンダリングされない場合、それは意味的に重要ではありません。 詳細と例外については以下で説明しますが、アクセシビリティツリーの構築方法の要点を説明する手順は次のとおりです。

    Include elements based on host language rules. These rules are documented in the host language mapping specification for those elements.
    ホスト言語の規則に基づいて要素を含めます。 これらの規則は、これらの要素のホスト言語マッピング仕様に記載されています。

    Include elements with WAI-ARIA roles and other WAI-ARIA attributes.
    WAI-ARIA ロールおよびその他の WAI-ARIA 属性を持つ要素を含めます。

    Exclude hidden elements and their descendants.
    非表示要素とその子孫を除外します。

    Exclude presentational elements, but include their descendent elements where presentation is not inherited, and include their textual content.
    表現的な（presentational）要素を除外しますが、プレゼンテーションが継承されない子孫要素を含め、テキストコンテンツを含めます。

        In some cases, the presentation/none role is inherited and the descendent elements are excluded.
        場合によっては、プレゼンテーション / なし（none）ロールが継承され、子孫要素が除外されます。

    Include, and possibly add back focusable or otherwise interactive elements.
    フォーカス可能な要素またはその他の相互作用的な要素を含め、場合によっては追加し直します。

        For example, an element marked with both role="presentation" and tabindex="0" is focusable. The presentation role is ignored, and the element is included.
        たとえば、role="presentation" と tabindex="0" の両方でマークされた要素はフォーカス可能です。 プレゼンテーションロールは無視され、要素が含まれます。

        In instances where the host language elements support CSS display:none, the element is not focusable even if it has tabindex="0" since there is nothing rendered on screen to focus, and users cannot interact with the element. The tabindex attribute is ignored, and the element is excluded.
        ホスト言語要素が CSS display:none をサポートしている場合、画面上にフォーカスするものがレンダリングされておらず、ユーザーが要素を相互作用できないため、tabindex="0" があっても要素はフォーカスできません。 tabindex 属性は無視され、要素は除外されます。





5.1.1 Excluding Elements from the Accessibility Tree §
5.1.1 アクセシビリティツリーからの要素の除外 §

The following elements are not exposed via the accessibility API and user agents MUST NOT include them in the accessibility tree:
次の要素はアクセシビリティ API を介して公開されておらず、ユーザーエージェントはそれらをアクセシビリティツリーに含めてはなりません（MUST NOT）。

    Elements with none or presentation as the first mappable role in the role attribute. However, their exclusion is conditional and depends on other factors. In addition, the element's descendants and text content are generally included. These exceptions and conditions are documented in the section "Presentational Roles Conflict Resolution" in Accessible Rich Internet Applications (WAI-ARIA) 1.1 [wai-aria-1.1].
    ロール（role）属性の最初のマップ可能なロールとして、なし（none）またはプレゼンテーション（presentation）を含む要素。 ただし、それらの除外は条件付きであり、他の要因に依存します。 さらに、要素の子孫とテキストコンテンツが通常含まれます。 これらの例外と条件は、「アクセス可能でリッチなインターネットアプリケーション（WAI-ARIA）1.1 [wai-aria-1.1]」の「表現的なロールの競合の解決（Presentational Roles Conflict Resolution）」のセクションに記載されています。

    Elements, including their descendent elements, that have host language semantics specifying that the element is not displayed, such as CSS display:none, visibility:hidden, or the HTML 5 hidden attribute.
    CSS の display:none、visibility:hidden、または HTML5 の hidden 属性など、要素が表示されないことを指定するホスト言語意味論を持つ要素（子孫要素を含む）。

If not already excluded from the accessibility tree per the above rules, user agents SHOULD NOT include the following elements in the accessibility tree:
上記の規則に従ってアクセシビリティツリーからまだ除外されていない場合、ユーザーエージェントはアクセシビリティツリーに次の要素を含めるべきではありません（SHOULD NOT）。

    Elements, including their descendants, that have a WAI-ARIA global attribute of aria-hidden="true". In other words, aria-hidden="true" on a parent overrides aria-hidden="false" on descendants.
    aria-hidden="true" の WAI-ARIA グローバル属性を持つ要素（子孫を含む）。 つまり、親の aria-hidden="true" は、子孫の aria-hidden="false" をオーバーライドします。

    Any descendants of elements that have the characteristic "Children Presentational: True" unless the descendant is not allowed to be presentational because it meets one of the conditions for exception described in Presentational Roles Conflict Resolution in Accessible Rich Internet Applications (WAI-ARIA) 1.1 [wai-aria-1.1]. However, the text content of any excluded descendants is included.
    「アクセス可能でリッチなインターネットアプリケーション（WAI-ARIA）1.1  [wai-aria-1.1]」の表現的なロールの競合の解決で説明されている例外の条件のいずれかを満たしているために子孫が表現的であることを許可されない場合を除き、"Children Presentational: True" （子は表現的である）という特性を持つ要素の子孫。 ただし、除外された子孫のテキストコンテンツは含まれます。 

    Elements having one of the following roles have the characteristic "Children Presentational: True":
    次のいずれかのロールを持つ要素には、"Children Presentational: True" という特性があります。

        button
        ボタン（button）

        checkbox
        チェックボックス（checkbox）

        img
        画像（img）

        math
        数学（math）

        menuitemcheckbox
        メニュー項目チェックボックス（menuitemcheckbox）

        menuitemradio
        メニュー項目ラジオボタン（menuitemradio）

        option
        オプション（option）

        progressbar
        プログレスバー（progressbar）

        radio
        ラジオボタン（radio）

        scrollbar
        スクロールバー（scrollbar）

        separator
        区切り（separator、セパレーター）

        slider
        スライダー（slider）

        switch
        スイッチ（switch）

        tab
        タブ（tab）





5.1.2 Including Elements in the Accessibility Tree §
5.1.2 アクセシビリティツリーに要素を含める §

If not already excluded from the accessibility tree per the rules above in Excluding Elements in the Accessibility Tree, user agents MUST provide an accessible object in the accessibility tree for DOM elements that meet any of the following criteria:
上記のアクセシビリティツリーからの要素の除外の規則に従ってアクセシビリティツリーからまだ除外されていない場合、ユーザーエージェントは、次の基準のいずれかを満たす DOM 要素のためにアクセシビリティツリーにアクセス可能なオブジェクトを提供する必要があります（MUST）。

    Text nodes
    テキストノード

    Elements that may fire an accessibility API event. Accessibility API events are documented in the Events section.
    アクセシビリティ API イベントを発火させる可能性のある要素。 アクセシビリティ API イベントは、「イベント」のセクションに記載されています。

    Elements that are focusable, or have an ID attribute and an ancestor with the aria-activedescendant attribute that matches the implicit or explicit semantics of the required context role. In either case, the element may receive focus and may fire an accessibility API FOCUS event.
    フォーカス可能な要素、または ID 属性と、必要なコンテキストロールの暗黙的または明示的な意味論に一致する aria-activedescendant 属性を持つ祖先を持つ要素。 いずれの場合も、要素はフォーカスを受け取り、アクセシビリティ API の FOCUS イベントを発火させる可能性があります。

    Elements that have a mappable role in the role attribute string (see Role Mapping below).
    ロール属性文字列にマップ可能なロールを持つ要素（以下の「ロールのマッピング」を参照）。

    Elements that have a global WAI-ARIA attribute but do not have aria-hidden="true". (See Excluding Elements in the Accessibility Tree for additional guidance on aria-hidden.)
    グローバルな WAI-ARIA 属性を持っているが、aria-hidden="true" を持たない要素。 （aria-hidden に関する追加のガイダンスについては、アクセシビリティツリーからの要素の除外を参照してください。）

    Elements that have an ID which is referenced by another element via a WAI-ARIA relation and are not hidden.
    WAI-ARIA 関係（relation）を介して別の要素によって参照され、非表示にされていない ID を持つ要素。

        WAI-ARIA relations include aria-controls, aria-describedby, aria-details, aria-errormessage, aria-flowto, aria-labelledby and aria-owns.
        WAI-ARIA 関係には、aria-controls、aria-describedby、aria-details、aria-errormessage、aria-flowto、aria-labelledby、および aria-owns が含まれます。

    Note
    注

    Text equivalents for hidden referenced objects may still be used in the name and description calculation even when not included in the accessibility tree.
    非表示の参照されたオブジェクトに相当するテキストは、アクセシビリティツリーに含まれていない場合でも、名前と説明の計算に使用できます。




5.1.3 Notification of State Changes §
5.1.3 状態変化の通知 §

User agents notify assistive technologies of state and property changes as defined in Events.
ユーザーエージェントは、「イベント」で定義されているように、状態とプロパティの変更を支援技術に通知します。 




5.2 Conflicts between native markup semantics and WAI-ARIA §
5.2 ネイティブなマークアップの意味論と WAI-ARIA の間の競合§

WAI-ARIA roles, states, and properties are intended to add semantic information when native host language elements with these semantics are not available, and are generally used on elements that have no native semantics of their own. They can also be used on elements that have similar but not identical semantics to the intended object (for instance, a nested list could be used to represent a tree structure). This method can be part of a fallback strategy for older browsers that have no WAI-ARIA implementation, or because native presentation of the repurposed element reduces the amount of style and/or script needed. Except for the cases outlined below, user agents MUST always use the WAI-ARIA semantics to define how it exposes the element to accessibility APIs, rather than using the host language semantics.
WAI-ARIA のロール、状態、およびプロパティは、これらの意味論を持つネイティブホスト言語要素が使用できない場合に意味論的な情報を追加することを目的としており、通常、独自のネイティブ意味論を持たない要素で使用されます。 これらは、意図されたオブジェクトと類似しているが同一ではない意味論を持つ要素にも使用できます（たとえば、ネストされたリストを使用してツリー構造を表すことができます）。 この方法は、WAI-ARIA が実装されていない古いブラウザーのフォールバック戦略の一部であったり、再利用された要素のネイティブなプレゼンテーションにより、必要なスタイルやスクリプトの量が減少するためであったりします。 以下に概説する場合を除いて、ユーザーエージェントは、ホスト言語の意味論を使用するのではなく、常に WAI-ARIA 意味論を使用して要素をアクセシビリティ API に公開する方法を定義する必要があります（MUST）。

Host languages can have features that have implicit WAI-ARIA semantics corresponding to roles. When a WAI-ARIA role is provided that has a corresponding role in the accessibility API, user agents MUST use the semantic of the WAI-ARIA role for processing, not the native semantic, unless the role requires WAI-ARIA states and properties whose attributes are explicitly forbidden on the native element by the host language. Values for roles do not conflict in the same way as values for states and properties, and because authors are expected to have a valid reason to provide a WAI-ARIA role even on elements that would not normally be repurposed. For example, spin buttons are typically constructed from text fields (<input type="text">) in order to get most of the default keyboard support. But, the native role, "text field", is not correct because it does not properly communicate the additional features of a spin button. The author adds the WAI-ARIA role of spinbutton (<input type="text" role="spinbutton" ...>) so that the control is properly mapped in the accessibility API. When a WAI-ARIA role is provided that does not have a corresponding role in the accessibility API, user agents MAY expose the native semantic in addition to the WAI-ARIA role. If the host language element is overridden by a WAI-ARIA role whose semantics or structure is not equivalent to the native host language semantics or to a subclsss of those semantics, then treat any required owned elements of the native role as having role presentation or none.
ホスト言語は、ロールに対応する暗黙の WAI-ARIA 意味論を持つ機能を持つことができます。 アクセシビリティ API で対応するロールを持つ WAI-ARI ロールが提供される場合、ユーザーエージェントは、ホスト言語によってネイティブな要素で属性が明示的に禁止されている WAI-ARIA 状態とプロパティをロールが必要とする場合を除き、ネイティブな意味論ではなく WAI-ARIA ロールの意味論を処理に使用する必要があります（MUST）。 ロールの値は、状態やプロパティの値と同じように競合することはなく、作成者には、通常は再利用されない要素に対しても WAI-ARIA ロールを提供する正当な理由があると予想されるためです。 たとえば、スピンボタンは通常、デフォルトのキーボードサポートのほとんどを取得するために、テキストフィールド（<input type="text">）から構成されます。 ただし、ネイティブなロールである「テキストフィールド」は、スピンボタンの追加機能を適切に伝達しないため、正しくありません。 作成者は、スピンボタンの WAI-ARIA ロールを追加して（<input type="text" role="spinbutton" ...>）、コントロールがアクセシビリティ API に適切にマッピングされるようにします。 アクセシビリティ API で対応するロールを持たない WAI-ARIA ロールが提供されている場合、ユーザーエージェントは WAI-ARIA ロールに加えてネイティブな意味論を公開できます（MAY）。 ホスト言語要素が、意味論または構造がネイティブなホスト言語意味論またはそれらの意味論のサブクラスと同等ではない WAI-ARIA ロールによってオーバーライドされる場合、ネイティブなロールの必要な所有要素をプレゼンテーションロールかなし（none）ロールとして扱います。

Note
注意

The above text differs slightly from the WAI-ARIA specification. The requirement for user agents to expose the WAI-ARIA role instead of the native role was intended to only apply in cases where there is a direct mapping from the WAI-ARIA role to a corresponding role in the accessibility API. The wording of the requirement is not clear in the WAI-ARIA specification, however, and has been interpreted differently by implementers. The requirement has been clarified here and an additional statement added to indicate that user agents may expose native semantics if there is not a direct mapping to a role in the accessibility API. Because there are differing implementations, authors will be advised against adding such WAI-ARIA roles to native elements that have their own semantics in the WAI-ARIA Authoring Practices Guide.
上記のテキストは、WAI-ARIA 仕様とは少し異なります。 ユーザーエージェントがネイティブなロールの代わりに WAI-ARIA ロールを公開するという要件は、WAI-ARIA ロールからアクセシビリティ API の対応するロールへの直接マッピングがある場合にのみ適用されることを目的としていました。 ただし、WAI-ARIA 仕様では要件の表現が明確ではなく、実装者によって解釈が異なります。 ここで要件が明確になり、アクセシビリティ API のロールへの直接マッピングがない場合、ユーザーエージェントがネイティブな意味論を公開する可能性があることを示す追加のステートメントが追加されました。 実装にはさまざまなものがあるため、作成者は、WAI-ARIA オーサリングプラクティスガイドで、独自の意味論を持つネイティブ要素にそのような WAI-ARIA ロールを追加しないようにアドバイスされます。

When WAI-ARIA states and properties correspond to host language features that have the same implicit WAI-ARIA semantic, it can be problematic if the values become out of sync. For example, the HTML checked attribute and the aria-checked attribute could have conflicting values. Therefore to prevent providing conflicting states and properties to assistive technologies, host languages will explicitly declare where the use of WAI-ARIA attributes on a host language element conflict with native attributes for that element. When a host language declares a WAI-ARIA attribute to be in direct semantic conflict with a native attribute for a given element, user agents MUST ignore the WAI-ARIA attribute and instead use the host language attribute with the same implicit semantic.
WAI-ARIA の状態とプロパティが、同じ暗黙の WAI-ARIA 意味論を持つホスト言語機能に対応している場合、値が同期しなくなると問題が発生する可能性があります。 たとえば、HTML checked 属性と aria-checked 属性の値が競合している可能性があります。 したがって、支援技術に競合する状態とプロパティを提供することを防ぐために、ホスト言語は、ホスト言語要素での WAI-ARIA 属性の使用がその要素のネイティブな属性と競合する場所を明示的に宣言します。 ホスト言語が WAI-ARIA 属性が特定の要素のネイティブな属性と直接意味論的に競合することを宣言する場合、ユーザーエージェントは WAI-ARIA 属性を無視し、代わりに同じ暗黙の意味論を持つホスト言語の属性を使用する必要があります（MUST）。

Host languages might also document features that cannot be overridden with WAI-ARIA (these are called "strong native semantics"). These can be features that have implicit WAI-ARIA semantics as well as features where the processing would be uncertain if the semantics were changed with WAI-ARIA. While conformance checkers might signal an error or warning when a WAI-ARIA role is used on elements with strong native semantics, user agents MUST still use the value of the semantic of the WAI-ARIA role when exposing the element to accessibility APIs.
ホスト言語は、WAI-ARIA でオーバーライドできない機能を文書化する場合もあります（これらは「強いネイティブな意味論（strong native semantics）」と呼ばれます）。 これらは、暗黙の WAI-ARIA 意味論を持つ機能だけでなく、意味論が WAI-ARIA で変更された場合に処理が不確実になる機能でもあります。 強いネイティブな意味論を持つ要素で WAI-ARIA ロールが使用されると、準拠性チェッカーがエラーまたは警告を通知する場合がありますが、ユーザーエージェントは、要素をアクセシビリティ API に公開するときに、WAI-ARIA ロールの意味論の値を依然として使用する必要があります（MUST）。




5.3 Exposing attributes that do not directly map to accessibility API properties §
5.3 アクセシビリティ API のプロパティに直接マップされない属性の公開 §

Platform accessibility APIs might have features that are not in WAI-ARIA. Likewise, WAI-ARIA exposes capabilities that are not supported by accessibility APIs at the time of publication. There typically is not a one to one relationship between all WAI-ARIA attributes and platform accessibility APIs. When WAI-ARIA roles, states and properties do not directly map to an accessibility API, and there is a mechanism in the API to expose the WAI-ARIA role, states, and properties and their values, user agents MUST expose the WAI-ARIA data using that mechanism as follows:
プラットフォームのアクセシビリティ API には、WAI-ARIA にはない機能が含まれている場合があります。 同様に、WAI-ARIA は、公開時点でアクセシビリティ API でサポートされていない機能を公開しています。 通常、すべての WAI-ARIA 属性とプラットフォームのアクセシビリティ API の間には1対1の関係性はありません。 WAI-ARIA のロール、状態、およびプロパティがアクセシビリティ API に直接マップされず、API に WAI-ARIA のロール、状態、およびプロパティとそれらの値を公開するメカニズムがある場合、ユーザーエージェントは以下のようにその仕組みを使用して WAI-ARIA データを公開する必要があります(MUST)。

    In IAccessible2 and ATK/AT-SPI, use object attributes to expose semantics that are not directly supported in the APIs. Object attributes are name-value pairs that are loosely specified, and very flexible for exposing things where there is no specific interface in an accessibility API. For example, at this time, the aria-live attribute can be exposed via an object attribute because accessibility APIs have no such property available. Specific rules for exposing object attribute name-value pairs are described throughout this document, and rules for the general cases are in State and Property Mapping.
    IAccessible2 および ATK / AT-SPI では、オブジェクト属性を使用して、API で直接サポートされていない意味論を公開します。 オブジェクト属性は、大まかに指定された名前と値のペアであり、アクセシビリティ API に特定のインターフェイスがない場合に公開するために非常に柔軟です。 たとえば、現時点では、aria-live 属性はアクセシビリティ API にはそのようなプロパティがないため、オブジェクト属性を介して公開できます。 オブジェクト属性の名前と値のペアを公開するための特定の規則は、この文書全体を通じて説明されており、一般的な場合の規則は、「状態とプロパティのマッピング」にあります。

    In Microsoft UIA, use the AriaRole and AriaProperties properties to expose semantics that are not directly supported in the control type.
    Microsoft UIA では、AriaRole プロパティと AriaProperties プロパティを使用して、コントロールタイプで直接サポートされていない意味論を公開します。

Note
注意

MSAA does not provide a mechanism for exposing attributes that do not map directly to the API and among implementers, there is no agreement on how to do it.
MSAA は、API に直接マップされない属性を公開するためのメカニズムを提供しておらず、実装者間で、それを行う方法について合意がありません。

User agents MUST also expose the entire role string through this mechanism and MAY also expose WAI-ARIA attributes and values through this mechanism even when there is a direct mapping to an accessibility API.
ユーザーエージェントは、このメカニズムを介してロール文字列全体を公開する必要があります（MUST）。 また、アクセシビリティ API に直接マッピングされている場合でも、このメカニズムを介して WAI-ARIA の属性と値を公開できます（MAY）。

Browser implementers are advised to publicly document their API methods for exposing any relevant information, so that assistive technology developers can use the API to support user features.
ブラウザーの実装者は、関連情報を公開するための API メソッドを公開して文書化することをお勧めします。 これにより、支援技術の開発者は API を使用してユーザー機能をサポートできます。




5.4 Role mapping §
5.4 ロールのマッピング §

Platform accessibility APIs traditionally have had a finite set of predefined roles that are expected by assistive technologies on that platform and only one or two roles may be exposed. In contrast, WAI-ARIA allows multiple roles to be specified as an ordered set of space-separated valid role tokens. The additional roles are fallback roles similar to the concept of specifying multiple fonts in case the first choice font type is not supported.
プラットフォームのアクセシビリティ API には、従来、そのプラットフォーム上の支援技術によって期待される事前定義されたロールの有限集合があり、1つまたは2つのロールのみが公開される可能性があります。 対照的に、WAI-ARIA では、スペースで区切られた有効なロールトークンの順序付きセットとして複数のロールを指定できます。 追加のロールは、最初に選択したフォントタイプがサポートされていない場合に、複数のフォントを指定するという概念に似たフォールバックのロールです。 




5.4.1 General rules §
5.4.1 一般規則 §

The following rules describe how to expose WAI-ARIA roles using the accessibility API:
次の規則は、アクセシビリティ API を使用して WAI-ARIA ロールを公開する方法を説明しています。

    The user agent MUST use the first token in the sequence of tokens in the role attribute value which matches the name of any non-abstract WAI-ARIA role according to rules that are specified in the Role Mapping Table below. See Conflicts between native markup semantics and WAI-ARIA for additional information. Note that when WAI-ARIA roles override host language semantics, there are no changes in the DOM, only in the accessibility tree. In the absence of author-supplied scripts, the presence of WAI-ARIA roles might not make sense. But user agents MUST map WAI-ARIA roles even in the absence of author-supplied scripts.
    ユーザーエージェントは、以下の「ロールのマッピング表」で指定されている規則に従って、非抽象 WAI-ARIA ロールの名前と一致するロール属性値のトークンシーケンスの最初のトークンを使用する必要があります（MUST）。 詳細については、「ネイティブなマークアップの意味論と WAI-ARIA の競合」を参照してください。 WAI-ARIA ロールがホスト言語の意味論をオーバーライドする場合、DOM は変更されず、アクセシビリティツリーのみが変更されることに注意してください。 作成者が提供するスクリプトがない場合、WAI-ARIA ロールの存在は意味をなさない可能性があります。 ただし、ユーザーエージェントは、作成者が提供するスクリプトがない場合でも、WAI-ARIA ロールをマップする必要があります。

    The following steps will correctly identify the applicable WAI-ARIA role:
    次の手順で、該当する WAI-ARIA ロールを正しく識別します。

        Use the rules of the host language to detect that an element has a role attribute and to identify the attribute value string for it.
        ホスト言語の規則を使用して、要素にロール属性があることを検出し、その属性値文字列を識別します。

        Separate the attribute value string for that attribute into a sequence of whitespace-free substrings by separating on whitespace.
        その属性の属性値文字列を、空白で区切ることにより、空白のない部分文字列のシーケンスに区切ります。

        Do a comparison of the substrings to all the names of the non-abstract WAI-ARIA roles. Case-sensitivity of the comparison inherits from the case-sensitivity of the host language.
        部分文字列を非抽象 WAI-ARIA ロールのすべての名前と比較します。 比較の大文字と小文字の区別は、ホスト言語の大文字と小文字の区別を継承します。

        Use the first such substring in textual order that matches the name of a non-abstract WAI-ARIA role for the API role mapping. See the Role Mapping Table below for details.
        API ロールマッピングの非抽象 WAI-ARIA ロールの名前と一致する最初の部分文字列をテキスト順に使用します。 詳細については、以下の「ロールのマッピング表」を参照してください。

    User agents MUST NOT map roles defined in the WAI-ARIA specification as "abstract" via the standard role mechanism of the accessibility API. Use the fallback procedure specified in the next rule if only an abstract role is provided. The abstract roles are:
    ユーザーエージェントは、アクセシビリティ API の標準のロールメカニズムを介して、WAI-ARIA 仕様で「抽象（abstract）」として定義されたロールをマップしてはなりません（MUST NOT）。 抽象ロールのみが提供されている場合は、次の規則で指定されているフォールバック手順を使用します。 抽象ロールは次のとおりです。

        command
        コマンド（command）

        composite
        複合（composite）

        input
        入力（input）

        landmark
        ランドマーク（landmark）

        range
        範囲（range）

        roletype
        ロールタイプ（roletype）

        section
        セクション（section）

        sectionhead
        セクションヘッド（sectionhead）

        select
        選択（select）

        structure
        構造（structure）

        widget
        ウィジェット（widget）

        window
        ウィンドウ （window）

    If the element does not have a role attribute, or if the role attribute contains no tokens matching the name of a non-abstract WAI-ARIA role, the user agent MUST fall back on normal processing of the base markup for the element. For example, for <table role="foo"> use the HTML table element to determine the platform accessibility API role mapping. For <input type="text" role="bar">, use the mapping for an HTML text input.
    要素にロール属性がない場合、またはロール属性に非抽象 WAI-ARIA ロールの名前と一致するトークンが含まれていない場合、ユーザーエージェントは要素の基本マークアップの通常の処理にフォールバックする必要があります（MUST）。 たとえば、<table role="foo"> の場合、HTML テーブル要素を使用してプラットフォームアクセシビリティ API ロールマッピングを決定します。 <input type="text" role="bar"> の場合、HTML テキスト入力のマッピングを使用します。

    When an explicit or inherited role of none or presentation is applied to an element, the user agent MUST implement the rules for the none or the presentation role defined in Accessible Rich Internet Applications (WAI-ARIA) 1.0 [wai-aria-1.1].
    none またはプレゼンテーションの明示的または継承されたロールが要素に適用される場合、ユーザーエージェントは「アクセス可能でリッチなインターネットアプリケーション（WAI-ARIA）1.0 [wai-aria-1.1]」で定義された、なし（none）ロールまたはプレゼンテーションロールの規則を実装する必要があります（MUST）。

    User agents MUST expose the WAI-ARIA role string if the API supports a mechanism to do so. This allows assistive technologies to do their own additional processing of roles.
    API が公開するメカニズムをサポートしている場合、ユーザーエージェントは WAI-ARIA ロール文字列を公開する必要があります（MUST）。 これにより、支援技術は独自のロールの追加処理を行うことができます。

        MSAA: not supported. User agents SHOULD NOT expose a custom role in MSAA's accRole property.
        MSAA：サポートされていません。 ユーザーエージェントは、MSAA の accRole プロパティでカスタムロールを公開するべきではありません（SHOULD NOT）。

        IAccessible2: expose as an object attribute pair (xml-roles:"string")
        IAccessible2：オブジェクト属性ペアとして公開（xml-roles:"string"）

        UIA: expose as AriaRole property. The AriaRole property can also support secondary roles using a space as a separator.
        UIA：AriaRole プロパティとして公開します。 AriaRole プロパティは、スペースを区切り文字として使用して、二次的なロールをサポートすることもできます。

        ATK/AT-SPI: expose as an object attribute pair (xml-roles:"string")
        ATK / AT-SPI：オブジェクト属性ペアとして公開（xml-roles:"string"）

    Platform accessibility APIs typically do not provide a vehicle to notify assistive technologies that a role has changed. Due to this and document caching, assistive technologies are unlikely to process a change in role attribute value. Authors who wish to change a role are advised by the WAI-ARIA specification to delete the associated element and its children and replace it with a new element having the appropriate role. If a role is changed, however, user agents SHOULD update the mapping in order to reflect the content in the DOM. Since assistive technologies will not know that the role has changed, user agents MAY address this error condition by treating it as removing a subtree item and inserting a new one as described in Changes to document content or node visibility.
    プラットフォームのアクセシビリティ API は通常、ロールが変更されたことを支援技術に通知する手段を提供しません。これと文書のキャッシュにより、支援技術がロール属性値の変更を処理する可能性はほとんどありません。 ロールを変更したい作成者は、WAI-ARIA 仕様により、関連する要素とその子を削除し、適切なロールを持つ新しい要素に置き換えることをお勧めします。 ただし、ロールが変更された場合、ユーザーエージェントは、コンテンツを DOM に反映するために、マッピングを更新するべきです（SHOULD）。 支援技術はロールが変更されたことを認識しないため、ユーザーエージェントは、「文書コンテンツやノードの可視性の変更」で説明されているように、サブツリー項目を削除し、新しい項目を挿入することで、このエラー状態に対処できます（MAY）。





5.4.2 Role Mapping Table §
5.4.2 ロールのマッピング表 §

Note
注意

Translators: For label text associated with the following table and its toggle buttons, see the mappingTableLabels object in the <head> section of this document.
翻訳者：次の表とそのトグルボタンに関連付けられているラベルテキストについては、この文書の <head> セクションにある mappingTableLabels オブジェクトを参照してください。


Table describing mapping of WAI-ARIA roles to accessibility APIs. WAI-ARIA Role 	MSAA + IAccessible2 	UIA 	ATK/AT-SPI 	AX API[Note 1]
WAI-ARIA ロールのアクセシビリティ API へのマッピングを説明する表。 WAI-ARIA ロール 	MSAA + IAccessible2 	UIA 	ATK / AT-SPI 	AX API [注1] 


alert 	Role: ROLE_SYSTEM_ALERT
アラート（alert） 	ロール：ROLE_SYSTEM_ALERT

Event: The user agent SHOULD fire EVENT_SYSTEM_ALERT. [Note 2] 	Control Type: Group
イベント：ユーザーエージェントは EVENT_SYSTEM_ALERT を発火させるべきです（SHOULD）。 [注2] 	コントロールタイプ：グループ（Group）

Localized Control Type: alert
ローカライズされたコントロールタイプ：アラート（alert）

LiveSetting: Assertive (2)
LiveSetting：独断的（2）

Event: The user agent SHOULD fire a system alert event. [Note 2] 	Role: ROLE_ALERT
イベント：ユーザーエージェントは、システムアラートイベントを発火させるべきです（SHOULD）。 [注2] 	ロール：ROLE_ALERT

Event: The user agent SHOULD fire a system alert event. [Note 2] 	AXRole: AXGroup
イベント：ユーザーエージェントは、システムアラートイベントを発火させるべきです（SHOULD）。 [注2] 	AXRole：AXGroup

AXSubrole: AXApplicationAlert
AXSubrole：AXApplicationAlert

AXRoleDescription: 'alert'
AXRoleDescription：'alert'

Event: The user agent SHOULD fire a system alert event. [Note 2]
イベント：ユーザーエージェントは、システムアラートイベントを発火させるべきです（SHOULD）。 [注2] 


alertdialog 	Role: ROLE_SYSTEM_DIALOG
アラートダイアログ（alertdialog） 	ロール：ROLE_SYSTEM_DIALOG

Event: The user agent SHOULD fire EVENT_SYSTEM_ALERT. [Note 2] 	Control Type: Pane
イベント：ユーザーエージェントは EVENT_SYSTEM_ALERT を発火させるべきです（SHOULD）。 [注2] 	コントロールタイプ：ペイン（Pane）

Event: The user agent SHOULD fire a system alert event. [Note 2] 	Role: ROLE_DIALOG
イベント：ユーザーエージェントは、システムアラートイベントを発火させるべきです（SHOULD）。 [注2] 	ロール：ROLE_DIALOG

Interface: Window
インターフェイス：Window

Event: The user agent SHOULD fire a system alert event. [Note 2] 	AXRole: AXGroup
イベント：ユーザーエージェントは、システムアラートイベントを発火させるべきです（SHOULD）。 [注2] 	AXRole：AXGroup

AXSubrole: AXApplicationAlertDialog
AXSubrole：AXApplicationAlertDialog

AXRoleDescription: 'web alert dialog'
AXRoleDescription：'web alert dialog'（ウェブアラートダイアログ）

Event: The user agent SHOULD fire a system alert event. [Note 2]
イベント：ユーザーエージェントは、システムアラートイベントを発火させるべきです（SHOULD）。 [注2] 


application 	Role: ROLE_SYSTEM_APPLICATION 	Control Type: Pane
アプリケーション（application） 	ロール：ROLE_SYSTEM_APPLICATION 	コントロールタイプ：ペイン（Pane）

Localized Control Type: application 	Role: ROLE_EMBEDDED 	AXRole: AXGroup
ローカライズされたコントロールタイプ：アプリケーション（application）	ロール：ROLE_EMBEDDED 	AXRole：AXGroup

AXSubrole: AXWebApplication
AXSubrole：AXWebApplication

AXRoleDescription: 'web application'
AXRoleDescription：'web application'（ウェブアプリケーション）


article 	Role: ROLE_SYSTEM_DOCUMENT
記事（article） 	ロール：ROLE_SYSTEM_DOCUMENT

State: STATE_SYSTEM_READONLY
状態：STATE_SYSTEM_READONLY

Object Attribute: xml-roles:article 	Control Type: Group
オブジェクト属性：xml-roles:article 	コントロールタイプ：グループ（Group）

Localized Control Type: article 	Role: ROLE_ARTICLE
ローカライズされたコントロールタイプ：記事（article） 	ロール：ROLE_ARTICLE

Object Attribute: xml-roles:article 	AXRole: AXGroup
オブジェクト属性：xml-roles:article 	AXRole：AXGroup

AXSubrole: AXDocumentArticle
AXSubrole：AXDocumentArticle

AXRoleDescription: 'article'
AXRoleDescription：'article'


banner 	Role: IA2_ROLE_LANDMARK
バナー（banner） 	ロール：IA2_ROLE_LANDMARK

Object Attribute: xml-roles:banner 	Control Type: Group
オブジェクト属性：xml-roles：banner 	コントロールタイプ：グループ（Group）

Localized Control Type: banner
ローカライズされたコントロールタイプ：バナー（banner）

Landmark Type: Custom
ランドマークタイプ：カスタム（Custom）

Localized Landmark Type: banner 	Role: ROLE_LANDMARK
ローカライズされたランドマークタイプ：バナー（banner） 	ロール：ROLE_LANDMARK

Object Attribute: xml-roles:banner 	AXRole: AXGroup
オブジェクト属性：xml-roles:banner 	AXRole：AXGroup

AXSubrole: AXLandmarkBanner
AXSubrole：AXLandmarkBanner

AXRoleDescription: 'banner'
AXRoleDescription：'banner'


button with default values for aria-pressed and aria-haspopup 	Role: ROLE_SYSTEM_PUSHBUTTON 	Control Type: Button 	Role: ROLE_PUSH_BUTTON 	AXRole: AXButton
ボタン（button。 aria-pressed および aria-haspopup がデフォルト値を持つボタン） 	ロール：ROLE_SYSTEM_PUSHBUTTON 	コントロールタイプ：ボタン（Button） 	ロール：ROLE_PUSH_BUTTON 	AXRole：AXButton

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'button'
AXRoleDescription：'button'


button with non-false value for aria-haspopup 	Role: ROLE_SYSTEM_BUTTONMENU 	Control Type: Button 	Role: ROLE_PUSH_BUTTON 	AXRole: AXPopUpButton
ボタン（button。 aria-haspopup が false 以外の値を持つボタン） 	ロール：ROLE_SYSTEM_BUTTONMENU 	コントロールタイプ：ボタン（Button） 	ロール：ROLE_PUSH_BUTTON 	AXRole：AXPopUpButton

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'pop up button'
AXRoleDescription：'pop up button'（ポップアップボタン）


button with defined value for aria-pressed 	Role: ROLE_SYSTEM_PUSHBUTTON
ボタン（button。 aria-pressed の値が定義されているボタン） 	ロール：ROLE_SYSTEM_PUSHBUTTON

Role: IA2_ROLE_TOGGLE_BUTTON 	Control Type: Button 	Role: ROLE_TOGGLE_BUTTON 	AXRole: AXCheckBox
ロール：IA2_ROLE_TOGGLE_BUTTON 	コントロールタイプ：ボタン（Button） 	ロール：ROLE_TOGGLE_BUTTON 	AXRole：AXCheckBox

AXSubrole: AXToggle
AXSubrole：AXToggle

AXRoleDescription: 'toggle button'
AXRoleDescription：'toggle button'（トグルボタン）



cell 	Role: ROLE_SYSTEM_CELL
セル（cell） 	ロール：ROLE_SYSTEM_CELL

Interface: IAccessibleTableCell 	Control Type: DataItem
インターフェイス：IAccessibleTableCell 	コントロールタイプ：データ項目（DataItem）

Localized Control Type: cell
ローカライズされたコントロールタイプ：セル（cell）

Control Pattern: TableItem 	Role: ROLE_TABLE_CELL
コントロールパターン：テーブル項目（TableItem） 	ロール：ROLE_TABLE_CELL

Interface: TableCell 	AXRole: AXCell
インターフェイス：TableCell 	AXRole：AXCell

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'cell'
AXRoleDescription：'cell'


checkbox 	Role: ROLE_SYSTEM_CHECKBUTTON
チェックボックス（checkbox） 	ロール：ROLE_SYSTEM_CHECKBUTTON

See also: aria-checked in the State and Property Mapping Table 	Control Type: Checkbox
参照：「状態とプロパティのマッピング表」の aria-checked 	コントロールタイプ：チェックボックス（Checkbox）

See also: aria-checked in the State and Property Mapping Table 	Role: ROLE_CHECK_BOX
参照：「状態とプロパティのマッピング表」の aria-checked 	ロール：ROLE_CHECK_BOX

See also: aria-checked in the State and Property Mapping Table 	AXRole: AXCheckBox
参照：「状態とプロパティのマッピング表」の aria-checked 	AXRole：AXCheckBox

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'checkbox'
AXRoleDescription：'checkbox'

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked


columnheader 	Role: ROLE_SYSTEM_COLUMNHEADER
列ヘッダー（columnheader） 	ロール：ROLE_SYSTEM_COLUMNHEADER

Interface: IAccessibleTableCell 	Control Type: HeaderItem 	Role: ROLE_COLUMN_HEADER
インターフェイス：IAccessibleTableCell 	コントロールタイプ：ヘッダー項目（HeaderItem） 	ロール：ROLE_COLUMN_HEADER

Interface: TableCell 	AXRole: AXCell
インターフェイス：TableCell 	AXRole：AXCell

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'cell'
AXRoleDescription：'cell'（セル）


combobox 	Role: ROLE_SYSTEM_COMBOBOX
コンボボックス（combobox） 	ロール：ROLE_SYSTEM_COMBOBOX

State: STATE_SYSTEM_HASPOPUP
状態：STATE_SYSTEM_HASPOPUP

State: STATE_SYSTEM_COLLAPSED if aria-expanded is not "true" 	Control Type: Combobox 	Role: ROLE_COMBO_BOX
状態：STATE_SYSTEM_COLLAPSED（aria-expanded が "true" でない場合）  	コントロールタイプ：コンボボックス（Combobox） 	ロール：ROLE_COMBO_BOX

State: STATE_EXPANDABLE
状態：STATE_EXPANDABLE

State: STATE_HAS_POPUP 	AXRole: AXComboBox
状態：STATE_HAS_POPUP 	AXRole：AXComboBox

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'combo box'
AXRoleDescription：'combo box'（コンボボックス）


complementary 	Role: IA2_ROLE_LANDMARK
補完的（complementary） 	ロール：IA2_ROLE_LANDMARK

Object Attribute: xml-roles:complementary 	Control Type: Group
オブジェクト属性：xml-roles:complementary 	コントロールタイプ：グループ（Group）

Localized Control Type: complementary
ローカライズされたコントロールタイプ：補完的（complementary）

Landmark Type: Custom
ランドマークタイプ：カスタム（Custom）

Localized Landmark Type: complementary 	Role: ROLE_LANDMARK
ローカライズされたランドマークタイプ：補完的（complementary） 	ロール：ROLE_LANDMARK

Object Attribute: xml-roles:complementary 	AXRole: AXGroup
オブジェクト属性：xml-roles:complementary 	AXRole：AXGroup

AXSubrole: AXLandmarkComplementary
AXSubrole：AXLandmarkComplementary

AXRoleDescription: 'complementary'
AXRoleDescription：'complementary'


contentinfo 	Role: IA2_ROLE_LANDMARK
コンテンツ情報（contentinfo） 	ロール：IA2_ROLE_LANDMARK

Object Attribute: xml-roles:contentinfo 	Control Type: Group
オブジェクト属性：xml-roles:contentinfo 	コントロールタイプ：グループ（Group）

Localized Control Type: content information
ローカライズされたコントロールタイプ：コンテンツ情報（content information）

Landmark Type: Custom
ランドマークタイプ：カスタム（Custom）

Localized Landmark Type: content information 	Role: ROLE_LANDMARK
ローカライズされたランドマークタイプ：コンテンツ情報（content information） 	ロール：ROLE_LANDMARK

Object Attribute: xml-roles:contentinfo 	AXRole: AXGroup
オブジェクト属性：xml-roles:contentinfo 	AXRole：AXGroup

AXSubrole: AXLandmarkContentInfo
AXSubrole：AXLandmarkContentInfo

AXRoleDescription: 'content information'
AXRoleDescription：'content information'（コンテンツ情報）


definition 	Object Attribute: xml-roles:definition 	Control Type: Group
定義（definition） 	オブジェクト属性：xml-roles:definition 	コントロールタイプ：グループ（Group）

Localized Control Type: definition 	Role: ROLE_DESCRIPTION_VALUE
ローカライズされたコントロールタイプ：定義（definition） 	ロール：ROLE_DESCRIPTION_VALUE

Object Attribute: xml-roles:definition 	AXRole: AXGroup
オブジェクト属性：xml-roles:definition 	AXRole：AXGroup

AXSubrole: AXDefinition
AXSubrole：AXDefinition

AXRoleDescription: 'definition'
AXRoleDescription：'definition'


dialog 	Role: ROLE_SYSTEM_DIALOG 	Control Type: Pane 	Role: ROLE_DIALOG
ダイアログ（dialog） 	ロール：ROLE_SYSTEM_DIALOG 	コントロールタイプ：ペイン（Pane） 	ロール：ROLE_DIALOG

Interface: Window 	AXRole: AXGroup
インターフェイス：Window 	AXRole：AXGroup

AXSubrole: AXApplicationDialog
AXSubrole：AXApplicationDialog

AXRoleDescription: 'web dialog'
AXRoleDescription：'web dialog'（ウェブダイアログ）


directory 	Role: ROLE_SYSTEM_LIST 	Control Type: List 	Role: ROLE_LIST 	AXRole: AXList
ディレクトリー（directory） 	ロール：ROLE_SYSTEM_LIST 	コントロールタイプ：リスト（List） 	ロール：ROLE_LIST 	AXRole：AXList

AXSubrole: AXContentList
AXSubrole：AXContentList

AXRoleDescription: 'content list'
AXRoleDescription：'content list'（コンテンツリスト）


document 	Role: ROLE_SYSTEM_DOCUMENT
文書（document） 	ロール：ROLE_SYSTEM_DOCUMENT

State: STATE_SYSTEM_READONLY 	Control Type: Document 	Role: ROLE_DOCUMENT_FRAME 	AXRole: AXGroup
状態：STATE_SYSTEM_READONLY 	コントロールタイプ：文書（Document） 	ロール：ROLE_DOCUMENT_FRAME 	AXRole：AXGroup

AXSubrole: AXDocument
AXSubrole：AXDocument

AXRoleDescription: 'document'
AXRoleDescription：'document'


feed 	Role: ROLE_SYSTEM_GROUPING
フィード（feed） 	ロール：ROLE_SYSTEM_GROUPING

Object Attribute: xml-roles:feed 	Control Type: Group
オブジェクト属性：xml-roles:feed 	コントロールタイプ：グループ（Group）

Localized Control Type: feed 	Role: ROLE_PANEL
ローカライズされたコントロールタイプ：フィード（feed） 	ロール：ROLE_PANEL

Object Attribute: xml-roles:feed 	AXRole: AXGroup
オブジェクト属性：xml-roles:feed 	AXRole：AXGroup

AXSubrole: AXApplicationGroup
AXSubrole：AXApplicationGroup

AXRoleDescription: 'feed'
AXRoleDescription：'feed'


figure 	Role: ROLE_SYSTEM_GROUPING
図（figure） 	ロール：ROLE_SYSTEM_GROUPING

Object Attribute: xml-roles:figure 	Control Type: Group
オブジェクト属性：xml-roles:figure 	コントロールタイプ：グループ（Group）

Localized Control Type: figure 	Role: ROLE_PANEL
ローカライズされたコントロールタイプ：図（figure） 	ロール：ROLE_PANEL

Object Attribute: xml-roles:figure 	AXRole: AXGroup
オブジェクト属性：xml-roles:figure 	AXRole：AXGroup

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'figure'
AXRoleDescription：'figure'


form 	Role: IA2_ROLE_FORM
フォーム（form） 	ロール：IA2_ROLE_FORM

Object Attribute: xml-roles:form 	Control Type: Group
オブジェクト属性：xml-roles:form 	コントロールタイプ：グループ（Group）

Localized Control Type: form
ローカライズされたコントロールタイプ：フォーム（form）

Landmark Type: Form 	Role: ROLE_LANDMARK
ランドマークタイプ：フォーム 	ロール：ROLE_LANDMARK

Object Attribute: xml-roles:form 	AXRole: AXGroup
オブジェクト属性：xml-roles:form 	AXRole：AXGroup

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'group'
AXRoleDescription：'group'（グループ）


grid 	Role: ROLE_SYSTEM_TABLE
グリッド（grid） 	ロール：ROLE_SYSTEM_TABLE

Object Attribute: xml-roles:grid
オブジェクト属性：xml-roles:grid

Interface: IAccessibleTable2
インターフェイス：IAccessibleTable2

Method: IAccessible::accSelect()
メソッド：IAccessible::accSelect()

Method: IAccessible::get_accSelection() 	Control Type: DataGrid
メソッド：IAccessible::get_accSelection() 	コントロールタイプ：データグリッド（DataGrid）

Control Pattern: Selection 	Role: ROLE_TABLE
コントロールパターン：選択（Selection） 	ロール：ROLE_TABLE

Object Attribute: xml-roles:grid
オブジェクト属性：xml-roles:grid

Interface: Table
インターフェイス：Table

Interface: Selection
インターフェイス：Selection

Because WAI-ARIA does not support modifying the selection via the accessibility API, user agents MUST return false for all Selection methods that provide a means to modify the selection.
WAI-ARIA はアクセシビリティ API を介した選択の変更をサポートしていないため、ユーザーエージェントは選択を変更する手段を提供するすべての Selection のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXTable
	AXRole：AXTable

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'table'
AXRoleDescription：'table'（テーブル）

AXColumnHeaderUIElements: a list of pointers to the columnheader elements
AXColumnHeaderUIElements：列ヘッダー要素へのポインターのリスト

AXHeader: a pointer to the row or group containing those columnheader elements
AXHeader：これらの列ヘッダー要素を含む行またはグループへのポインター

AXRowHeaderUIElements: a list of pointers to the rowheader elements
AXRowHeaderUIElements：行ヘッダー要素へのポインターのリスト 


gridcell 	Role: ROLE_SYSTEM_CELL
グリッドセル（gridcell） 	ロール：ROLE_SYSTEM_CELL

Interface: IAccessibleTableCell 	Control Type: DataItem
インターフェイス：IAccessibleTableCell 	コントロールタイプ：データ項目（DataItem）

Localized Control Type: gridcell
ローカライズされたコントロールタイプ：グリッドセル（gridcell）

Control Pattern: SelectionItem
コントロールパターン：選択項目（SelectionItem）

SelectionItem.SelectionContainer: the containing grid 	Role: ROLE_TABLE_CELL
SelectionItem.SelectionContainer：含んでいるグリッド 	ロール：ROLE_TABLE_CELL

Interface: TableCell 	AXRole: AXCell
インターフェイス：TableCell 	AXRole：AXCell

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'cell'
AXRoleDescription：'cell'（セル）


group 	Role: ROLE_SYSTEM_GROUPING 	Control Type: Group 	Role: ROLE_PANEL 	AXRole: AXGroup
グループ（group） 	ロール：ROLE_SYSTEM_GROUPING 	コントロールタイプ：グループ（Group） 	ロール：ROLE_PANEL 	AXRole：AXGroup

AXSubrole: AXApplicationGroup
AXSubrole：AXApplicationGroup

AXRoleDescription: 'group'
AXRoleDescription：'group'


heading 	Role: IA2_ROLE_HEADING
見出し（heading） 	ロール：IA2_ROLE_HEADING

Object Attribute: xml-roles:heading 	Control Type: Text
オブジェクト属性：xml-roles:heading 	コントロールタイプ：テキスト（Text）

Localized Control Type: heading 	Role: ROLE_HEADING 	AXRole: AXHeading
ローカライズされたコントロールタイプ：見出し（heading） 	ロール：ROLE_HEADING 	AXRole：AXHeading

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'heading'
AXRoleDescription：'heading'


img 	Role: ROLE_SYSTEM_GRAPHIC
画像（img） 	ロール：ROLE_SYSTEM_GRAPHIC

Interface: IAccessibleImage 	Control Type: Image 	Role: ROLE_IMAGE
インターフェイス：IAccessibleImage 	コントロールタイプ：画像（Image） 	ロール：ROLE_IMAGE

Interface: Image 	AXRole: AXImage
インターフェイス：Image  	AXRole：AXImage

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'image'
AXRoleDescription：'image'（画像）


link 	Role: ROLE_SYSTEM_LINK
リンク（link） 	ロール：ROLE_SYSTEM_LINK

State: STATE_SYSTEM_LINKED
状態：STATE_SYSTEM_LINKED

State: STATE_SYSTEM_LINKED on its descendants
状態：STATE_SYSTEM_LINKED（その子孫上について）

Interface: IAccessibleHypertext 	Control Type: HyperLink
インターフェイス：IAccessibleHypertext 	コントロールタイプ：ハイパーリンク（HyperLink）

Control Pattern: Value 	Role: ROLE_LINK
コントロールパターン：値（Value） 	ロール：ROLE_LINK

Interface: HyperlinkImpl 	AXRole: AXLink
インターフェイス：HyperlinkImpl 	AXRole：AXLink

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'link'
AXRoleDescription：'link'


list 	Role: ROLE_SYSTEM_LIST
リスト（list） 	ロール：ROLE_SYSTEM_LIST

State: STATE_SYSTEM_READONLY 	Control Type: List 	Role: ROLE_LIST 	AXRole: AXList
状態：STATE_SYSTEM_READONLY 	コントロールタイプ：リスト（List） 	ロール：ROLE_LIST 	AXRole：AXList

AXSubrole: AXContentList
AXSubrole：AXContentList

AXRoleDescription: 'content list'
AXRoleDescription：'content list'（コンテンツリスト） 


listbox not owned by or child of combobox 	Role: ROLE_SYSTEM_LIST
リストボックス（listbox。 コンボボックスが所有していないか、コンボボックスの子ではない） 	ロール：ROLE_SYSTEM_LIST

Method: IAccessible::accSelect()
メソッド：IAccessible::accSelect()

Method: IAccessible::get_accSelection() 	Control Type: List
メソッド：IAccessible::get_accSelection() 	コントロールタイプ：（List）

Control Pattern: Selection 	Role: ROLE_LIST_BOX
コントロールパターン：選択（Selection） 	ロール：ROLE_LIST_BOX

Interface: Selection
インターフェイス：Selection

Because WAI-ARIA does not support modifying the selection via the accessibility API, user agents MUST return false for all Selection methods that provide a means to modify the selection.
WAI-ARIA はアクセシビリティ API を介した選択の変更をサポートしていないため、ユーザーエージェントは選択を変更する手段を提供するすべての Selection のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXList
 	AXRole：AXList

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'list'
AXRoleDescription：'list'（リスト） 


listbox owned by or child of combobox 	Role: ROLE_SYSTEM_LIST
リストボックス（listbox。 コンボボックスが所有するか、コンボボックスの子である） 	ロール：ROLE_SYSTEM_LIST

Method: IAccessible::accSelect()
メソッド：IAccessible::accSelect()

Method: IAccessible::get_accSelection() 	Control Type: List
メソッド：IAccessible::get_accSelection() 	コントロールタイプ：リスト（List）

Control Pattern: Selection 	Role: ROLE_MENU
コントロールパターン：選択（Selection） 	ロール：ROLE_MENU

Interface: Selection
インターフェイス：Selection

Because WAI-ARIA does not support modifying the selection via the accessibility API, user agents MUST return false for all Selection methods that provide a means to modify the selection.
WAI-ARIA はアクセシビリティ API を介した選択の変更をサポートしていないため、ユーザーエージェントは選択を変更する手段を提供するすべての Selection のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXList
 	AXRole：AXList

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'list'
AXRoleDescription：'list'（リスト）


listitem 	Role: ROLE_SYSTEM_LISTITEM
リスト項目（listitem） 	ロール：ROLE_SYSTEM_LISTITEM

State: STATE_SYSTEM_READONLY 	Control Type: ListItem
状態：STATE_SYSTEM_READONLY 	コントロールタイプ：リスト項目（ListItem）

Control Pattern: SelectionItem
コントロールパターン：選択項目（SelectionItem）

SelectionItem.SelectionContainer: the containing list 	Role: ROLE_LIST_ITEM 	AXRole: AXGroup
SelectionItem.SelectionContainer：含んでいるリスト 	ロール：ROLE_LIST_ITEM 	AXRole：AXGroup

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'group'
AXRoleDescription：'group'（グループ）


log 	Object Attribute: xml-roles:log
ログ（log） 	オブジェクト属性：xml-roles:log

Object Attribute: container-live:polite
オブジェクト属性：container-live:polite

Object Attribute: live:polite
オブジェクト属性：live:polite

Object Attribute: container-live-role:log 	Control Type: Group
オブジェクト属性：container-live-role:log 	コントロールタイプ：グループ（Group）

Localized Control Type: log
ローカライズされたコントロールタイプ：ログ（log）

LiveSetting: Polite (1) 	Role: ROLE_LOG
LiveSetting：丁寧（1） 	ロール：ROLE_LOG

Object Attribute: xml-roles:log
オブジェクト属性：xml-roles:log

Object Attribute: container-live:polite
オブジェクト属性：container-live:polite

Object Attribute: live:polite
オブジェクト属性：live:polite

Object Attribute: container-live-role:log 	AXRole: AXGroup
オブジェクト属性：container-live-role:log 	AXRole：AXGroup

AXSubrole: AXApplicationLog
AXSubrole：AXApplicationLog

AXRoleDescription: 'log'
AXRoleDescription：'log'


main 	Role: IA2_ROLE_LANDMARK
メイン（main） 	ロール：IA2_ROLE_LANDMARK

Object Attribute: xml-roles:main 	Control Type: Group
オブジェクト属性：xml-roles:main 	コントロールタイプ：グループ（Group）

Localized Control Type: main
ローカライズされたコントロールタイプ：メイン（main）

Landmark Type: Main 	Role: ROLE_LANDMARK
ランドマークタイプ：メイン 	ロール：ROLE_LANDMARK

Object Attribute: xml-roles:main 	AXRole: AXGroup
オブジェクト属性：xml-roles:main 	AXRole：AXGroup

AXSubrole: AXLandmarkMain
AXSubrole：AXLandmarkMain

AXRoleDescription: 'main'
AXRoleDescription：'main'


marquee 	Role: ROLE_SYSTEM_ANIMATION
マーキー（marquee） 	ロール：ROLE_SYSTEM_ANIMATION

Object Attribute: xml-roles:marquee
オブジェクト属性：xml-roles:marquee

Object Attribute: container-live:off
オブジェクト属性：container-live:off

Object Attribute: live:off 	Control Type: Group
オブジェクト属性：live:off 	コントロールタイプ：グループ（Group）

Localized Control Type: marquee
ローカライズされたコントロールタイプ：マーキー（marquee）

LiveSetting: Off (0) 	Role: ROLE_MARQUEE
LiveSetting：オフ（0） 	ロール：ROLE_MARQUEE

Object Attribute: container-live:off
オブジェクト属性：container-live:off

Object Attribute: live:off 	AXRole: AXGroup
オブジェクト属性：live:off 	AXRole：AXGroup

AXSubrole: AXApplicationMarquee
AXSubrole：AXApplicationMarquee

AXRoleDescription: 'marquee'
AXRoleDescription：'marquee'


math 	Role: ROLE_SYSTEM_EQUATION 	Control Type: Group
数学（math） 	ロール：ROLE_SYSTEM_EQUATION 	コントロールタイプ：グループ（Group）

Localized Control Type: math 	Role: ROLE_MATH 	AXRole: AXGroup
ローカライズされたコントロールタイプ：数学（math） 	ロール：ROLE_MATH 	AXRole：AXGroup

AXSubrole: AXDocumentMath
AXSubrole：AXDocumentMath

AXRoleDescription: 'math'
AXRoleDescription：'math'


menu 	Role: ROLE_SYSTEM_MENUPOPUP
メニュー（menu） 	ロール：ROLE_SYSTEM_MENUPOPUP

Method: IAccessible::accSelect()
メソッド：IAccessible::accSelect()

Method: IAccessible::get_accSelection() 	Control Type: Menu 	Role: ROLE_MENU
メソッド：IAccessible::get_accSelection() 	コントロールタイプ：メニュー（Menu） 	ロール：ROLE_MENU

Interface: Selection
インターフェイス：Selection

Because WAI-ARIA does not support modifying the selection via the accessibility API, user agents MUST return false for all Selection methods that provide a means to modify the selection.
WAI-ARIA はアクセシビリティ API を介した選択の変更をサポートしていないため、ユーザーエージェントは選択を変更する手段を提供するすべての Selection のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXMenu
 	AXRole：AXMenu

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'menu'
AXRoleDescription：'menu'


menubar 	Role: ROLE_SYSTEM_MENUBAR
メニューバー（menubar） 	ロール：ROLE_SYSTEM_MENUBAR

Method: IAccessible::accSelect()
メソッド：IAccessible::accSelect()

Method: IAccessible::get_accSelection() 	Control Type: MenuBar 	Role: ROLE_MENU_BAR
メソッド：IAccessible::get_accSelection() 	コントロールタイプ：メニューバー（MenuBar） 	ロール：ROLE_MENU_BAR

Interface: Selection
インターフェイス：Selection

Because WAI-ARIA does not support modifying the selection via the accessibility API, user agents MUST return false for all Selection methods that provide a means to modify the selection.
WAI-ARIA はアクセシビリティ API を介した選択の変更をサポートしていないため、ユーザーエージェントは選択を変更する手段を提供するすべての Selection のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXMenuBar
 	AXRole：AXMenuBar

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'menu bar'
AXRoleDescription：'menu bar'（メニューバー）


menuitem not owned by or child of group 	Role: ROLE_SYSTEM_MENUITEM 	Control Type: MenuItem 	Role: ROLE_MENU_ITEM 	AXRole: AXMenuItem
メニュー項目（menuitem。 グループが所有していないか、グループの子ではない） 	ロール：ROLE_SYSTEM_MENUITEM 	コントロールタイプ：メニュー項目（MenuItem） 	ロール：ROLE_MENU_ITEM 	AXRole：AXMenuItem

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'menu item'
AXRoleDescription：'menu item'（メニュー項目）


menuitem owned by or child of group 	Role: ROLE_SYSTEM_MENUITEM 	Control Type: MenuItem 	Role: ROLE_MENU_ITEM 	AXRole: AXMenuButton
メニュー項目（menuitem。 グループが所有しているか、グループの子である） 	ロール：ROLE_SYSTEM_MENUITEM 	コントロールタイプ：メニュー項目（MenuItem） 	ロール：ROLE_MENU_ITEM 	AXRole：AXMenuButton

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'menu button'
AXRoleDescription：'menu button'（メニューボタン）


menuitemcheckbox 	Role: ROLE_SYSTEM_CHECKBUTTON or ROLE_SYSTEM_MENUITEM
メニュー項目チェックボックス（menuitemcheckbox） 	ロール：ROLE_SYSTEM_CHECKBUTTON または ROLE_SYST EM_MENUITEM

Role: IA2_ROLE_CHECK_MENU_ITEM
ロール：IA2_ROLE_CHECK_MENU_ITEM

See also: aria-checked in the State and Property Mapping Table 	Control Type: MenuItem
参照：「状態とプロパティのマッピング表」の aria-checked 	コントロールタイプ：メニュー項目（MenuItem）

Control Pattern: Toggle
コントロールパターン：トグル（Toggle）

See also: aria-checked in the State and Property Mapping Table 	Role: ROLE_CHECK_MENU_ITEM
参照：「状態とプロパティのマッピング表」の aria-checked 	ロール：ROLE_CHECK_MENU_ITEM

See also: aria-checked in the State and Property Mapping Table 	AXRole: AXMenuItem
参照：「状態とプロパティのマッピング表」の aria-checked 	AXRole：AXMenuItem

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'menu item'
AXRoleDescription：'menu item'（メニュー項目）

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked 


menuitemradio 	Role: ROLE_SYSTEM_RADIOBUTTON or ROLE_SYSTEM_MENUITEM
メニュー項目ラジオボタン（menuitemradio） 	ロール：ROLE_SYSTEM_RADIOBUTTON または ROLE_SYSTEM_MENUITEM

Role: IA2_ROLE_RADIO_MENU_ITEM
ロール：IA2_ROLE_RADIO_MENU_ITEM

See also: aria-checked in the State and Property Mapping Table 	Control Type: MenuItem
参照：「状態とプロパティのマッピング表」の aria-checked 	コントロールタイプ：メニュー項目（MenuItem）

Control Pattern: Toggle
コントロールパターン：トグル（Toggle）

Control Pattern: SelectionItem
コントロールパターン：選択項目（SelectionItem）

See also: aria-checked in the State and Property Mapping Table 	Role: ROLE_RADIO_MENU_ITEM
参照：「状態とプロパティのマッピング表」の aria-checked 	ロール：ROLE_RADIO_MENU_ITEM

See also: aria-checked in the State and Property Mapping Table 	AXRole: AXMenuItem
参照：「状態とプロパティのマッピング表」の aria-checked 	AXRole：AXMenuItem

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'menu item'
AXRoleDescription：'menu item'（メニュー項目）

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked 


navigation 	Role: IA2_ROLE_LANDMARK
ナビゲーション（navigation） 	ロール：IA2_ROLE_LANDMARK

Object Attribute: xml-roles:navigation 	Control Type: Group
オブジェクト属性：xml-roles:navigation 	コントロールタイプ：グループ（Group）

Localized Control Type: navigation
ローカライズされたコントロールタイプ：ナビゲーション（navigation）

Landmark Type: Navigation 	Role: ROLE_LANDMARK
ランドマークタイプ：ナビゲーション 	ロール：ROLE_LANDMARK

Object Attribute: xml-roles:navigation 	AXRole: AXGroup
オブジェクト属性：xml-roles:navigation 	AXRole：AXGroup

AXSubrole: AXLandmarkNavigation
AXSubrole：AXLandmarkNavigation

AXRoleDescription: 'navigation'
AXRoleDescription：'navigation'


none 	
なし（none） 	

See General rules for exposing WAI-ARIA semantics.
「WAI-ARIA 意味論を公開するための一般的な規則」を参照してください。

For objects that have required owned descendants (e.g., a grid owns gridcells, a list owns listitems), and the descendant is in the accessibility tree, expose it as IA2_ROLE_TEXT_FRAME. User agents SHOULD prune empty descendants from the accessibility tree.
所有された子孫が必要なオブジェクト（グリッドがグリッドセルを所有し、リストがリスト項目を所有するなど）で、子孫がアクセシビリティツリーにある場合は、IA2_ROLE_TEXT_FRAME として公開します。 ユーザーエージェントは、アクセシビリティツリーから空の子孫を削除するべきです（SHOULD）。

	

See General rules for exposing WAI-ARIA semantics.
「WAI-ARIA 意味論を公開するための一般的な規則」を参照してください。

For objects that have required owned descendants (e.g., a grid owns gridcells, a list owns listitems), and the descendant is in the accessibility tree, expose it using the text pattern. User agents SHOULD prune empty descendants from the accessibility tree.
所有する子孫が必要なオブジェクト（グリッドがグリッドセルを所有し、リストがリスト項目を所有するなど）で、子孫がアクセシビリティツリーにある場合は、テキストパターンを使用して公開します。 ユーザーエージェントは、アクセシビリティツリーから空の子孫を削除するべきです（SHOULD）。

	

See General rules for exposing WAI-ARIA semantics.
「WAI-ARIA 意味論を公開するための一般的な規則」を参照してください。

For objects that have required owned descendants (e.g., a grid owns gridcells, a list owns listitems), and the descendant is in the accessibility tree, expose it as ROLE_SECTION. User agents SHOULD prune empty descendants from the accessibility tree.
所有された子孫が必要なオブジェクト（グリッドがグリッドセルを所有し、リストがリスト項目を所有するなど）で、子孫がアクセシビリティツリーにある場合は、ROLE_SECTION として公開します。 ユーザーエージェントは、アクセシビリティツリーから空の子孫を削除するべきです（SHOULD）。

	

See General rules for exposing WAI-ARIA semantics.
「WAI-ARIA意味論を公開するための一般的な規則」を参照してください。

For objects that have required owned descendants (e.g., a grid owns gridcells, a list owns listitems), and the descendant is in the accessibility tree, expose it as AXGroup. User agents SHOULD prune empty descendants from the accessibility tree.
所有された子孫が必要なオブジェクト（グリッドがグリッドセルを所有し、リストがリスト項目を所有するなど）で、子孫がアクセシビリティツリーにある場合は、AXGroup として公開します。 ユーザーエージェントは、アクセシビリティツリーから空の子孫を削除するべきです（SHOULD）。


note 	Role: IA2_ROLE_NOTE 	Control Type: Group
メモ（note） 	ロール：IA2_ROLE_NOTE 	コントロールタイプ：グループ（Group）

Localized Control Type: note 	Role: ROLE_COMMENT 	AXRole: AXGroup
ローカライズされたコントロールタイプ：メモ（note） 	ロール：ROLE_COMMENT 	AXRole：AXGroup

AXSubrole: AXDocumentNote
AXSubrole：AXDocumentNote

AXRoleDescription: 'note'
AXRoleDescription：'note'


option not inside combobox 	Role: ROLE_SYSTEM_LISTITEM
オプション（option。 コンボボックス内にない） 	ロール：ROLE_SYSTEM_LISTITEM

See also: aria-checked in the State and Property Mapping Table 	Control Type: ListItem
参照：「状態とプロパティのマッピング表」の aria-checked 	コントロールタイプ：リスト項目（ListItem）

Control Pattern: Invoke
コントロールパターン：呼び出す（Invoke）

See also: aria-checked in the State and Property Mapping Table 	Role: ROLE_LIST_ITEM
参照：「状態とプロパティのマッピング表」の aria-checked 	ロール：ROLE_LIST_ITEM

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked

	AXRole: AXStaticText
 	AXRole：AXStaticText

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'text'
AXRoleDescription：'text'（テキスト）

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked 


option inside combobox 	Role: ROLE_SYSTEM_LISTITEM
オプション（option。 コンボボックス内にある） 	ロール：ROLE_SYSTEM_LISTITEM

See also: aria-checked in the State and Property Mapping Table 	Control Type: ListItem
参照：「状態とプロパティのマッピング表」の aria-checked 	コントロールタイプ：リスト項目（ListItem）

Control Pattern: Invoke
コントロールパターン：呼び出す（Invoke）

See also: aria-checked in the State and Property Mapping Table 	Role: ROLE_MENU_ITEM
参照：「状態とプロパティのマッピング表」の aria-checked 	ロール：ROLE_MENU_ITEM

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked

	AXRole: AXStaticText
 	AXRole：AXStaticText

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'text'
AXRoleDescription：'text'（テキスト）

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked 


presentation 	
プレゼンテーション（presentation） 	

See General rules for exposing WAI-ARIA semantics.
「WAI-ARIA 意味論を公開するための一般的な規則」を参照してください。

For objects that have required owned descendants (e.g., a grid owns gridcells, a list owns listitems), and the descendant is in the accessibility tree, expose it as IA2_ROLE_TEXT_FRAME. User agents SHOULD prune empty descendants from the accessibility tree.
所有された子孫が必要なオブジェクト（グリッドがグリッドセルを所有し、リストがリスト項目を所有するなど）で、子孫がアクセシビリティツリーにある場合は、IA2_ROLE_TEXT_FRAME として公開します。 ユーザーエージェントは、アクセシビリティツリーから空の子孫を削除するべきです（SHOULD）。

	

See General rules for exposing WAI-ARIA semantics.
「WAI-ARIA 意味論を公開するための一般的な規則」を参照してください。

For objects that have required owned descendants (e.g., a grid owns gridcells, a list owns listitems), and the descendant is in the accessibility tree, expose it using the text pattern. User agents SHOULD prune empty descendants from the accessibility tree.
所有する子孫が必要なオブジェクト（グリッドがグリッドセルを所有し、リストがリスト項目を所有するなど）で、子孫がアクセシビリティツリーにある場合は、テキストパターンを使用して公開します。 ユーザーエージェントは、アクセシビリティツリーから空の子孫を削除するべきです（SHOULD）。

	

See General rules for exposing WAI-ARIA semantics.
「WAI-ARIA 意味論を公開するための一般的な規則」を参照してください。

For objects that have required owned descendants (e.g., a grid owns gridcells, a list owns listitems), and the descendant is in the accessibility tree, expose it as ROLE_SECTION. User agents SHOULD prune empty descendants from the accessibility tree.
所有された子孫が必要なオブジェクト（グリッドがグリッドセルを所有し、リストがリスト項目を所有するなど）で、子孫がアクセシビリティツリーにある場合は、ROLE_SECTION として公開します。 ユーザーエージェントは、アクセシビリティツリーから空の子孫を削除するべきです（SHOULD）。

	

See General rules for exposing WAI-ARIA semantics.
「WAI-ARIA 意味論を公開するための一般的な規則」を参照してください。

For objects that have required owned descendants (e.g., a grid owns gridcells, a list owns listitems), and the descendant is in the accessibility tree, expose it as AXGroup. User agents SHOULD prune empty descendants from the accessibility tree.
所有された子孫が必要なオブジェクト（グリッドがグリッドセルを所有し、リストがリスト項目を所有するなど）で、子孫がアクセシビリティツリーにある場合は、AXGroup として公開します。 ユーザーエージェントは、アクセシビリティツリーから空の子孫を削除するべきです（SHOULD）。


progressbar 	Role: ROLE_SYSTEM_PROGRESSBAR
プログレスバー（progressbar） 	ロール：ROLE_SYSTEM_PROGRESSBAR

State: STATE_SYSTEM_READONLY
状態：STATE_SYSTEM_READONLY

Interface: IAcesssibleValue 	Control Type: ProgressBar
インターフェイス：IAcesssibleValue 	コントロールタイプ：プログレスバー（ProgressBar）

Control Pattern: RangeValue if aria-valuenow, aria-valuemax, or aria-valuemin is present 	Role: ROLE_PROGRESS_BAR
コントロールパターン：範囲値（RangeValue。 aria-valuenow、aria-valuemax、または aria-valuemin が存在する場合） 	ロール：ROLE_PROGRESS_BAR

Interface: Value
インターフェイス：Value

Because WAI-ARIA does not support modifying the value via the accessibility API, user agents MUST return false for all Value methods that provide a means to modify the value.
WAI-ARIA はアクセシビリティ API を介した値の変更をサポートしていないため、ユーザーエージェントは、値を変更する手段を提供するすべての Value のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXProgressIndicator
 	AXRole：AXProgressIndicator

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'progress indicator'
AXRoleDescription：'progress indicator'（進行状況インジケーター）


radio 	Role: ROLE_SYSTEM_RADIOBUTTON
ラジオボタン（radio） 	ロール：ROLE_SYSTEM_RADIOBUTTON

See also: aria-checked in the State and Property Mapping Table 	Control Type: RadioButton
参照：「状態とプロパティのマッピング表」の aria-checked 	コントロールタイプ：ラジオボタン（RadioButton）

Control Pattern: Toggle
コントロールパターン：トグル（Toggle）

Control Pattern: SelectionItem
コントロールパターン：選択項目（SelectionItem）

See also: aria-checked in the State and Property Mapping Table 	Role: ROLE_RADIO_BUTTON
参照：「状態とプロパティのマッピング表」の aria-checked 	ロール：ROLE_RADIO_BUTTON

See also: aria-checked in the State and Property Mapping Table 	AXRole: AXRadioButton
参照：「状態とプロパティのマッピング表」の aria-checked 	AXRole：AXRadioButton

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'radio button'
AXRoleDescription：'radio button'（ラジオボタン）

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked 


radiogroup 	Role: ROLE_SYSTEM_GROUPING 	Control Type: List 	Role: ROLE_PANEL 	AXRole: AXRadioGroup
ラジオグループ（radiogroup） 	ロール：ROLE_SYSTEM_GROUPING 	コントロールタイプ：リスト（List） 	ロール：ROLE_PANEL 	AXRole：AXRadioGroup

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'radio group'
AXRoleDescription：'radio group'（ラジオグループ）


region with an accessible name 	Role: IA2_ROLE_LANDMARK
リージョン（region。 アクセス可能な名前がある） 	ロール：IA2_ROLE_LANDMARK

Object Attribute: xml-roles:region 	Control Type: Group
オブジェクト属性：xml-roles:region 	コントロールタイプ：グループ（Group）

Localized Control Type: region
ローカライズされたコントロールタイプ：リージョン（region）

Landmark Type: Custom
ランドマークタイプ：カスタム（Custom）

Localized Landmark Type: region 	Role: ROLE_LANDMARK
ローカライズされたランドマークタイプ：リージョン（region） 	ロール：ROLE_LANDMARK

Object Attribute: xml-roles:region 	AXRole: AXGroup
オブジェクト属性：xml-roles:region 	AXRole：AXGroup

AXSubrole: AXLandmarkRegion
AXSubrole：AXLandmarkRegion

AXRoleDescription: 'region'
AXRoleDescription：'region'


region without an accessible name 	Do not expose the element as a landmark. Use the native host language role of the element instead. 	Do not expose the element as a landmark. Use the native host language role of the element instead. 	Do not expose the element as a landmark. Use the native host language role of the element instead. 	Do not expose the element as a landmark. Use the native host language role of the element instead.
リージョン（region。 アクセス可能な名前がない） 	要素をランドマークとして公開しないでください。 代わりに、要素のネイティブホスト言語のロールを使用してください。 	要素をランドマークとして公開しないでください。 代わりに、要素のネイティブホスト言語のロールを使用してください。 	要素をランドマークとして公開しないでください。 代わりに、要素のネイティブホスト言語のロールを使用してください。 	要素をランドマークとして公開しないでください。 代わりに、要素のネイティブホスト言語のロールを使用してください。 


row not inside treegrid 	Role: ROLE_SYSTEM_ROW 	Control Type: DataItem
行（row。 ツリーグリッド内にない） 	ロール：ROLE_SYSTEM_ROW 	コントロールタイプ：データ項目（DataItem）

Localized Control Type: row
ローカライズされたコントロールタイプ：行（row）

Control Pattern: SelectionItem 	Role: ROLE_TABLE_ROW 	AXRole: AXRow
コントロールパターン：選択項目（SelectionItem） 	ロール：ROLE_TABLE_ROW 	AXRole：AXRow

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'row'
AXRoleDescription：'row'


row inside treegrid 	Role: ROLE_SYSTEM_OUTLINEITEM 	Control Type: DataItem
行（row。 ツリーグリッド内にある） 	ロール：ROLE_SYSTEM_OUTLINEITEM 	コントロールタイプ：データ項目（DataItem）

Localized Control Type: row
ローカライズされたコントロールタイプ：行（row）

Control Pattern: SelectionItem 	Role: ROLE_TABLE_ROW 	AXRole: AXRow
コントロールパターン：選択項目（SelectionItem） 	ロール：ROLE_TABLE_ROW 	AXRole：AXRow

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'row'
AXRoleDescription：'row'


rowgroup 	Role: ROLE_SYSTEM_GROUPING 	Control Type: Group 	Role: ROLE_PANEL 	Not mapped
行グループ（rowgroup） 	ロール：ROLE_SYSTEM_GROUPING 	コントロールタイプ：グループ（Group） 	ロール：ROLE_PANEL 	マップされていない


rowheader 	Role: ROLE_SYSTEM_ROWHEADER
行ヘッダー（rowheader） 	ロール：ROLE_SYSTEM_ROWHEADER

Interface: IAccessibleTableCell 	Control Type: HeaderItem 	Role: ROLE_ROW_HEADER
インターフェイス：IAccessibleTableCell 	コントロールタイプ：ヘッダー項目（HeaderItem） 	ロール：ROLE_ROW_HEADER

Interface: TableCell 	AXRole: AXCell
インターフェイス：TableCell 	AXRole：AXCell

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'cell'
AXRoleDescription：'cell'（セル）


scrollbar 	Role: ROLE_SYSTEM_SCROLLBAR
スクロールバー（scrollbar） 	ロール：ROLE_SYSTEM_SCROLLBAR

Interface: IAcesssibleValue 	Control Type: ScrollBar
インターフェイス：IAcesssibleValue 	コントロールタイプ：スクロールバー（ScrollBar）

Control Pattern: RangeValue 	Role: ROLE_SCROLL_BAR
コントロールパターン：範囲値（RangeValue） 	ロール：ROLE_SCROLL_BAR

Interface: Value
インターフェイス：Value

Because WAI-ARIA does not support modifying the value via the accessibility API, user agents MUST return false for all Value methods that provide a means to modify the value.
WAI-ARIA はアクセシビリティ API を介した値の変更をサポートしていないため、ユーザーエージェントは、値を変更する手段を提供するすべての Value のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXScrollBar
 	AXRole：AXScrollBar

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'scroll bar'
AXRoleDescription：'scroll bar'（スクロールバー）


search 	Role: IA2_ROLE_LANDMARK
検索（search） 	ロール：IA2_ROLE_LANDMARK

Object Attribute: xml-roles:search 	Control Type: Group
オブジェクト属性：xml-roles:search 	コントロールタイプ：グループ（Group）

Localized Control Type: search
ローカライズされたコントロールタイプ：検索（search）

Landmark Type: Search 	Role: ROLE_LANDMARK
ランドマークタイプ：検索（Search） 	ロール：ROLE_LANDMARK

Object Attribute: xml-roles:search 	AXRole: AXGroup
オブジェクト属性：xml-roles:search 	AXRole：AXGroup

AXSubrole: AXLandmarkSearch
AXSubrole：AXLandmarkSearch

AXRoleDescription: 'search'
AXRoleDescription：'search'


searchbox 	Role: ROLE_SYSTEM_TEXT
検索ボックス（searchbox） 	ロール：ROLE_SYSTEM_TEXT

Object Attribute: text-input-type:search 	Control Type: Edit
オブジェクト属性：text-input-type:search 	コントロールタイプ：編集（Edit）

Localized Control Type: search box 	Role: ROLE_ENTRY
ローカライズされたコントロールタイプ：検索ボックス（search box） 	ロール：ROLE_ENTRY

Object Attribute: xml-roles:searchbox
オブジェクト属性：text-input-type:search

Interface: EditableText if aria-readonly is not "true" 	AXRole: AXTextField
インターフェイス：EditableText（aria-readonly が "true" でない場合） 	AXRole：AXTextField

AXSubrole: AXSearchField
AXSubrole：AXSearchField

AXRoleDescription: 'search text field'
AXRoleDescription：'search text field'（検索テキストフィールド）


separator (non-focusable) 	Role: ROLE_SYSTEM_SEPARATOR 	Control Type: Separator 	Role: ROLE_SEPARATOR 	AXRole: AXSplitter
区切り（separator。 フォーカス不可の） 	ロール：ROLE_SYSTEM_SEPARATOR 	コントロールタイプ：区切り（Separator） 	ロール：ROLE_SEPARATOR 	AXRole：AXSplitter

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'splitter'
AXRoleDescription：'splitter'（スプリッター）


separator (focusable) 	Role: ROLE_SYSTEM_SEPARATOR
区切り（separator。 フォーカス可の） 	ロール：ROLE_SYSTEM_SEPARATOR

Interface: IAccessibleValue 	Control Type: Thumb
インターフェイス：IAccessibleValue 	コントロールタイプ：つまみ（Thumb）

Control Pattern: RangeValue 	Role: ROLE_SEPARATOR
コントロールパターン：範囲値（RangeValue） 	ロール：ROLE_SEPARATOR

Interface: Value
インターフェイス：Value

Because WAI-ARIA does not support modifying the value via the accessibility API, user agents MUST return false for all Value methods that provide a means to modify the value.
WAI-ARIA はアクセシビリティ API を介した値の変更をサポートしていないため、ユーザーエージェントは、値を変更する手段を提供するすべての Value のメソッドに対して false を返す必要があります（MUST）。 

	AXRole: AXSplitter
 	AXRole：AXSplitter

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'splitter'
AXRoleDescription：'splitter'（スプリッター）


slider 	Role: ROLE_SYSTEM_SLIDER
スライダー（slider） 	ロール：ROLE_SYSTEM_SLIDER

Interface: IAcesssibleValue 	Control Type: Slider
インターフェイス：IAcesssibleValue 	コントロールタイプ：スライダー（Slider）

Control Pattern: RangeValue 	Role: ROLE_SLIDER
コントロールパターン：範囲値（RangeValue） 	ロール：ROLE_SLIDER

Interface: Value
インターフェイス：Value

Because WAI-ARIA does not support modifying the value via the accessibility API, user agents MUST return false for all Value methods that provide a means to modify the value.
WAI-ARIA はアクセシビリティ API を介した値の変更をサポートしていないため、ユーザーエージェントは、値を変更する手段を提供するすべての Value のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXSlider
 	AXRole：AXSlider

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'slider'
AXRoleDescription：'slider'


spinbutton 	Role: ROLE_SYSTEM_SPINBUTTON
スピンボタン（spinbutton） 	ロール：ROLE_SYSTEM_SPINBUTTON

Interface: IAcesssibleValue 	Control Type: Spinner
インターフェイス：IAcesssibleValue 	コントロールタイプ：スピナー（Spinner）

Control Pattern: RangeValue 	Role: ROLE_SPIN_BUTTON
コントロールパターン：範囲値（RangeValue） 	ロール：ROLE_SPIN_BUTTON

Interface: Value
インターフェイス：Value

Because WAI-ARIA does not support modifying the value via the accessibility API, user agents MUST return false for all Value methods that provide a means to modify the value.
WAI-ARIA はアクセシビリティAPIを介した値の変更をサポートしていないため、ユーザーエージェントは、値を変更する手段を提供するすべての Value のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXIncrementor
 	AXRole：AXIncrementor

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'stepper'
AXRoleDescription：'stepper'（ステッパー）


status 	Role: ROLE_SYSTEM_STATUSBAR
ステータス（status） 	ロール：ROLE_SYSTEM_STATUSBAR

Object Attribute: container-live:polite
オブジェクト属性：container-live:polite

Object Attribute: live:polite
オブジェクト属性：live:polite

Object Attribute: container-live-role:status 	Control Type: Group
オブジェクト属性：container-live-role:status 	コントロールタイプ：グループ（Group）

Localized Control Type: status
ローカライズされたコントロールタイプ：ステータス（status）

LiveSetting: Polite (1) 	Role: ROLE_STATUSBAR
LiveSetting：丁寧（1） 	ロール：ROLE_STATUSBAR

Object Attribute: container-live:polite
オブジェクト属性：container-live:polite

Object Attribute: live:polite
オブジェクト属性：live:polite

Object Attribute: container-live-role:status 	AXRole: AXGroup
オブジェクト属性：container-live-role:status 	AXRole：AXGroup

AXSubrole: AXApplicationStatus
AXSubrole：AXApplicationStatus

AXRoleDescription: 'application status'
AXRoleDescription：'application status'（アプリケーションステータス）


switch 	Role: ROLE_SYSTEM_CHECKBUTTON
スイッチ（switch） 	ロール：ROLE_SYSTEM_CHECKBUTTON

Role: IA2_ROLE_TOGGLE_BUTTON
ロール：IA2_ROLE_TOGGLE_BUTTON

Object Attribute: xml-roles:switch
オブジェクト属性：xml-roles:switch

See also: aria-checked in the State and Property Mapping Table 	Control Type: Button
参照：「状態とプロパティのマッピング表」でaria-checked 	コントロールタイプ：ボタン（Button）

Localized Control Type: toggleswitch
ローカライズされたコントロールタイプ：トグルスイッチ（toggleswitch）

Control Pattern: Toggle
コントロールパターン：トグル（Toggle）

See also: aria-checked in the State and Property Mapping Table 	Role: ROLE_TOGGLE_BUTTON
参照：「状態とプロパティのマッピング表」の aria-checked 	ロール：ROLE_TOGGLE_BUTTON

Object Attribute: xml-roles:switch
オブジェクト属性：xml-roles:switch

See also: aria-checked in the State and Property Mapping Table 	AXRole: AXCheckBox
参照：「状態とプロパティのマッピング表」の aria-checked 	AXRole：AXCheckBox

AXSubrole: AXSwitch
AXSubrole：AXSwitch

AXRoleDescription: 'switch'
AXRoleDescription：'switch'

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked 


tab 	Role: ROLE_SYSTEM_PAGETAB
タブ（tab） 	ロール：ROLE_SYSTEM_PAGETAB

State: STATE_SYSTEM_SELECTED if focus is inside tabpanel associated with aria-labelledby 	Control Type: TabItem 	Role: ROLE_PAGE_TAB
状態：STATE_SYSTEM_SELECTED（フォーカスが aria-labelledby に関連付けられたタブパネル内にある場合） 	コントロールタイプ：タブ項目（TabItem） 	ロール：ROLE_PAGE_TAB

State: STATE_SELECTED if focus is inside tabpanel associated with aria-labelledby 	AXRole: AXRadioButton
状態：STATE_SELECTED（フォーカスが aria-labelledby に関連付けられたタブパネル内にある場合） 	AXRole：AXRadioButton

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'tab'
AXRoleDescription：'tab'


table 	Role: ROLE_SYSTEM_TABLE
テーブル（table） 	ロール：ROLE_SYSTEM_TABLE

Object Attribute: xml-roles:table
オブジェクト属性：xml-roles:table

Interface: IAccessibleTable2 	Control Type: Table
インターフェイス：IAccessibleTable2 	コントロールタイプ：テーブル（Table）

Control Pattern: Grid
コントロールパターン：グリッド（Grid）

Control Pattern: Table 	Role: ROLE_TABLE
コントロールパターン：テーブル（Table） 	ロール：ROLE_TABLE

Object Attribute: xml-roles:table
オブジェクト属性：xml-roles:table

Interface: Table 	AXRole: AXTable
インターフェイス：Table 	AXRole：AXTable

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'table'
AXRoleDescription：'table'

AXColumnHeaderUIElements: a list of pointers to the columnheader elements
AXColumnHeaderUIElements：列ヘッダー要素へのポインターのリスト

AXHeader: a pointer to the row or group containing those columnheader elements
AXHeader：これらの列ヘッダー要素を含む行またはグループへのポインター

AXRowHeaderUIElements: a list of pointers to the rowheader elements
AXRowHeaderUIElements：行ヘッダー要素へのポインターのリスト 


tablist 	Role: ROLE_SYSTEM_PAGETABLIST
タブリスト（tablist） 	ロール：ROLE_SYSTEM_PAGETABLIST

Method: IAccessible::accSelect()
メソッド：IAccessible::accSelect()

Method: IAccessible::get_accSelection() 	Control Type: Tab
メソッド：IAccessible::get_accSelection() 	コントロールタイプ：タブ（Tab）

Control Pattern: Selection 	Role: ROLE_PAGE_TAB_LIST
コントロールパターン：選択（Selection） 	ロール：ROLE_PAGE_TAB_LIST

Interface: Selection
インターフェイス：Selection

Because WAI-ARIA does not support modifying the selection via the accessibility API, user agents MUST return false for all Selection methods that provide a means to modify the selection.
WAI-ARIA はアクセシビリティ API を介した選択の変更をサポートしていないため、ユーザーエージェントは選択を変更する手段を提供するすべての Selection のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXTabGroup
 	AXRole：AXTabGroup

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'tab group'
AXRoleDescription：'tab group'（タブグループ）


tabpanel 	Role: ROLE_SYSTEM_PANE or ROLE_SYSTEM_PROPERTYPAGE 	Control Type: Pane 	Role: ROLE_SCROLL_PANE 	AXRole: AXGroup
タブパネル（tabpanel） 	ロール：ROLE_SYSTEM_PANE または ROLE_SYSTEM_PROPERTYPAGE 	コントロールタイプ：ペイン（Pane） 	ロール：ROLE_SCROLL_PANE 	AXRole：AXGroup

AXSubrole: AXTabPanel
AXSubrole：AXTabPanel

AXRoleDescription: 'tab panel'
AXRoleDescription：'tab panel'（タブパネル）


term 	Role: IA2_ROLE_TEXT_FRAME
用語（term） 	ロール：IA2_ROLE_TEXT_FRAME

Object Attribute: xml-roles:term 	Control Type: Text
オブジェクト属性：xml-roles：term 	コントロールタイプ：テキスト（Text）

Localized Control Type: term 	Role: ROLE_DESCRIPTION_TERM 	AXRole: AXGroup
ローカライズされたコントロールタイプ：用語（term） 	ロール：ROLE_DESCRIPTION_TERM 	AXRole：AXGroup

AXSubrole: AXTerm
AXSubrole：AXTerm

AXRoleDescription: 'term'
AXRoleDescription：'term'


textbox when aria-multiline is false 	Role: ROLE_SYSTEM_TEXT
テキストボックス（textbox。 aria-multiline が false の場合） 	ロール：ROLE_SYSTEM_TEXT

State: IA2_STATE_SINGLE_LINE 	Control Type: Edit 	Role: ROLE_ENTRY
状態：IA2_STATE_SINGLE_LINE 	コントロールタイプ：編集（Edit） 	ロール：ROLE_ENTRY

State: STATE_SINGLE_LINE
状態：STATE_SINGLE_LINE

Interface: EditableText if aria-readonly is not "true" 	AXRole: AXTextField
インターフェイス：EditableText（aria-readonly が "true" でない場合） 	AXRole：AXTextField

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'text field'
AXRoleDescription：'text field'（テキストフィールド）


textbox when aria-multiline is true 	Role: ROLE_SYSTEM_TEXT
テキストボックス（textbox。 aria-multiline が true の場合） 	ロール：ROLE_SYSTEM_TEXT

State: IA2_STATE_MULTI_LINE 	Control Type: Edit 	Role: ROLE_ENTRY
状態：IA2_STATE_MULTI_LINE 	コントロールタイプ：編集（Edit） 	ロール：ROLE_ENTRY

State: STATE_MULTI_LINE
状態：STATE_MULTI_LINE

Interface: EditableText if aria-readonly is not "true" 	AXRole: AXTextArea
インターフェイス：EditableText（aria-readonly が "true" でない場合） 	AXRole：AXTextArea

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'text entry area'
AXRoleDescription：'text entry area'（テキスト入力領域）


timer 	Object Attribute: xml-roles:timer
タイマー（timer） 	オブジェクト属性：xml-roles:timer

Object Attribute: container-live:off
オブジェクト属性：container-live:off

Object Attribute: live:off
オブジェクト属性：live:off

Object Attribute: container-live-role:timer 	Control Type: Group
オブジェクト属性：container-live-role:timer 	コントロールタイプ：グループ（Group）

Localized Control Type: timer
ローカライズされたコントロールタイプ：タイマー（timer）

LiveSetting: Off (0) 	Role: ROLE_TIMER
LiveSetting：オフ（0） 	ロール：ROLE_TIMER

Object Attribute: container-live:off
オブジェクト属性：container-live:off

Object Attribute: live:off
オブジェクト属性：live:off

Object Attribute: container-live-role:timer 	AXRole: AXGroup
オブジェクト属性：container-live-role:timer 	AXRole：AXGroup

AXSubrole: AXApplicationTimer
AXSubrole：AXApplicationTimer

AXRoleDescription: 'timer'
AXRoleDescription：'timer'


toolbar 	Role: ROLE_SYSTEM_TOOLBAR 	Control Type: ToolBar 	Role: ROLE_TOOL_BAR 	AXRole: AXToolbar
ツールバー（toolbar） 	ロール：ROLE_SYSTEM_TOOLBAR 	コントロールタイプ：ツールバー（ToolBar） 	ロール：ROLE_TOOL_BAR 	AXRole：AXToolbar

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'toolbar'
AXRoleDescription：'toolbar'


tooltip 	Role: ROLE_SYSTEM_TOOLTIP 	Control Type: ToolTip 	Role: ROLE_TOOL_TIP 	AXRole: AXGroup
ツールチップ（tooltip） 	ロール：ROLE_SYSTEM_TOOLTIP 	コントロールタイプ：ツールチップ（ToolTip） 	ロール：ROLE_TOOL_TIP 	AXRole：AXGroup

AXSubrole: AXUserInterfaceTooltip
AXSubrole：AXUserInterfaceTooltip

AXRoleDescription: 'tooltip'
AXRoleDescription：'tooltip'


tree 	Role: ROLE_SYSTEM_OUTLINE
ツリー（tree） 	ロール：ROLE_SYSTEM_OUTLINE

Method: IAccessible::accSelect()
メソッド：IAccessible::accSelect()

Method: IAccessible::get_accSelection() 	Control Type: Tree 	Role: ROLE_TREE
メソッド：IAccessible::get_accSelection() 	コントロールタイプ：ツリー（Tree） 	ロール：ROLE_TREE

Interface: Selection
インターフェイス：Selection

Because WAI-ARIA does not support modifying the selection via the accessibility API, user agents MUST return false for all Selection methods that provide a means to modify the selection.
WAI-ARIA はアクセシビリティ API を介した選択の変更をサポートしていないため、ユーザーエージェントは選択を変更する手段を提供するすべての Selection のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXOutline
 	AXRole：AXOutline

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'outline'
AXRoleDescription：'outline'（アウトライン）


treegrid 	Role: ROLE_SYSTEM_OUTLINE
ツリーグリッド（treegrid） 	ロール：ROLE_SYSTEM_OUTLINE

Interface: IAccessibleTable2
インターフェイス：IAccessibleTable2

Method: IAccessible::accSelect()
メソッド：IAccessible::accSelect()

Method: IAccessible::get_accSelection() 	Control Type: DataGrid 	Role: ROLE_TREE_TABLE
メソッド：IAccessible::get_accSelection() 	コントロールタイプ：データグリッド（DataGrid） 	ロール：ROLE_TREE_TABLE

Interface: Table
インターフェイス：Table

Interface: Selection
インターフェイス：Selection

Because WAI-ARIA does not support modifying the selection via the accessibility API, user agents MUST return false for all Selection methods that provide a means to modify the selection.
WAI-ARIA はアクセシビリティ API を介した選択の変更をサポートしていないため、ユーザーエージェントは選択を変更する手段を提供するすべての Selection のメソッドに対して false を返す必要があります（MUST）。

	AXRole: AXTable
 	AXRole：AXTable

AXSubrole: <nil>
AXSubrole：<nil>

AXRoleDescription: 'table'
AXRoleDescription：'table'（テーブル）


treeitem 	Role: ROLE_SYSTEM_OUTLINEITEM
ツリー項目（treeitem） 	ロール：ROLE_SYSTEM_OUTLINEITEM

See also: aria-checked in the State and Property Mapping Table 	Control Type: TreeItem
参照：「状態とプロパティのマッピング表」の aria-checked 	コントロールタイプ：ツリー項目（TreeItem）

See also: aria-checked in the State and Property Mapping Table 	Role: ROLE_TREE_ITEM
参照：「状態とプロパティのマッピング表」の aria-checked 	ロール：ROLE_TREE_ITEM

See also: aria-checked in the State and Property Mapping Table 	AXRole: AXRow
参照：「状態とプロパティのマッピング表」の aria-checked 	AXRole：AXRow

AXSubrole: AXOutlineRow
AXSubrole：AXOutlineRow

AXRoleDescription: 'outline row'
AXRoleDescription：'outline row'（アウトライン行）

See also: aria-checked in the State and Property Mapping Table
参照：「状態とプロパティのマッピング表」の aria-checked 


Note
注

[Note 1] User agent should return a user-presentable, localized string value for the AXRoleDescription.
[注1] ユーザーエージェントは、AXRoleDescription に対して、ユーザーが提示できるローカライズされた文字列値を返す必要があります。

Note
注

[Note 2] This specification does not currently contain guidance for when user agents should fire system alert events. Some guidance may be added to the specification at a later date but it will be a recommendation (SHOULD), not a requirement (MUST).
[注2] 現在、この仕様には、ユーザーエージェントがシステムアラートイベントを発火させるタイミングに関するガイダンスは含まれていません。 一部のガイダンスは後日仕様に追加される可能性がありますが、それは推奨事項（SHOULD）であり、要件（MUST）ではありません。 




5.5 State and Property Mapping §
5.5 状態とプロパティのマッピング §

This section describes how to expose WAI-ARIA states and object properties.
このセクションでは、WAI-ARIA の状態とオブジェクトのプロパティを公開する方法について説明します。 




5.5.1 General rules §
5.5.1 一般規則 §

    User agents MUST compute managed states VISIBLE/INVISIBLE, SHOWING/OFFSCREEN, etc. This typically is done in the same way as for ordinary elements that do not have WAI-ARIA attributes present. The FOCUSABLE/FOCUSED states may be affected by aria-activedescendant. See the rules in Controlling focus with aria-activedescendant.
    ユーザーエージェントは、管理状態 VISIBLE / INVISIBLE、SHOWING / OFFSCREEN などを計算する必要があります（MUST）。 これは通常、WAI-ARIA 属性が存在しない通常の要素の場合と同じ方法で実行されます。 FOCUSABLE / FOCUSED 状態は、aria-activedescendant の影響を受ける可能性があります。 「aria-activedescendant によるフォーカスの制御」の規則を参照してください。

    User agents MUST continue to expose native semantics in addition to WAI-ARIA state and property semantics except where an explicit WAI-ARIA override is allowed by the host language. For example, an HTML checkbox may have an aria-labelledby attribute but the native HTML semantics must still be exposed.
    ユーザーエージェントは、ホスト言語で明示的な WAI-ARIA オーバーライドが許可されている場合を除き、WAI-ARIA の状態とプロパティの意味論に加えてネイティブな意味論を引き続き公開する必要があります（MUST）。 たとえば、HTML チェックボックスに aria-labelledby 属性が含まれている場合でも、ネイティブな HTML 意味論を公開する必要があります。

    User agents MUST expose additional states for certain roles as defined in the Role Mapping Table.
    ユーザーエージェントは、「ロールのマッピング表」で定義されているように、特定のロールの追加の状態を公開する必要があります（MUST）。

    User agents MUST compute states for the relevant WAI-ARIA attributes and map to the accessibility API as specified in the State and Property Mapping Table. To determine the relevant WAI-ARIA attributes, refer to the Definition of Roles [wai-aria-1.1]]. Where the author has not provided values for required attributes, user agents SHOULD process as if the default value was provided.
    ユーザーエージェントは、関連する WAI-ARIA 属性の状態を計算し、「状態とプロパティのマッピング表」で指定されているようにアクセシビリティ API にマップする必要があります（MUST）。 関連する WAI-ARIA 属性を決定するには、「ロールの定義 [wai-aria-1.1]」を参照してください。 作成者が必要な属性の値を提供していない場合、ユーザーエージェントはデフォルト値が提供されたかのように処理するべきです（SHOULD）。

    For forward compatibility with new WAI-ARIA properties in future versions, user agents SHOULD expose all properties not in the table below as a text string, removing the "aria-" prefix from the name, if the API supports it. For example, aria-foo="bar" would be exposed with a text string foo=bar in UIA, since aria-foo is not a currently known WAI-ARIA property. The following list specifies the accessibility APIs for exposing properties as text strings.
    将来のバージョンでの新しい WAI-ARIA プロパティとの上位互換性のために、ユーザーエージェントは、以下の表にないすべてのプロパティをテキスト文字列として公開し、API がサポートしている場合は、名前から "aria-" プレフィックスを削除するべきです（SHOULD）。 たとえば、aria-foo は現在既知の WAI-ARIA プロパティではないため、UIA では aria-foo="bar" はテキスト文字列 foo=bar で公開されます。 次のリストは、プロパティをテキスト文字列として公開するためのアクセシビリティ API を指定しています。

        MSAA: not supported
        MSAA：サポートされていません

        IAccessible2: expose as an object attribute pair ( property:string)
        IAccessible2：オブジェクト属性ペアとして公開（property:string）

        UIA: expose an object attribute pair in AriaProperties (property=string)
        UIA：AriaProperties (property=string) でオブジェクト属性ペアを公開します

        ATK/AT-SPI: expose as an object attribute pair (property:string)
        ATK / AT-SPI：オブジェクト属性ペアとして公開（property:string）

    Some WAI-ARIA properties are not global, and are only supported on certain roles. If a non-global WAI-ARIA state or property is used where it is not supported, user agents SHOULD NOT map the given WAI-ARIA property to the platform accessibility API. For example, if aria-checked="true" is specified on <div role="grid">, it should not be exposed in MSAA implementations as STATE_SYSTEM_CHECKED. User agents MAY expose non-relevant attributes as a text string if the API supports it as described above.
    一部の WAI-ARIA プロパティはグローバルではなく、特定のロールでのみサポートされます。 サポートされていない場所でグローバルでない WAI-ARIA の状態またはプロパティが使用されている場合、ユーザーエージェントは指定された WAI-ARIA プロパティをプラットフォームアクセシビリティ API にマップするべきではありません（SHOULD NOT）。 たとえば、aria-checked="true" が <div role="grid"> で指定されている場合、MSAA 実装では STATE_SYSTEM_CHECKED として公開しないでください。 API が上記のようにサポートしている場合、ユーザーエージェントは関連性のない属性をテキスト文字列として公開できます（MAY）。

    When an explicit or inherited role of none or presentation is applied to an element, the user agent MUST implement the rules for the none or the presentation role defined in Accessible Rich Internet Applications (WAI-ARIA) 1.0 [wai-aria-1.1]].
    なし（none）またはプレゼンテーション（presentation）の明示的または継承されたロールが要素に適用される場合、ユーザーエージェントは「アクセス可能でリッチなインターネットアプリケーション（WAI-ARIA）1.0 [wai-aria-1.1]」で定義された、なし（none）ロールまたはプレゼンテーション（presentation）ロールの規則を実装する必要があります（MUST）。





5.5.2 State and Property Mapping Table §
5.5.2 状態とプロパティのマッピング表 §




5.5.2.1 Not Mapped §
5.5.2.1 マップされていない §

There are a number of occurrences in the table where a given state or property is declared "Not mapped". In some cases, this occurs for the default value of the state/property, and is equivalent to its absence. User agents might find it quicker to map the value than check to see if it is the default. For computational efficiency, user agents MAY expose the state or property value if doing so is equivalent to not mapping it. These cases are marked with an asterisk.
表には、特定の状態またはプロパティが「マップされていない」と宣言されている箇所がいくつかあります。 場合によっては、これは状態やプロパティのデフォルト値で発生し、その欠如と同等です。 ユーザーエージェントは、値がデフォルトであるかどうかを確認するよりも、値をマップする方が速い場合があります。 計算効率のために、ユーザーエージェントは、状態またはプロパティの値を公開することがマップしないことと同等である場合、その値を公開できます（MAY）。 これらのケースにはアスタリスクが付いています。

In other cases, it is mandatory that the state/property not be mapped, since exposing it implies a related affordance. An example is aria-grabbed. Its absence not only indicates that the accessible object is not grabbed, but further defines it as not grab-able. These cases are marked as "Not mapped" without an asterisk.
その他の場合、状態やプロパティを公開することは関連するアフォーダンス（訳注：環境が動物に対して与える「意味」のこと）を意味するため、状態やプロパティをマッピングしないことが必須です。 例は aria-grabbed です。 その欠如は、アクセス可能なオブジェクトが取得されていないことを示すだけでなく、取得できないものとしてさらに定義します。 これらのケースは、アスタリスクなしで「マップされていない」としてマークされています。

Note
注

Translators: For label text associated with the following table and its toggle buttons, see the mappingTableLabels object in the <head> section of this document.
翻訳者：次の表とそのトグルボタンに関連付けられているラベルテキストについては、この文書の <head> セクションにある mappingTableLabels オブジェクトを参照してください。


WAI-ARIA state and property mapping rule table WAI-ARIA State or Property 	MSAA + IAccessible2 	UIA 	ATK/AT-SPI 	AX API
WAI-ARIA の状態およびプロパティのマッピング規則の表 	WAI-ARIA の状態またはプロパティ 	MSAA + IAccessible2 	UIA 	ATK / AT-SPI 	AX API


aria-activedescendant 	

See Controlling focus with aria-activedescendant, Handling focus changes from the Assistive Technology, and ID Reference Error Processing in Relations.
「aria-activedescendant によるフォーカスの制御」、「支援技術からのフォーカス変更の処理」、および「関係」の 「ID 参照エラー処理」を参照してください。

In cases, however, the focus can be transparent in an accessibility tree as it may be exposed as focus delegation from the container element to the child object that takes active focus. This is represented by an accessible object that comes with STATE_SYSTEM_FOCUSED state. When this happens, standard focus event and event handling should apply.
ただし、場合によっては、フォーカスは、コンテナ要素からアクティブなフォーカスを取得する子オブジェクトへのフォーカス委任として公開される可能性があるため、アクセシビリティツリーで透過的にすることができます。 これは、STATE_SYSTEM_FOCUSED 状態に付属するアクセス可能なオブジェクトによって表されます。これが発生した場合、標準のフォーカスイベントとイベント処理が適用されます。

	

See Controlling focus with aria-activedescendant, Handling focus changes from the Assistive Technology, and ID Reference Error Processing in Relations.
「aria-activedescendant によるフォーカスの制御」、「支援技術からのフォーカス変更の処理」、および「関係」の 「ID 参照エラー処理」を参照してください。

	

See Controlling focus with aria-activedescendant, Handling focus changes from the Assistive Technology, and ID Reference Error Processing in Relations.
「aria-activedescendant によるフォーカスの制御」、「支援技術からのフォーカス変更の処理」、および「関係」の 「ID 参照エラー処理」を参照してください。

In cases, however, the focus can be transparent in an accessibility tree as it may be exposed as focus delegation from the container element to the child object that takes active focus. This is represented by an accessible object that comes with STATE_FOCUSED state. When this happens, standard focus event and event handling should apply.
ただし、場合によっては、フォーカスは、コンテナ要素からアクティブなフォーカスを取得する子オブジェクトへのフォーカス委任として公開される可能性があるため、アクセシビリティツリーで透過的にすることができます。 これは、STATE_FOCUSED 状態に付属するアクセス可能なオブジェクトによって表されます。これが発生した場合、標準のフォーカスイベントとイベント処理が適用されます。

	Property: AXSelectedRows: pointer to active descendant node
	プロパティ：AXSelectedRows：アクティブな子孫ノードへのポインタ


aria-atomic=true 	Object Attribute: atomic:true
aria-atomic=true 	オブジェクト属性：atomic:true

Object Attribute: container-atomic:true
オブジェクト属性：container-atomic:true

Object Attribute: container-atomic:true on all descendants
オブジェクト属性：container-atomic:true（すべての子孫について）

Relation: IA2_RELATION_MEMBER_OF pointing to this element (the atomic root)
関係：この要素（アトミックルート）を指す IA2_RELATION_MEMBER_OF

See also: Changes to document content or node visibility 	Property: AriaProperties.atomic: true
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：AriaProperties.atomic：true

See also: Changes to document content or node visibility 	Object Attribute: atomic:true
参照：「文書コンテンツやノードの可視性の変更」 	オブジェクト属性：atomic:true

Object Attribute: container-atomic:true
オブジェクト属性：container-atomic:true

Object Attribute: container-atomic:true on all descendants
オブジェクト属性：container-atomic:true（すべての子孫について）

Relation: RELATION_MEMBER_OF pointing to this element (the atomic root)
関係：この要素（アトミックルート）を指す RELATION_MEMBER_OF

See also: Changes to document content or node visibility 	Property: AXARIAAtomic: YES
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：AXARIAAtomic：YES

See also: Changes to document content or node visibility
参照：「文書コンテンツやノードの可視性の変更」 


aria-atomic=false 	Not mapped* — OPTIONAL — but if mapped:
aria-atomic=false 	マップされていない* — 任意（OPTIONAL） — ただし、マップされている場合：

Object Attribute: atomic:false
オブジェクト属性：atomic:false

Object Attribute: container-atomic:false
オブジェクト属性：container-atomic:false

Object Attribute: container-atomic:false on all descendants
オブジェクト属性：container-atomic:false（すべての子孫について）

Relation: IA2_RELATION_MEMBER_OF pointing to this element (the atomic root)
関係：この要素（アトミックルート）を指す IA2_RELATION_MEMBER_OF

See also: Changes to document content or node visibility 	Property: AriaProperties.atomic: false
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：AriaProperties.atomic：false

See also: Changes to document content or node visibility 	Not mapped* — OPTIONAL — but if mapped:
参照：「文書コンテンツやノードの可視性の変更」 	マップされていない* — 任意（OPTIONAL） — ただし、マップされている場合：

Object Attribute: atomic:false on all descendants
オブジェクト属性：atomic:false（すべての子孫について）

Object Attribute: container-atomic:false
オブジェクト属性：container-atomic:false

Object Attribute: container-atomic:false on all descendants
オブジェクト属性：container-atomic:false（すべての子孫について）

Relation: RELATION_MEMBER_OF pointing to this element (the atomic root)
関係：この要素（アトミックルート）を指す RELATION_MEMBER_OF

See also: Changes to document content or node visibility 	Property: AXARIAAtomic: NO
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：AXARIAAtomic：NO

See also: Changes to document content or node visibility
参照：「文書コンテンツやノードの可視性の変更」 


aria-autocomplete=inline, list, or both 	Object Attribute: autocomplete:<value>
aria-autocomplete=inline、list、または both 	オブジェクト属性：autocomplete:<value>

State: IA2_STATE_SUPPORTS_AUTOCOMPLETION 	Not mapped 	Object Attribute: autocomplete:<value>
状態：IA2_STATE_SUPPORTS_AUTOCOMPLETION 	マップされていない 	オブジェクト属性：autocomplete:<value>

State: STATE_SUPPORTS_AUTOCOMPLETION 	Not mapped
状態：STATE_SUPPORTS_AUTOCOMPLETION 	マップされていない 


aria-autocomplete=none 	Not mapped* 	Not mapped* 	Not mapped* 	Not mapped*
aria-autocomplete=none 	マップされていない* 	マップされていない* 	マップされていない* 	マップされていない*


aria-busy=true 	State: STATE_SYSTEM_BUSY 	Property: AriaProperties.busy: true 	State: STATE_BUSY 	Property: AXElementBusy: YES
aria-busy=true 	状態：STATE_SYSTEM_BUSY 	プロパティ：AriaProperties.busy：true 	状態：STATE_BUSY 	プロパティ：AXElementBusy：YES


aria-busy=false 	State: STATE_SYSTEM_BUSY not exposed 	Property: AriaProperties.busy: false 	State: STATE_BUSY not exposed 	Property: AXElementBusy: NO
aria-busy=false 	状態：STATE_SYSTEM_BUSY が公開されていない 	プロパティ：AriaProperties.busy：false 	状態：STATE_BUSY が公開されていない 	プロパティ：AXElementBusy：NO


aria-checked=true 	State: STATE_SYSTEM_CHECKED
aria-checked=true 	状態：STATE_SYSTEM_CHECKED

Object Attribute: checkable:true 	Property: Toggle.ToggleState: On (1)
オブジェクト属性：checkable:true	プロパティ：Toggle.ToggleState：オン（1）

Property: SelectionItem.IsSelected: True for radio and menuitemradio 	State: STATE_CHECKABLE
プロパティ：SelectionItem.IsSelected：True（ラジオボタンおよびメニュー項目ラジオボタンの場合） 	状態：STATE_CHECKABLE

State: STATE_CHECKED 	Property: AXValue: 1
状態：STATE_CHECKED 	プロパティ：AXValue：1

Property: AXMenuItemMarkChar: ✓ for menuitemcheckbox and menuitemradio
プロパティ：AXMenuItemMarkChar：✓（メニュー項目チェックボックスおよびメニュー項目ラジオボタンの場合） 


aria-checked=false 	State: STATE_SYSTEM_CHECKED not exposed
aria-checked=false 	状態：STATE_SYSTEM_CHECKED が公開されていない

Object Attribute: checkable:true 	Property: Toggle.ToggleState: Off (0)
オブジェクト属性：checkable:true 	プロパティ：Toggle.ToggleState：オフ（0）

Property: SelectionItem.IsSelected: False for radio and menuitemradio 	State: STATE_CHECKABLE
プロパティ：SelectionItem.IsSelected：False（ラジオボタンおよびメニュー項目ラジオボタンの場合） 	状態：STATE_CHECKABLE

State: STATE_CHECKED not exposed 	Property: AXValue: 0
状態：STATE_CHECKED が公開されていない 	プロパティ：AXValue：0

Property: AXMenuItemMarkChar: <nil> for menuitemcheckbox and menuitemradio
プロパティ：AXMenuItemMarkChar：<nil>（メニュー項目チェックボックスおよびメニュー項目ラジオボタンの場合）


aria-checked=mixed 	State: STATE_SYSTEM_MIXED
aria-checked=mixed 	状態：STATE_SYSTEM_MIXED

Object Attribute: checkable:true 	Property: Toggle.ToggleState: Indeterminate (2) 	State: STATE_INDETERMINATE
オブジェクト属性：checkable:true 	プロパティ：Toggle.ToggleState：不確定（2） 	状態：STATE_INDETERMINATE

State: STATE_CHECKABLE
状態：STATE_CHECKABLE

State: STATE_CHECKED not exposed 	Property: AXValue: 2
状態：STATE_CHECKED が公開されていない 	プロパティ：AXValue：2

Property: AXMenuItemMarkChar: <nil> for menuitemcheckbox and menuitemradio
プロパティ：AXMenuItemMarkChar：<nil>（メニュー項目チェックボックスおよびメニュー項目ラジオボタンの場合）


aria-checked is undefined 	Not mapped 	Not mapped 	Not mapped 	Not mapped
aria-checked が未定義 	マップされていない 	マップされていない 	マップされていない 	マップされていない


aria-colcount 	Object Attribute: colcount:<value>
aria-colcount 	オブジェクト属性：colcount:<value>

Method: IAccessible2::groupPosition(): similarItemsInGroup=<value> on cells and headers 	Property: Grid.ColumnCount: <value> 
メソッド：IAccessible2::groupPosition()：similarItemsInGroup=<value>（セルとヘッダーについて） 	プロパティ：Grid.ColumnCount：<value>

	

If the value of aria-colcount is -1, calculate the column count based on the number of columns in the DOM and expose that value as described below along with STATE_INDETERMINATE.
aria-colcount の値が -1 の場合、DOM の列数に基づいて列数を計算し、STATE_INDETERMINATE とともに以下で説明するようにその値を公開します。

Object Attribute: colcount:<value>
オブジェクト属性：colcount:<value>

Method: atk_table_get_n_columns(): <value> 	Property: AXARIAColumnCount: <value>
メソッド：atk_table_get_n_columns()：<value> 	プロパティ：AXARIAColumnCount：<value> 


aria-colindex 	Object Attribute: colindex:<value>
aria-colindex 	オブジェクト属性：colindex:<value>

Method: IAccessible2::groupPosition(): positionInGroup=<value> on cells and headers 	Property: GridItem.Column: <value> (zero-based) 	Object Attribute: colindex:<value>
メソッド：IAccessible2::groupPosition()：positionInGroup=<value>（セルとヘッダーについて） 	プロパティ：GridItem.Column：<value>（ゼロベース） 	オブジェクト属性：colindex:<value>

Method: atk_table_cell_get_position(): column=<value> 	Property: AXARIAColumnIndex: <value>
メソッド：atk_table_cell_get_position()：column=<value> 	プロパティ：AXARIAColumnIndex：<value> 


aria-colspan 	Object Attribute: colspan:<value>
aria-colspan 	オブジェクト属性：colspan:<value>

Method: IAccessibleTableCell::columnExtent(): <value> 	Property: GridItem.ColumnSpan: <value> 	Object Attribute: colspan:<value>
メソッド：IAccessibleTableCell::columnExtent()：<value> 	プロパティ：GridItem.ColumnSpan：<value> 	オブジェクト属性：colspan:<value>

Method: atk_table_cell_get_row_column_span(): column_span=<value> 	Property: AXColumnIndexRange.length: <value>
メソッド：atk_table_cell_get_row_column_span()：column_span=<value> 	プロパティ：AXColumnIndexRange.length：<value> 


aria-controls 	Relation: IA2_RELATION_CONTROLLER_FOR points to accessible nodes matching IDREFs
aria-controls 	関係：IA2_RELATION_CONTROLLER_FOR は、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: IA2_RELATION_CONTROLLED_BY points to element
逆の関係：IA2_RELATION_CONTROLLED_BY は要素を指します

See also: Mapping Additional Relations 	Property: ControllerFor: pointers to accessible nodes matching IDREFs 	Relation: RELATION_CONTROLLER_FOR points to accessible nodes matching IDREFs
参照：追加の「関係」のマッピング 	プロパティ：ControllerFor：IDREF に一致するアクセス可能なノードへのポインター 	関係：RELATION_CONTROLLER_FOR は、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: RELATION_CONTROLLED_BY points to element
逆の関係：RELATION_CONTROLLED_BY は要素を指します

See also: Mapping Additional Relations 	Property: AXLinkedUIElements: pointers to accessible nodes matching IDREFs
参照：追加の「関係」のマッピング 	プロパティ：AXLinkedUIElements：IDREF に一致するアクセス可能なノードへのポインター 


aria-current with non-false allowed value 	Object Attribute: current:<value> 	Property: AriaProperties.current: <value> 	Object Attribute: current:<value>
aria-current（false 以外の許可された値を持つ） 	オブジェクト属性：current:<value> 	プロパティ：AriaProperties.current：<value> 	オブジェクト属性：current:<value>

State: STATE_ACTIVE 	Property: AXARIACurrent: <value>
状態：STATE_ACTIVE 	プロパティ：AXARIACurrent：<value>


aria-current with unrecognized value 	Object Attribute: current:true 	Property: AriaProperties.current: true 	Object Attribute: current:true
aria-current（認識されない値を持つ） 	オブジェクト属性：current:true 	プロパティ：AriaProperties.current：true 	オブジェクト属性：current:true

State: STATE_ACTIVE 	Property: AXARIACurrent: true
状態：STATE_ACTIVE 	プロパティ：AXARIACurrent：true 


aria-current is false or undefined 	Not mapped* 	Not mapped* 	Not mapped* 	Not mapped*
aria-current（false または未定義） 	マップされていない* 	マップされていない* 	マップされていない* 	マップされていない*


aria-describedby 	Property: accDescription: <value>
aria-describeby 	プロパティ：accDescription：<value>

Relation: IA2_RELATION_DESCRIBED_BY points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
関係：IA2_RELATION_DESCRIBED_BY は、参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: IA2_RELATION_DESCRIPTION_FOR points to element
逆の関係：IA2_RELATION_DESCRIPTION_FOR は要素を指します

See also: Name Computation and Mapping Additional Relations 	Property: FullDescription: <value>
参照：「名前」の計算と追加の「関係」のマッピング 	プロパティ：FullDescription：<value>

Property: DescribedBy: points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
プロパティ：DescribedBy：参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します

See also: Name Computation 	Property: Description: <value>
参照：「名前」の計算 	プロパティ：Description：<value>

Relation: RELATION_DESCRIBED_BY points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
関係：参照されるオブジェクトがアクセシビリティツリーにある場合、RELATION_DESCRIBED_BY は IDREF に一致するアクセス可能なノードを指します

Reverse Relation: RELATION_DESCRIPTION_FOR points to element
逆の関係：RELATION_DESCRIPTION_FOR は要素を指します

See also: Name Computation and Mapping Additional Relations 	Property: AXHelp: <value>
参照：「名前」の計算と追加の「関係」のマッピング 	プロパティ：AXHelp：<value>

See also: Name Computation
参照：「名前」の計算 


aria-details 	Relation: IA2_RELATION_DETAILS points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
aria-details 	関係：参照されるオブジェクトがアクセシビリティツリーにある場合、IA2_RELATION_DETAILS は IDREF に一致するアクセス可能なノードを指します

Reverse Relation: IA2_RELATION_DETAILS_FOR points to element
逆の関係：IA2_RELATION_DETAILS_FOR は要素を指します

See also: Mapping Additional Relations 	Property: DescribedBy: points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree 	Relation: RELATION_DETAILS points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
参照：追加の「関係」のマッピング 	プロパティ：DescribedBy：参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します 	関係：RELATION_DETAILS は、参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: RELATION_DETAILS_FOR points to element
逆の関係：RELATION_DETAILS_FOR は要素を指します

See also: Mapping Additional Relations 	Not mapped*
参照：追加の「関係」のマッピング 	マップされていない*


aria-disabled=true 	State: STATE_SYSTEM_UNAVAILABLE
aria-disabled=true 	状態：STATE_SYSTEM_UNAVAILABLE

State: STATE_SYSTEM_UNAVAILABLE on all descendants with STATE_SYSTEM_FOCUSABLE 	Property: IsEnabled: false 	State: STATE_ENABLED not exposed 	Property: AXEnabled: NO
状態：STATE_SYSTEM_UNAVAILABLE（STATE_SYSTEM_FOCUSABLE を持つすべての子孫について） 	プロパティ：IsEnabled：false 	状態：STATE_ENABLED が公開されていない 	プロパティ：AXEnabled：NO 


aria-disabled=false 	State: STATE_SYSTEM_UNAVAILABLE not exposed 	Property: IsEnabled: true 	State: STATE_ENABLED 	Property: AXEnabled: YES
aria-disabled=false 	状態：STATE_SYSTEM_UNAVAILABLE が公開されていない 	プロパティ：IsEnabled：true 	状態：STATE_ENABLED 	プロパティ：AXEnabled：YES


aria-dropeffect=copy, move, link, execute, or popup 	Object Attribute: dropeffect:<value> 	Property: AriaProperties.dropeffect: <value> 	Object Attribute: dropeffect:<value> 	array AXDropEffects
aria-dropeffect=copy、move、link、execute、または popup 	オブジェクト属性：dropeffect:<value> 	プロパティ：AriaProperties.dropeffect：<value> 	オブジェクト属性：dropeffect:<value> 	array AXDropEffects


aria-dropeffect=none 	Object Attribute: dropeffect:none if there are no other valid tokens
aria-dropeffect=none 	オブジェクト属性：dropeffect:none（他に有効なトークンがない場合）

Not mapped if not specified by the author 	Not mapped* 	Object Attribute: dropeffect:none if there are no other valid tokens
マップされていない（作成者によって指定されていない場合） 	マップされていない* 	オブジェクト属性：dropeffect:none（他に有効なトークンがない場合）

Not mapped if not specified by the author 	Not mapped*
マップされていない（作成者によって指定されていない場合） 	マップされていない* 


aria-errormessage 	Relation: IA2_RELATION_ERROR points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
aria-errormessage 	関係：参照されたオブジェクトがアクセシビリティツリーにある場合、IA2_RELATION_ERROR は IDREF に一致するアクセス可能なノードを指します

Reverse Relation: IA2_RELATION_ERROR_FOR points to element
逆の関係：IA2_RELATION_ERROR_FOR は要素を指します

See also: Mapping Additional Relations 	Property: ControllerFor: pointer to the target accessible object 	Relation: RELATION_ERROR_MESSAGE points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
参照：追加の「関係」のマッピング 	プロパティ：ControllerFor：対象のアクセス可能なオブジェクトへのポインター 	関係：RELATION_ERROR_MESSAGE は、参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: RELATION_ERROR_FOR points to element
逆の関係：RELATION_ERROR_FOR は要素を指します

See also: Mapping Additional Relations 	Property: AXValidationError: textual content of the referenced element
参照：追加の「関係」のマッピング 	プロパティ：AXValidationError：参照される要素のテキストコンテンツ 


aria-expanded=true 	State: STATE_SYSTEM_EXPANDED 	Property: ExpandCollapse.ExpandCollapseState: Expanded 	State: STATE_EXPANDABLE
aria-expanded=true 	状態：STATE_SYSTEM_EXPANDED 	プロパティ：ExpandCollapse.ExpandCollapseState：拡張 	状態：STATE_EXPANDABLE
 	
State: STATE_EXPANDED 	Property: AXExpanded: YES
状態：STATE_EXPANDED 	プロパティ：AXExpanded：YES 


aria-expanded=false 	State: STATE_SYSTEM_COLLAPSED 	Property: ExpandCollapse.ExpandCollapseState: Collapsed 	State: STATE_EXPANDABLE
aria-expanded=false 	状態：STATE_SYSTEM_COLLAPSED 	プロパティ：ExpandCollapse.ExpandCollapseState：折りたたまれた 	状態：STATE_EXPANDABLE

State: STATE_EXPANDED not exposed 	Property: AXExpanded: NO
状態：STATE_EXPANDED が公開されていない 	プロパティ：AXExpanded：NO 


aria-expanded is undefined 	Not mapped 	Not mapped 	Not mapped 	Not mapped
aria-expanded が未定義 	マップされていない 	マップされていない 	マップされていない 	マップされていない


aria-flowto 	Relation: IA2_RELATION_FLOW_TO points to accessible nodes matching IDREFs
aria-flowto 	関係：IA2_RELATION_FLOW_TO は、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: IA2_RELATION_FLOW_FROM points to element
逆の関係：IA2_RELATION_FLOW_FROM は要素を指します

See also: Mapping Additional Relations 	Property: FlowsTo: pointers to accessible nodes matching IDREFs 	Relation: RELATION_FLOWS_TO points to accessible nodes matching IDREFs
参照：追加の「関係」のマッピング 	プロパティ：FlowsTo：IDREF に一致するアクセス可能なノードへのポインター 	関係：RELATION_FLOWS_TO は、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: RELATION_FLOWS_FROM points to element
逆の関係：RELATION_FLOWS_FROM は要素を指します

See also: Mapping Additional Relations 	Property: AXLinkedUIElements: pointers to accessible nodes matching IDREFs
参照：追加の「関係」のマッピング 	プロパティ：AXLinkedUIElements：IDREF に一致するアクセス可能なノードへのポインター 


aria-grabbed=true 	Object Attribute: grabbed:true 	Property: AriaProperties.grabbed: true 	Object Attribute: grabbed:true 	Property: AXGrabbed: YES
aria-grabbed=true 	オブジェクト属性：grabbed:true 	プロパティ：AriaProperties.grabbed：true 	オブジェクト属性：grabbed:true 	プロパティ：AXGrabbed：YES


aria-grabbed=false 	Object Attribute: grabbed:false 	Property: AriaProperties.grabbed: false 	Object Attribute: grabbed:false 	Property: AXGrabbed: NO
aria-grabbed=false 	オブジェクト属性：grabbed:false 	プロパティ：AriaProperties.grabbed：false 	オブジェクト属性：grabbed:false 	プロパティ：AXGrabbed：NO


aria-grabbed is undefined 	Not mapped 	Not mapped 	Not mapped 	Not mapped
aria-grabbed が未定義 	マップされていない 	マップされていない 	マップされていない 	マップされていない


aria-haspopup=true 	State: STATE_SYSTEM_HASPOPUP
aria-haspopup=true 	状態：STATE_SYSTEM_HASPOPUP

Object Attribute: haspopup:true 	Control Pattern: ExpandCollapse See also: aria-expanded 	State: STATE_HAS_POPUP
オブジェクト属性：haspopup:true 	コントロールパターン：ExpandCollapse 参照：aria-expanded 	状態：STATE_HAS_POPUP

Object Attribute: haspopup:true 	Property: Action: AXShowMenu
オブジェクト属性：haspopup:true 	プロパティ：Action：AXShowMenu 


aria-haspopup=false 	State: STATE_SYSTEM_HASPOPUP not exposed
aria-haspopup=false 	状態：STATE_SYSTEM_HASPOPUP が公開されていない

Object Attribute: haspopup:false 	Not mapped* 	Not mapped* 	Not mapped*
オブジェクト属性：haspopup:false 	マップされていない* 	マップされていない* 	マップされていない*


aria-haspopup=dialog 	State: STATE_SYSTEM_HASPOPUP
aria-haspopup=dialog 	状態：STATE_SYSTEM_HASPOPUP

Object Attribute: haspopup:dialog 	Control Pattern: ExpandCollapse
オブジェクト属性：haspopup:dialog 	コントロールパターン：ExpandCollapse

See also: aria-expanded 	State: STATE_HAS_POPUP
参照：aria-expanded 	状態：STATE_HAS_POPUP

Object Attribute: haspopup:dialog 	Action: AXShowMenu
オブジェクト属性：haspopup:dialog 	Action：AXShowMenu 


aria-haspopup=listbox 	State: STATE_SYSTEM_HASPOPUP
aria-haspopup=listbox 	状態：STATE_SYSTEM_HASPOPUP

Object Attribute: haspopup:listbox 	Control Pattern: ExpandCollapse
オブジェクト属性：haspopup:listbox 	コントロールパターン：ExpandCollapse

See also: aria-expanded 	State: STATE_HAS_POPUP
参照：aria-expanded 	状態：STATE_HAS_POPUP

Object Attribute: haspopup:listbox 	Action: AXShowMenu
オブジェクト属性：haspopup:listbox 	Action：AXShowMenu 


aria-haspopup=menu 	State: STATE_SYSTEM_HASPOPUP
aria-haspopup=menu 	状態：STATE_SYSTEM_HASPOPUP

Object Attribute: haspopup:menu 	Control Pattern: ExpandCollapse
オブジェクト属性：haspopup:menu 	コントロールパターン：ExpandCollapse

See also: aria-expanded 	State: STATE_HAS_POPUP
参照：aria-expanded 	状態：STATE_HAS_POPUP

Object Attribute: haspopup:menu 	Action: AXShowMenu
オブジェクト属性：haspopup:menu 	Action：AXShowMenu 


aria-haspopup=tree 	State: STATE_SYSTEM_HASPOPUP
aria-haspopup=tree 	状態：STATE_SYSTEM_HASPOPUP

Object Attribute: haspopup:tree 	Control Pattern: ExpandCollapse
オブジェクト属性：haspopup:tree 	コントロールパターン：ExpandCollapse

See also: aria-expanded 	State: STATE_HAS_POPUP
参照：aria-expanded 	状態：STATE_HAS_POPUP

Object Attribute: haspopup:tree 	Action: AXShowMenu
オブジェクト属性：haspopup:tree 	Action：AXShowMenu 


aria-hidden=true on unfocused element 	Element SHOULD NOT be exposed
aria-hidden=true（フォーカスされていない要素について） 	要素は公開されるべきではありません（SHOULD NOT）

See also: Including Elements in the Accessibility Tree 	Element SHOULD NOT be exposed
参照：「アクセシビリティツリーに要素を含める」 	要素は公開されるべきではありません（SHOULD NOT）

See also: Including Elements in the Accessibility Tree 	Element SHOULD NOT be exposed
参照：「アクセシビリティツリーに要素を含める」 	要素は公開されるべきではありません（SHOULD NOT）

See also: Including Elements in the Accessibility Tree 	Element SHOULD NOT be exposed
参照：「アクセシビリティツリーに要素を含める」 	要素は公開されるべきではありません（SHOULD NOT）

See also: Including Elements in the Accessibility Tree
参照：「アクセシビリティツリーに要素を含める」 


aria-hidden=true when element is focused or fires an accessibility event 	Object Attribute: hidden:true
aria-hidden=true（要素がフォーカスされたとき、またはアクセシビリティイベントを発火させたとき） 	オブジェクト属性：hidden:true

See also: Including Elements in the Accessibility Tree 	Property: AriaProperties.hidden: true
参照：「アクセシビリティツリーに要素を含める」 	プロパティ：AriaProperties.hidden：true

See also: Including Elements in the Accessibility Tree 	Object Attribute: hidden:true
参照：「アクセシビリティツリーに要素を含める」 	オブジェクト属性：hidden:true

See also: Including Elements in the Accessibility Tree 	Not mapped
参照：「アクセシビリティツリーに要素を含める」 	マップされていない

See also: Including Elements in the Accessibility Tree
参照：「アクセシビリティツリーに要素を含める」 


aria-hidden=false 	Not mapped 	Not mapped 	Not mapped 	Not mapped
aria-hidden=false 	マップされていない 	マップされていない 	マップされていない 	マップされていない


aria-invalid=true 	State: IA2_STATE_INVALID_ENTRY
aria-invalid=true 	状態：IA2_STATE_INVALID_ENTRY

Text Attribute: invalid:true 	Property: IsDataValidForForm: false 	State: STATE_INVALID_ENTRY
テキスト属性：invalid:true 	プロパティ：IsDataValidForForm：false 	状態：STATE_INVALID_ENTRY

Text Attribute: invalid:true 	Property: AXInvalid: true
テキスト属性：invalid:true 	プロパティ：AXInvalid：true 


aria-invalid=false 	State: IA2_STATE_INVALID_ENTRY not exposed 	Property: IsDataValidForForm: true 	State: STATE_INVALID_ENTRY not exposed 	Property: AXInvalid: false
aria-invalid=false 	状態：IA2_STATE_INVALID_ENTRY が公開されていない 	プロパティ：IsDataValidForForm：true 	状態：STATE_INVALID_ENTRY が公開されていない 	プロパティ：AXInvalid：false


aria-invalid=spelling or grammar 	State: IA2_STATE_INVALID_ENTRY
aria-invalid=spelling または grammar 	状態：IA2_STATE_INVALID_ENTRY

Text Attribute: invalid:<value> 	Property: IsDataValidForForm: <value> 	State: STATE_INVALID_ENTRY
テキスト属性：invalid:<value> 	プロパティ：IsDataValidForForm：<value> 	状態：STATE_INVALID_ENTRY

Text Attribute: invalid:<value> 	Property: AXInvalid: <value>
テキスト属性：invalid:<value> 	プロパティ：AXInvalid：<value> 


aria-invalid with unrecognized value 	State: IA2_STATE_INVALID_ENTRY
aria-invalid（認識されない値） 	状態：IA2_STATE_INVALID_ENTRY

Text Attribute: invalid:true 	Property: IsDataValidForForm: false 	State: STATE_INVALID_ENTRY
テキスト属性：invalid:true 	プロパティ：IsDataValidForForm：false 	状態：STATE_INVALID_ENTRY

Text Attribute: invalid:true 	Property: AXInvalid: true
テキスト属性：invalid:true 	プロパティ：AXInvalid：true


aria-keyshortcuts 	Property: accKeyboardShortcut: <value> 	Property: AcceleratorKey: <value> 	Object Attribute: keyshortcuts:<value> 	Not mapped*
aria-keyshortcuts 	プロパティ：accKeyboardShortcut：<value> 	プロパティ：AcceleratorKey：<value> 	オブジェクト属性：keyshortcuts:<value> 	マップされていない* 


aria-label 	Property: accName: <value>
aria-label 	プロパティ：accName：<value>

See also: Name Computation 	Property: Name: <value>
参照：「名前」の計算 	プロパティ：Name：<value>

See also: Name Computation 	Property: Name: <value>
参照：「名前」の計算 	プロパティ：Name：<value>

See also: Name Computation 	Property: AXDescription: <value>
参照：「名前」の計算 	プロパティ：AXDescription：<value>

See also: Name Computation
参照：「名前」の計算 


aria-labelledby 	Property: accName: <value>
aria-labelledby 	プロパティ：accName：<value>

Relation: IA2_RELATION_LABELLED_BY points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
関係：IA2_RELATION_LABELLED_BY は、参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: IA2_RELATION_LABEL_FOR points to element
逆の関係：IA2_RELATION_LABEL_FOR は要素を指します

See also: Name Computation and Mapping Additional Relations 	Property: Name: <value>
参照：「名前」の計算と追加の「関係」のマッピング 	プロパティ：Name：<value>

Property: LabeledBy: points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
プロパティ：LabeledBy：参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します

See also: Name Computation 	Property: Name: <value>
参照：「名前」の計算 	プロパティ：Name：<value>

Relation: RELATION_LABELLED_BY points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
関係：RELATION_LABELLED_BY は、参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します

Reverse Relation: RELATION_LABEL_FOR points to element
逆の関係：RELATION_LABEL_FOR は要素を指します

See also: Name Computation and Mapping Additional Relations 	Property: AXDescription: <value>
参照：「名前」の計算と追加の「関係」のマッピング 	プロパティ：AXDescription：<value>

Property: AXTitleUIElement: points to accessible node matching IDREF, if there is a single referenced element that is in the accessibility tree
プロパティ：AXTitleUIElement：アクセシビリティツリーに単一の参照要素がある場合、IDREF に一致するアクセス可能なノードを指します

See also: Name Computation
参照：「名前」の計算 


aria-level on non-heading 	Object Attribute: level:<value>
aria-level（見出し以外について） 	オブジェクト属性：level:<value>

Method: IAccessible2::groupPosition(): groupLevel=<value> on roles that support aria-posinset and aria-setsize
メソッド：IAccessible2::groupPosition()：groupLevel=<value>（aria-posinset および aria-setsize をサポートするロールについて）

See also: groupPosition() 	Property: AriaProperties.level: <value> 	Object Attribute: level:<value> 	Property: AXDisclosureLevel: <value> (zero-based), when used on an outline row (like a treeitem or group)
参照：groupPosition() 	プロパティ：AriaProperties.level：<value> 	オブジェクト属性：level:<value> 	プロパティ：AXDisclosureLevel：<value>（ゼロベース。 アウトライン行（ツリー項目やグループなど）で使用する場合） 


aria-level on heading 	Object Attribute: level:<value> 	Property: AriaProperties.level: <value>
aria-level（見出しについて） 	オブジェクト属性：level:<value> 	プロパティ：AriaProperties.level：<value>

Property: StyleId_Heading: <value> 	Object Attribute: level:<value> 	Property: AXValue: <value>
プロパティ：StyleId_Heading：<value> 	オブジェクト属性：level:<value> 	プロパティ：AXValue：<value>> 


aria-live=assertive 	Object Attribute: live:assertive
aria-live=assertive 	オブジェクト属性：live:assertive

Object Attribute: container-live:assertive
オブジェクト属性：container-live:assertive

Object Attribute: container-live:assertive on all descendants
オブジェクト属性：container-live:assertive（すべての子孫について）

See also: Changes to document content or node visibility 	Property: LiveSetting: "assertive"
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：LiveSetting："assertive"

See also: Changes to document content or node visibility 	Object Attribute: live:assertive
参照：「文書コンテンツやノードの可視性の変更」 	オブジェクト属性：live:assertive

Object Attribute: container-live:assertive
オブジェクト属性：container-live:assertive

Object Attribute: container-live:assertive on all descendants
オブジェクト属性：container-live:assertive（すべての子孫について）

See also: Changes to document content or node visibility 	Property: AXARIALive: "assertive"
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：AXARIALive："assertive"

See also: Changes to document content or node visibility
参照：「文書コンテンツやノードの可視性の変更」 


aria-live=polite 	Object Attribute: live:polite
aria-live=polite 	オブジェクト属性：live:polite

Object Attribute: container-live:polite
オブジェクト属性：container-live:polite

Object Attribute: container-live:polite on all descendants
オブジェクト属性：container-live:polite（すべての子孫について）

See also: Changes to document content or node visibility 	Property: LiveSetting: "polite"
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：LiveSetting："polite"

See also: Changes to document content or node visibility 	Object Attribute: live:polite
参照：「文書コンテンツやノードの可視性の変更」 	オブジェクト属性：live:polite

Object Attribute: container-live:polite
オブジェクト属性：container-live:polite

Object Attribute: container-live:polite on all descendants
オブジェクト属性：container-live:polite（すべての子孫について）

See also: Changes to document content or node visibility 	Property: AXARIALive: "polite"
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：AXARIALive："polite"

See also: Changes to document content or node visibility
参照：「文書コンテンツやノードの可視性の変更」 


aria-live=off 	Object Attribute: live:off
aria-live=off 	オブジェクト属性：live:off

Object Attribute: container-live:off
オブジェクト属性：container-live:off

Object Attribute: container-live:off on all descendants 	Property: LiveSetting: "off" 	Object Attribute: live:off
オブジェクト属性：container-live:off（すべての子孫について） 	プロパティ：LiveSetting："off" 	オブジェクト属性：live:off

Object Attribute: container-live:off
オブジェクト属性：container-live:off

Object Attribute: container-live:off on all descendants
オブジェクト属性：container-live:off（すべての子孫について）

	Property: AXARIALive: "off"
 	プロパティ：AXARIALive："off" 


aria-modal=true 	State: IA2_STATE_MODAL 	Property: Window.IsModal: true
aria-modal=true 	状態：IA2_STATE_MODAL 	プロパティ：Window.IsModal：true

	State: STATE_MODAL 	Prune the accessibility tree such that the background content is no longer exposed. No specific property is set on the accessible object that corresponds to the element with aria-modal="true". Only the tree whose root is that modal accessible object is exposed.
 	状態：STATE_MODAL 	背景コンテンツが公開されないように、アクセシビリティツリーを刈り込みます。 aria-modal="true" の要素に対応するアクセス可能なオブジェクトに特定のプロパティは設定されていません。 そのモーダルでアクセス可能なオブジェクトをルートとするツリーのみが公開されます。 


aria-modal=false 	State: IA2_STATE_MODAL not exposed 	Property: Window.IsModal: false
aria-modal=false 	状態：IA2_STATE_MODAL が公開されていない 	プロパティ：Window.IsModal：false

	State: STATE_MODAL not exposed 	Grow the accessibility tree such that the background content is exposed. No specific property is set on the accessible object that corresponds to the element with aria-modal="false".
 	状態：STATE_MODAL が公開されていない 	背景コンテンツが公開されるように、アクセシビリティツリーを成長させます。 aria-modal="false" の要素に対応するアクセス可能なオブジェクトに特定のプロパティは設定されていません。 


aria-multiline=true 	State: IA2_STATE_MULTI_LINE
aria-multiline=true 	状態：IA2_STATE_MULTI_LINE

State: IA2_STATE_SINGLE_LINE not exposed 	Property: AriaProperties.multiline: true 	State: STATE_MULTI_LINE
状態：IA2_STATE_SINGLE_LINE が公開されていない 	プロパティ：AriaProperties.multiline：true 	状態：STATE_MULTI_LINE

State: STATE_SINGLE_LINE not exposed 	Not mapped
状態：STATE_SINGLE_LINE が公開されていない 	マップされていない

See also: textbox in the Role Mapping Table
参照：「ロールのマッピング表」のテキストボックス 


aria-multiline=false 	State: IA2_STATE_SINGLE_LINE
aria-multiline=false 	状態：IA2_STATE_SINGLE_LINE

State: IA2_STATE_MULTI_LINE not exposed 	Not mapped* 	State: STATE_SINGLE_LINE
状態：IA2_STATE_MULTI_LINE が公開されていない 	マップされていない* 	状態：STATE_SINGLE_LINE

State: STATE_MULTI_LINE not exposed 	Not mapped
状態：STATE_MULTI_LINE が公開されていない 	マップされていない

See also: textbox in the Role Mapping Table
参照：「ロールのマッピング表」のテキストボックス 


aria-multiselectable=true 	State: STATE_SYSTEM_MULTISELECTABLE
aria-multiselectable=true 	状態：STATE_SYSTEM_MULTISELECTABLE

State: STATE_SYSTEM_EXTSELECTABLE
状態：STATE_SYSTEM_EXTSELECTABLE

See also: Selection for details on accessibility events 	Property: Selection.CanSelectMultiple: true
参照：アクセシビリティイベントの詳細については、「選択」 	プロパティ：Selection.CanSelectMultiple：true

See also: Selection for details on accessibility events 	State: STATE_MULTISELECTABLE
参照：アクセシビリティイベントの詳細については、「選択」 	状態：STATE_MULTISELECTABLE

See also: Selection for details on accessibility events 	Not mapped*
参照：アクセシビリティイベントの詳細については、「選択」 	マップされていない*

See also: Selection for details on accessibility events
参照：アクセシビリティイベントの詳細については、「選択」 


aria-multiselectable=false 	State: STATE_SYSTEM_MULTISELECTABLE not exposed
aria-multiselectable=false 	状態：STATE_SYSTEM_MULTISELECTABLE が公開されていない

State: STATE_SYSTEM_EXTSELECTABLE not exposed
状態：STATE_SYSTEM_EXTSELECTABLE が公開されていない

See also: Selection for details on accessibility events 	Not mapped* 	State: STATE_MULTISELECTABLE not exposed 	Not mapped*
参照：アクセシビリティイベントの詳細については、「選択」 	マップされていない* 	状態：STATE_MULTISELECTABLE が公開されていない 	マップされていない* 


aria-orientation=horizontal 	State: IA2_STATE_HORIZONTAL
aria-orientation=horizontal 	状態：IA2_STATE_HORIZONTAL

State: IA2_STATE_VERTICAL not exposed 	Property: Orientation: horizontal 	State: STATE_HORIZONTAL
状態：IA2_STATE_VERTICAL が公開されていない 	プロパティ：Orientation：horizontal 	状態：STATE_HORIZONTAL

State: STATE_VERTICAL not exposed 	Property: AXOrientation: AXHorizontalOrientation
状態：STATE_VERTICAL が公開されていない 	プロパティ：AXOrientation：AXHorizontalOrientation 


aria-orientation=vertical 	State: IA2_STATE_VERTICAL
aria-orientation=vertical 	State：IA2_STATE_VERTICAL

State: IA2_STATE_HORIZONTAL not exposed 	Property: Orientation: vertical 	State: STATE_VERTICAL
状態：IA2_STATE_HORIZONTAL が公開されていない 	プロパティ：Orientation：vertical 	状態：STATE_VERTICAL

State: STATE_HORIZONTAL not exposed 	Property: AXOrientation: AXVerticalOrientation
状態：STATE_HORIZONTAL が公開されていない 	プロパティ：AXOrientation：AXVerticalOrientation 


aria-orientation is undefined 	Not mapped* 	Not mapped* 	State: STATE_VERTICAL not exposed
aria-orientation が未定義 	マップされていない* 	マップされていない* 	状態：STATE_VERTICAL が公開されていない

State: STATE_HORIZONTAL not exposed 	Property: AXOrientation: AXUnknownOrientation
状態：STATE_HORIZONTAL が公開されていない 	プロパティ：AXOrientation：AXUnknownOrientation 


aria-owns 	

User agents MAY expose the elements that are referenced by this property as children of the current element. In which case, if multiple aria-owns relationships are found, use only the first one. If the accessibility tree is not modified, expose as:
ユーザーエージェントは、このプロパティによって参照される要素を現在の要素の子として公開できます（MAY）。 その場合、複数の aria-owns 関係性が見つかった場合は、最初の関係のみを使用してください。 アクセシビリティツリーが変更されていない場合は、次のように公開します。

Relation: IA2_RELATION_NODE_PARENT_OF points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
関係：IA2_RELATION_NODE_PARENT_OF は、参照されるオブジェクトがアクセシビリティツリーにある場合、IDREF に一致するアクセス可能なノードを指します。

Reverse Relation: IA2_RELATION_NODE_CHILD_OF points to element
逆の関係：IA2_RELATION_NODE_CHILD_OF は要素を指します

See also: Mapping Additional Relations 	Expose the elements that are referenced by this property as children of the current element. If multiple aria-owns relationships are found, use only the first one. 	
参照：追加の「関係」のマッピング 	このプロパティによって現在の要素の子として参照されている要素を公開します。 複数の aria-owns 関係性が見つかった場合は、最初の関係のみを使用してください。 	

User agents MAY expose the elements that are referenced by this property as children of the current element. In which case, if multiple aria-owns relationships are found, use only the first one. If the accessibility tree is not modified, expose as:
ユーザーエージェントは、このプロパティによって参照される要素を現在の要素の子として公開できます（MAY）。 その場合、複数の aria-owns 関係性が見つかった場合は、最初の関係のみを使用してください。 アクセシビリティツリーが変更されていない場合は、次のように公開します。

Relation: RELATION_NODE_PARENT_OF points to accessible nodes matching IDREFs, if the referenced objects are in the accessibility tree
関係：参照されるオブジェクトがアクセシビリティツリーにある場合、RELATION_NODE_PARENT_OF は IDREF に一致するアクセス可能なノードを指します

Reverse Relation: RELATION_NODE_CHILD_OF points to element
逆の関係：RELATION_NODE_CHILD_OF は要素を指します

See also: Mapping Additional Relations 	Property: AXOwns: pointers to accessible nodes matching IDREFs
参照：追加の「関係」のマッピング 	プロパティ：AXOwns：IDREF に一致するアクセス可能なノードへのポインター


aria-placeholder 	Object Attribute: placeholder-text:<value> 	Property: AriaProperties.placeholder: <value> 	Object Attribute: placeholder-text:<value> 	Property: AXPlaceholderValue: <value>
aria-placeholder 	オブジェクト属性：placeholder-text:<value> 	プロパティ：AriaProperties.placeholder：<value> 	オブジェクト属性：placeholder-text:<value> 	プロパティ：AXPlaceholderValue：<value>


aria-posinset 	Object Attribute: posinset:<value>
aria-posinset 	オブジェクト属性：posinset:<value>

See also: Group Position 	Property: AriaProperties.posinset: <value>
参照：「グループ位置」 	プロパティ：AriaProperties.posinset：<value>

See also: Group Position 	Object Attribute: posinset:<value>
参照：「グループ位置」 	オブジェクト属性：posinset:<value>

See also: Group Position 	Property: AXARIAPosInSet: <value>
参照：「グループ位置」	プロパティ：AXARIAPosInSet：<value>

See also: Group Position
参照：「グループ位置」 


aria-pressed=true 	State: STATE_SYSTEM_PRESSED
aria-pressed=true 	状態：STATE_SYSTEM_PRESSED

See also: button with defined value for aria-pressed 	Property: Toggle.ToggleState: On (1) 	State: STATE_PRESSED
参照：「aria-pressed の値が定義されているボタン」 	プロパティ：Toggle.ToggleState：オン（1） 	状態：STATE_PRESSED

See also: button with defined value for aria-pressed 	Property: AXValue: 1
参照：「aria-pressed の値が定義されているボタン」 	プロパティ：AXValue：1

See also: button with defined value for aria-pressed
参照：「aria-pressed の値が定義されているボタン」 


aria-pressed=mixed 	State: STATE_SYSTEM_MIXED
aria-pressed=mixed 	状態：STATE_SYSTEM_MIXED

See also: button with defined value for aria-pressed 	Property: Toggle.ToggleState: Indeterminate (2) 	State: STATE_INDETERMINATE
参照：「aria-pressed の値が定義されているボタン」 	プロパティ：Toggle.ToggleState：不確定（2） 	状態：STATE_INDETERMINATE

See also: button with defined value for aria-pressed 	Property: AXValue: 2
参照：「aria-pressed の値が定義されているボタン」 	プロパティ：AXValue：2

See also: button with defined value for aria-pressed
参照：「aria-pressed の値が定義されているボタン」 


aria-pressed=false 	State: STATE_SYSTEM_PRESSED not exposed
aria-pressed=false 	状態：STATE_SYSTEM_PRESSEDは公開されていません

See also: button with defined value for aria-pressed 	Property: Toggle.ToggleState: Off (3) 	State: STATE_PRESSED not exposed
参照：「aria-pressed の値が定義されているボタン」 	プロパティ：Toggle.ToggleState：オフ（3） 	状態：STATE_PRESSEDは公開されていません

See also: button with defined value for aria-pressed 	Property: AXValue: 0
参照：「aria-pressed の値が定義されているボタン」 	プロパティ：AXValue：0

See also: button with defined value for aria-pressed
参照：「aria-pressed の値が定義されているボタン」 


aria-pressed is undefined 	Not mapped* 	Not mapped* 	Not mapped* 	Not mapped*
aria-pressed が未定義 	マップされていない* 	マップされていない* 	マップされていない* 	マップされていない*


aria-readonly=true 	State: STATE_SYSTEM_READONLY 	Property: Value.IsReadOnly: true 	State: STATE_READ_ONLY
aria-readonly=true 	状態：STATE_SYSTEM_READONLY 	プロパティ：Value.IsReadOnly：true 	状態：STATE_READ_ONLY

State: STATE_EDITABLE not exposed on text input roles
状態：STATE_EDITABLE はテキスト入力ロールで公開されていません

State: STATE_CHECKABLE not exposed on roles supporting aria-checked
状態：STATE_CHECKABLE は、aria-checked をサポートするロールで公開されていません

State: STATE_CHECKABLE not exposed on radio descendants when used on a radiogroup 	Method: AXUIElementIsAttributeSettable(AXValue): NO
状態：STATE_CHECKABLE は、ラジオグループで使用した場合、ラジオボタンの子孫に公開されていません 	メソッド：AXUIElementIsAttributeSettable(AXValue)：NO 


aria-readonly=false 	State: STATE_SYSTEM_READONLY not exposed
aria-readonly=false 	状態：STATE_SYSTEM_READONLY は、公開されていません

State: IA2_STATE_EDITABLE 	Property: Value.IsReadOnly: false 	State: STATE_READ_ONLY not exposed 	Method: AXUIElementIsAttributeSettable(AXValue): YES
状態：IA2_STATE_EDITABLE 	プロパティ：Value.IsReadOnly：false 	状態：STATE_READ_ONLY は公開されていません 	メソッド：AXUIElementIsAttributeSettable(AXValue)：YES 


aria-readonly is unspecified on gridcell 	The gridcell MUST inherit any author-provided value for aria-readonly from the containing grid or treegrid. Expose the inherited value on the gridcell as described for aria-readonly="true" and aria-readonly="false". 	The gridcell MUST inherit any author-provided value for aria-readonly from the containing grid or treegrid. Expose the inherited value on the gridcell as described for aria-readonly="true" and aria-readonly="false". 	The gridcell MUST inherit any author-provided value for aria-readonly from the containing grid or treegrid. Expose the inherited value on the gridcell as described for aria-readonly="true" and aria-readonly="false". 	The gridcell MUST inherit any author-provided value for aria-readonly from the containing grid or treegrid. Expose the inherited value on the gridcell as described for aria-readonly="true" and aria-readonly="false".
ria-readonly はグリッドセルで指定されていません 	グリッドセルは、含まれているグリッドまたはツリーグリッドから、作成者が提供した aria-readonly の値を継承する必要があります（MUST）。 aria-readonly="true" および aria-readonly="false" の説明に従って、継承された値をグリッドセルに公開します。 	グリッドセルは、含まれているグリッドまたはツリーグリッドから、作成者が提供した aria-readonly の値を継承する必要があります（MUST）。 aria-readonly="true" および aria-readonly="false" の説明に従って、継承された値をグリッドセルに公開します。 	グリッドセルは、含まれているグリッドまたはツリーグリッドから、作成者が提供した aria-readonly の値を継承する必要があります（MUST）。 aria-readonly="true" および aria-readonly="false" の説明に従って、継承された値をグリッドセルに公開します。 	グリッドセルは、含まれているグリッドまたはツリーグリッドから、作成者が提供した aria-readonly の値を継承する必要があります（MUST）。 aria-readonly="true" および aria-readonly="false" の説明に従って、継承された値をグリッドセルに公開します。



aria-relevant 	Object Attribute: relevant:<value>
aria-relevant 	オブジェクト属性：relevant:<value>

Object Attribute: container-relevant:<value>
オブジェクト属性：container-relevant:<value>

Object Attribute: container-relevant:<value> on all descendants
オブジェクト属性：container-relevant:<value>（すべての子孫について）

See also: Changes to document content or node visibility 	Property: AriaProperties.relevant: <value>
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：AriaProperties.relevant：<値>

See also: Changes to document content or node visibility 	Object Attribute: relevant:<value>
参照：「文書コンテンツやノードの可視性の変更」 	オブジェクト属性：relevant:<value>

Object Attribute: container-relevant:<value>
オブジェクト属性：container-relevant:<value>

Object Attribute: container-relevant:<value> on all descendants
オブジェクト属性：container-relevant:<value>（すべての子孫について）

See also: Changes to document content or node visibility 	Property: AXARIARelevant: <value>
参照：「文書コンテンツやノードの可視性の変更」 	プロパティ：AXARIARelevant：<value>

See also: Changes to document content or node visibility
参照：「文書コンテンツやノードの可視性の変更」


aria-required=true 	State: IA2_STATE_REQUIRED 	Property: IsRequiredForForm: true 	State: STATE_REQUIRED 	Property: AXRequired: YES
aria-required=true 	状態：IA2_STATE_REQUIRED 	プロパティ：IsRequiredForForm：true 	状態：STATE_REQUIRED 	プロパティ：AXRequired：YES


aria-required=false 	Not mapped* 	Not mapped* 	Not mapped* 	Not mapped*
aria-required=false 	マップされていない* 	マップされていない* 	マップされていない* 	マップされていない*


aria-roledescription 	Method: localizedExtendedRole(): <value> 	Localized Control Type: <value> 	Object Attribute: roledescription:<value> 	Property: AXRoleDescription: <value>
aria-roledescription 	メソッド：localizedExtendedRole()：<value> 	ローカライズされたコントロールタイプ：<value> 	オブジェクト属性：roledescription:<value> 	プロパティ：AXRoleDescription：<value>


aria-roledescription is empty or whitespace characters 	Not mapped 	Localized Control Type is defined as that specified for the role of the element: based on the explicit role if the role attribute is provided; otherwise, based on the implicit role for the host language. 	Not mapped 	AXRoleDescription is defined as that specified for the role of the element: based on the explicit role if the role attribute is provided; otherwise, based on the implicit role for the host language.
aria-roledescription が空または空白文字 	マップされていない 	ローカライズされたコントロールタイプは、要素のロールに指定されたものとして定義されます。 ロール属性が指定されている場合は、明示的なロールに基づきます。 それ以外の場合は、ホスト言語の暗黙的なロールに基づきます。 	マップされていない 	AXRoleDescription は、要素のロールに指定されたものとして定義されます。 ロール属性が指定されている場合は、明示的なロールに基づきます。 それ以外の場合は、ホスト言語の暗黙的なロールに基づきます。


aria-rowcount 	Object Attribute: rowcount:<value>
aria-rowcount 	オブジェクト属性：rowcount:<value>

Method: IAccessible2::groupPosition(): similarItemsInGroup=<value> on rows 	Property: Grid.RowCount: <value> 	
メソッド：IAccessible2::groupPosition()：similarItemsInGroup=<value>（行について） 	プロパティ：Grid.RowCount：<value> 	

If the value of aria-rowcount is -1, calculate the row count based on the number of rows in the DOM and expose that value as described below along with STATE_INDETERMINATE.
aria-rowcount の値が -1 の場合、DOM の行数に基づいて行数を計算し、STATE_INDETERMINATE とともに以下で説明するようにその値を公開します。

Object Attribute: rowcount:<value>
オブジェクト属性：rowcount:<value>

Method: atk_table_get_n_rows(): <value> 	Property: AXARIARowCount: <value>
メソッド：atk_table_get_n_rows()：<value> 	プロパティ：AXARIARowCount：<value>


aria-rowindex 	Object Attribute: rowindex:<value>
aria-rowindex 	オブジェクト属性：rowindex:<value>

Method: IAccessible2::groupPosition(): positionInGroup=<value> on rows 	Property: GridItem.Row: <value> (zero-based) 	Object Attribute: rowindex:<value>
メソッド：IAccessible2::groupPosition()：positionInGroup=<value>（行について） 	プロパティ：GridItem.Row：<value>（ゼロベース） 	オブジェクト属性：rowindex:<value>

Method: atk_table_cell_get_position(): row=<value> 	Property: AXARIARowIndex: <value>
メソッド：atk_table_cell_get_position()：row=<value> 	プロパティ：AXARIARowIndex：<value> 


aria-rowspan 	Object Attribute: rowspan:<value>
aria-rowspan 	オブジェクト属性：rowspan:<value>

Method: IAccessibleTableCell::rowExtent(): column=<value> 	Property: GridItem.RowSpan: <value> 	Object Attribute: rowspan:<value>
メソッド：IAccessibleTableCell::rowExtent()：column=<value> 	プロパティ：GridItem.RowSpan：<value> 	オブジェクト属性：rowspan:<value>

Method: atk_table_cell_get_row_column_span(): row_span=<value> 	Property: AXRowIndexRange.length: <value>
メソッド：atk_table_cell_get_row_column_span()：row_span=<value> 	プロパティ：AXRowIndexRange.length：<value> 


aria-selected=true 	State: STATE_SYSTEM_SELECTABLE
aria-selected=true 	状態：STATE_SYSTEM_SELECTABLE

State: STATE_SYSTEM_SELECTED
状態：STATE_SYSTEM_SELECTED

See also: Selection for details on accessibility events 	Property: SelectionItem.IsSelected: true 	State: STATE_SELECTABLE
参照：アクセシビリティイベントの詳細については、「選択」 	プロパティ：SelectionItem.IsSelected：true 	状態：STATE_SELECTABLE

State: STATE_SELECTED
状態：STATE_SELECTED

See also: Selection for details on accessibility events 	Property: AXSelected: YES
参照：アクセシビリティイベントの詳細については、「選択」 	プロパティ：AXSelected：YES 


aria-selected=false 	State: STATE_SYSTEM_SELECTABLE
aria-selected=false 	状態：STATE_SYSTEM_SELECTABLE

State: STATE_SYSTEM_SELECTED not exposed
状態：STATE_SYSTEM_SELECTED は公開されていません

See also: Selection for details on accessibility events 	Property: SelectionItem.IsSelected: false 	State: STATE_SELECTABLE
参照：アクセシビリティイベントの詳細については、「選択」 	プロパティ：SelectionItem.IsSelected：false 	状態：STATE_SELECTABLE

State: STATE_SELECTED not exposed
状態：STATE_SELECTED は公開されていません

See also: Selection for details on accessibility events 	Property: AXSelected: NO
参照：アクセシビリティイベントの詳細については、「選択」 	プロパティ：AXSelected：NO 


aria-selected is undefined 	Not mapped 	Not mapped 	Not mapped 	Not mapped
aria-selected が未定義 	マップされていない 	マップされていない 	マップされていない 	マップされていない


aria-setsize 	Object Attribute: setsize:<value>
aria-setsize 	オブジェクト属性：setsize:<value>

See also: Group Position 	Property: AriaProperties.setsize: <value>
参照：「グループ位置」 	プロパティ：AriaProperties.setsize：<value>

See also: Group Position 	
参照：「グループ位置」 	

If the author-provided value of aria-setsize is -1, the exposed value should be based on the number of objects in the DOM.
作成者が提供した aria-setsize の値が -1 の場合、公開される値は DOM 内のオブジェクトの数に基づいている必要があります。

Object Attribute: setsize:<value>
オブジェクト属性：setsize:<value>

State: STATE_INDETERMINATE if the author-provided value is -1
状態：STATE_INDETERMINATE（author-provided の値が -1 の場合）

See also: Group Position 	Property: AXARIASetSize: <value>
参照：「グループ位置」 	プロパティ：AXARIASetSize：<value>

See also: Group Position
参照：「グループ位置」


aria-sort=ascending 	Object Attribute: sort:ascending 	Property: AriaProperties.sort: ascending
aria-sort=ascending 	オブジェクト属性：sort:ascending 	プロパティ：AriaProperties.sort：ascending

Property: ItemStatus: ascending if the element maps to HeaderItem Control Type 	Object Attribute: sort:ascending 	Property: AXSortDirection: AXAscendingSortDirection
プロパティ：ItemStatus：昇順（要素が HeaderItem コントロールタイプにマップされている場合） 	オブジェクト属性：sort:ascending 	プロパティ：AXSortDirection：AXAscendingSortDirection 


aria-sort=descending 	Object Attribute: sort:descending 	Property: AriaProperties.sort: descending
aria-sort=descending 	オブジェクト属性：sort:descending 	プロパティ：AriaProperties.sort：descending

Property: ItemStatus: descending if the element maps to HeaderItem Control Type 	Object Attribute: sort:descending 	Property: AXSortDirection: AXDescendingSortDirection
プロパティ：ItemStatus：降順（要素が HeaderItem コントロールタイプにマップされている場合） 	オブジェクト属性：sort:descending 	プロパティ：AXSortDirection：AXDescendingSortDirection


aria-sort=other 	Object Attribute: sort:other 	Property: AriaProperties.sort: other
aria-sort=other 	オブジェクト属性：sort:other 	プロパティ：AriaProperties.sort：other

Property: ItemStatus: other if the element maps to HeaderItem Control Type 	Object Attribute: sort:other 	Property: AXSortDirection: AXUnknownSortDirection
プロパティ：ItemStatus：その他（要素が HeaderItem コントロールタイプにマップされている場合） 	オブジェクト属性：sort:other 	プロパティ：AXSortDirection：AXUnknownSortDirection


aria-sort=none 	Object Attribute: sort:none, if the value is not unspecified 	Not mapped* 	Object Attribute: sort:none, if the value is not unspecified 	Not mapped*
aria-sort=none 	オブジェクト属性：sort:none（値が指定されていない場合） 	マップされていない* 	オブジェクト属性：sort:none（値が指定されていない場合） 	マップされていない* 


aria-valuemax 	Method: IAccessibleValue::maximumValue(): <value>
aria-valuemax 	メソッド：IAccessibleValue::maximumValue()：<value>

See also: Widget values 	Property: RangeValue.Maximum: <value>
参照：「ウィジェット値」 	プロパティ：RangeValue.Maximum：<value>

See also: Widget values 	Method: atk_value_get_maximum_value(): <value>
参照：「ウィジェット値」 	メソッド：atk_value_get_maximum_value()：<value>

See also: Widget values 	Property: AXMaxValue: <value>
参照：「ウィジェット値」 	プロパティ：AXMaxValue：<value>

See also: Widget values
参照：「ウィジェット値」 


aria-valuemin 	Method: IAccessibleValue::minimumValue(): <value>
aria-valuemin 	メソッド：IAccessibleValue::minimumValue()：<value>

See also: Widget values 	Property: RangeValue.Minimum: <value>
参照：「ウィジェット値」 	プロパティ：RangeValue.Minimum：<value>

See also: Widget values 	Method: atk_value_get_minimum_value(): <value>
参照：「ウィジェット値」 	メソッド：atk_value_get_minimum_value()：<value>

See also: Widget values 	Property: AXMinValue: <value>
参照：「ウィジェット値」 	プロパティ：AXMinValue：<value>

See also: Widget values
参照：「ウィジェット値」 


aria-valuenow 	Method: IAccessibleValue::currentValue(): <value>
aria-valuenow 	メソッド：IAccessibleValue::currentValue()：<value>

Method: IAccessible::get_accValue(): <value> if aria-valuetext is not defined
メソッド：IAccessible::get_accValue()：<value>（aria-valuetext が定義されていない場合）

See also: Widget values 	Property: RangeValue.Value: <value>
参照：「ウィジェット値」 	プロパティ：RangeValue.Value：<value>

See also: Widget values 	Method: atk_value_get_current_value(): <value>
参照：「ウィジェット値」 	メソッド：atk_value_get_current_value()：<value>

See also: Widget values 	Property: AXValue: <value>
参照：「ウィジェット値」 	プロパティ：AXValue：<value>

See also: Widget values
参照：「ウィジェット値」 


aria-valuetext 	Method: IAccessible::get_accValue(): <value>
aria-valuetext 	メソッド：IAccessible::get_accValue()：<value>

Object Attribute: valuetext:<value>
オブジェクト属性：valuetext:<value>

See also: Widget values 	Property: Value.Value: <value>
参照：「ウィジェット値」 	プロパティ：Value.Value：<value>

See also: Widget values 	Object Attribute: valuetext:<value>
参照：「ウィジェット値」 	オブジェクト属性：valuetext:<value>

See also: Widget values 	Property: AXValueDescription: <value>
参照：「ウィジェット値」 	プロパティ：AXValueDescription：<value>

See also: Widget values
参照：「ウィジェット値」 




5.6 Special Processing Requiring Additional Computation §
5.6 追加の計算を必要とする特別な処理 §



5.6.1 Name and Description §
5.6.1 名前と説明 §

For information on how to compute an accessible name or accessible description, see the section titled Text Alternative Computation of the Accessible Name and Description Computation and API Mappings specification.
アクセス可能な名前またはアクセス可能な説明を計算する方法については、「アクセス可能な名前と説明の計算と API マッピング」の仕様の「テキスト代替計算（Text Alternative Computation）」というタイトルのセクションを参照してください。 （訳注：文書名が変更されている）




5.6.2 Widget Values §
5.6.2 ウィジェット値 §

Some WAI-ARIA roles are widgets that have a particular value within a range of values. For example progressbar, spinbutton, and slider use aria-valuemin and aria-valuemax to specify the range of valid values, aria-valuenow to specify the current value, and optionally aria-valuetext to specify a text string equivalent for the current value.
一部の WAI-ARIA ロールは、値の範囲内で特定の値を持つウィジェットです。 たとえば、プログレスバー（progressbar）、スピンボタン（spinbutton）、スライダー（slider）は、aria-valuemin と aria-valuemax を使用して有効な値の範囲を指定し、aria-valuenow を使用して現在の値を指定し、オプションで aria-valuetext を使用して現在の値と同等のテキスト文字列を指定します。

If the value is not set on a control that requires value, then user agents SHOULD return an error when the current value is requested.
値を必要とするコントロールに値が設定されていない場合、ユーザーエージェントは、現在の値が要求されたときにエラーを返すべきです（SHOULD）。

When assistive technology requests the current value, user agents are not required to ensure that aria-valuenow is greater than aria-valuemin and less than aria-valuemax.
支援技術が現在の値を要求する場合、ユーザーエージェントは、aria-valuenow が aria-valuemin より大きく、aria-valuemax より小さいことを確認する必要はありません。

If an element has the aria-valuetext property set, but not aria-valuenow, user agents MUST expose the string value of aria-valuetext as specified in State and Property Mapping.
要素に aria-valuetext プロパティが設定されている場合、aria-valuenow ではなく、ユーザーエージェントは「状態とプロパティのマッピング」で指定されているように aria-valuetext の文字列値を公開する必要があります（MUST）。 




5.6.3 Relations §
5.6.3 関係 §

Often in a GUI, there are relationships between the widgets that can be exposed programmatically to assistive technology. WAI-ARIA provides several relationship properties which are globally applicable to any element: aria-controls, aria-describedby, aria-flowto, aria-labelledby, aria-owns, aria-posinset, and aria-setsize. Therefore, it is not important to check the role before computing them. User agents can simply map these relations to accessibility APIs as defined in the section titled State and Property Mapping.
多くの場合、GUI には、プログラムで支援技術に公開できるウィジェット間に関係性があります。 WAI-ARIA は、任意の要素にグローバルに適用できるいくつかの関係性プロパティを提供します。 aria-controls、aria-describeby、aria-flowto、aria-labelledby、aria-owns、aria-posinset、および aria-setsize です。 したがって、それらを計算する前にロールを確認することは重要ではありません。 ユーザーエージェントは、「状態とプロパティのマッピング」というタイトルのセクションで定義されているように、これらの関係をアクセシビリティ API に単純にマッピングできます。 




5.6.3.1 ID Reference Error Processing §
5.6.3.1 ID 参照エラー処理 §

User agents SHOULD ignore ID references that do not match the ID of another element in the same document.
ユーザーエージェントは、同じ文書内の別の要素の ID と一致しない ID 参照を無視するべきです（SHOULD）。

It is the web author's responsibility to ensure that IDs are unique. If more than one element has the same ID, the user agent SHOULD use the first element found with the given ID. The behavior will be the same as getElementById.
ID が一意であることを確認するのはウェブ作成者の責任です。 複数の要素が同じ ID を持っている場合、ユーザーエージェントは指定された ID で見つかった最初の要素を使用するべきです（SHOULD）。 振る舞いは getElementById と同じになります。

If the same element is specified multiple times in a single WAI-ARIA relation, user agents SHOULD return multiple pointers to the same object.
同じ要素が単一の WAI-ARIA 関係で複数回指定されている場合、ユーザーエージェントは同じオブジェクトへの複数のポインターを返すべきです（SHOULD）。

aria-activedescendant is defined as referencing only a single ID reference. Any aria-activedescendant value that does not match an existing IDREF exactly is an author error and will not match any element in the DOM.
aria-activedescendant は、単一の ID 参照のみを参照するものとして定義されています。 既存の IDREF と完全に一致しない aria-activedescendant 値は作成者エラーであり、DOM 内のどの要素とも一致しません。 




5.6.3.2 Reverse Relations §
5.6.3.2 逆の関係 §

A reverse relation exists when an element's ID is referenced by a property in another element. For APIs that support reverse relations, user agents MUST use the mapping defined in the following table when an element's ID is referenced by a relation property of another element and the referenced element is in the accessibility tree according to the rules in General rules for exposing WAI-ARIA semantics. All WAI-ARIA references must point to an element that is exposed as an accessible object in the accessibility tree. When the referenced object is not exposed in the accessibility tree (e.g. because it is hidden), the reference is null. aria-labelledby and aria-described by have an additional feature, which allows them to pull a flattened string from the referenced element to populate the name or description fields of the accessibility API. This feature is described in the Name and Description section.
要素の ID が別の要素のプロパティによって参照される場合、逆の関係が存在します。 逆の関係をサポートする API の場合、要素の ID が別の要素の関係プロパティによって参照され、参照された要素が「WAI-ARIA 意味論を公開するための一般的な規則」の規則に従ってアクセシビリティツリーにある場合、ユーザーエージェントは次の表で定義されたマッピングを使用する必要があります（MUST）。 すべての WAI-ARIA 参照は、アクセシビリティツリーでアクセス可能なオブジェクトとして公開されている要素を指している必要があります。 参照されたオブジェクトがアクセシビリティツリーに公開されていない場合（非表示になっているなど）、参照は null になります。 aria-labelledby および aria-describedby には追加機能があり、参照される要素からフラット化された文字列を引き出して、アクセシビリティ API の名前または説明フィールドに入力できます。 この機能については、「名前と説明」のセクションで説明しています。


Reverse relation mapping table WAI-ARIA Relation 	IAccessible2 	ATK/AT-SPI
逆の関係のマッピング表 WAI-ARIA 関係 	IAccessible2 	ATK / AT-SPI


aria-controls references the element's ID 	IA2_RELATION_CONTROLLED_BY 	RELATION_CONTROLLED_BY
aria-controls は要素の ID を参照します 	IA2_RELATION_CONTROLLED_BY 	RELATION_CONTROLLED_BY

aria-describedby references the element's ID 	IA2_RELATION_DESCRIPTION_FOR 	RELATION_DESCRIPTION_FOR
aria-describeby は要素の ID を参照します 	IA2_RELATION_DESCRIPTION_FOR 	RELATION_DESCRIPTION_FOR


aria-details references the element's ID 	IA2_RELATION_DETAILS_FOR 	RELATION_DETAILS_FOR
aria-details は要素の ID を参照します 	IA2_RELATION_DETAILS_FOR 	RELATION_DETAILS_FOR


aria-errormessage references the element's ID 	IA2_RELATION_ERROR_FOR 	RELATION_ERROR_FOR
aria-errormessage は要素の ID を参照します 	IA2_RELATION_ERROR_FOR 	RELATION_ERROR_FOR


aria-flowto references the element's ID 	IA2_RELATION_FLOW_FROM 	RELATION_FLOWS_FROM
aria-flowto は要素の ID を参照します 	IA2_RELATION_FLOW_FROM 	RELATION_FLOWS_FROM


aria-labelledby references the element's ID 	IA2_RELATION_LABEL_FOR 	RELATION_LABEL_FOR
aria-labelledby は要素の ID を参照します 	IA2_RELATION_LABEL_FOR 	RELATION_LABEL_FOR


aria-owns references the element's ID 	IA2_RELATION_NODE_CHILD_OF/IA2_RELATION_NODE_PARENT_OF 	RELATION_NODE_CHILD_OF/RELATION_NODE_PARENT_OF
aria-owns は要素の ID を参照します 	IA2_RELATION_NODE_CHILD_OF / IA2_RELATION_NODE_PARENT_OF 	RELATION_NODE_CHILD_OF / RELATION_NODE_PARENT_OF 


Special case: If both aria-labelledby and HTML <label for= … > are used, the user agent MUST use the WAI-ARIA relation and MUST ignore the HTML label relation.
特殊なケース：aria-labelledby と HTML <label for= … > の両方が使用されている場合、ユーザーエージェントは WAI-ARIA 関係を使用する必要があり（MUST）、HTML ラベルの関係を無視する必要があります（MUST）。

Note that aria-describedby may reference structured or interactive information where users would want to be able to navigate to different sections of content. User agents MAY provide a way for the user to navigate to structured information referenced by aria-describedby and assistive technology SHOULD provide such a method.
aria-describedby は、ユーザーがコンテンツのさまざまなセクションにナビゲートできるようにしたい構造化された情報または相互作用的な情報を参照する場合があることに注意してください。 ユーザーエージェントは、ユーザーが aria-describedby によって参照される構造化された情報にナビゲートする方法を提供してもよいし（MAY）、支援技術はそのような方法を提供するべきです（SHOULD）。 




5.6.3.3 Implied reverse relations §
5.6.3.3 暗黙の逆の関係 §

In addition to the explicit relations defined by WAI-ARIA properties, reverse relations are implied in two other situations: elements with role="treeitem" where the ancestor does not have an aria-owns property and descendants of elements with aria-atomic property.
WAI-ARIA プロパティによって定義された明示的な関係に加えて、逆の関係は、祖先が aria-owns プロパティを持たない role="treeitem" を持つ要素と、aria-atomic プロパティを持つ要素の子孫という2つの状況で暗示されます。

In the case of role="treeitem", when aria-owns is not used, user agents SHOULD do the following where reverse relations are supported by the API:
role="treeitem" の場合、aria-owns が使用されていないとき、ユーザーエージェントは API によって逆の関係がサポートされている場合、次のことを行うべきです（SHOULD）。

    If the current treeitem uses aria-level, then walk backwards in the tree until a treeitem is found with a lower aria-level, then set RELATION_NODE_CHILD_OF to that element. If the top of the tree is reached, then set RELATION_NODE_CHILD_OF to the tree element itself.
    現在のツリー項目が aria-level を使用している場合は、より低い aria-level を持つツリー項目が見つかるまでツリー内を逆方向に歩き、RELATION_NODE_CHILD_OF をその要素に設定します。 ツリーの最上部に到達した場合は、RELATION_NODE_CHILD_OF をツリー要素自体に設定します。

    If the parent of the treeitem has a role of group, then walk backwards from the group until an element with a role of treeitem is found, then set RELATION_NODE_CHILD_OF to that element.
    ツリー項目の親がグループロールを持っている場合は、ツリー項目ロールを持つ要素が見つかるまでグループから逆方向に歩き、RELATION_NODE_CHILD_OF をその要素に設定します。

In the case of aria-atomic, where reverse relations are supported by the API:
逆の関係が API によってサポートされている aria-atomic の場合：

    User agents SHOULD check the chain of ancestor elements for aria-atomic="true". If found, user agents SHOULD set the RELATION_MEMBER_OF relation to point to the ancestor that sets aria-atomic="true".
    ユーザーエージェントは、祖先要素のチェーンで aria-atomic="true" をチェックするべきです（SHOULD）。 見つかった場合、ユーザーエージェントは、 aria-atomic="true" を設定する祖先を指すように RELATION_MEMBER_OF 関係を設定する必要があります。





5.6.4 Group Position §
5.6.4 グループ位置 §

aria-level, aria-posinset, and aria-setsize are all 1-based. When the property is not present or is "0", it indicates the property is not computed or not supported. If any of these properties are specified by the author as either "0" or a negative number, user agents SHOULD use "1" instead.
aria-level、aria-posinset、および aria-setsize はすべて 1 ベースです。 プロパティが存在しないか "0" の場合、プロパティが計算されていないか、サポートされていないことを示します。 これらのプロパティのいずれかが作成者によって "0" または負の数として指定されている場合、ユーザーエージェントは代わりに "1" を使用するべきです（SHOULD）。

If aria-level is not provided or inherited for an element of role treeitem, user agents implementing IAccessible2 or ATK/AT-SPI MUST compute it by following the explicit or computed RELATION_NODE_CHILD_OF relations.
ツリー項目ロールの要素に aria-level が提供または継承されていない場合、IAccessible2 または ATK / AT-SPI を実装するユーザーエージェントは、明示的または計算された RELATION_NODE_CHILD_OF 関係に従ってそれを計算する必要があります（MUST）。

If aria-posinset and aria-setsize are not provided, user agents MUST compute them as follows:
aria-posinset と aria-setsize が指定されていない場合、ユーザーエージェントはそれらを次のように計算する必要があります（MUST）。

    for role="treeitem", walk the tree backward and forward until the explicit or computed level becomes less than the current item's level. Count items only if they are at the same level as the current item.
    role="treeitem" の場合、明示的または計算されたレベルが現在の項目のレベルより低くなるまで、ツリーを前後に歩きます。 現在の項目と同じレベルにある場合にのみ、項目をカウントします。

    Otherwise, if the role supports aria-posinset and aria-setsize, process the parent (DOM parent or parent defined by aria-owns), counting items that have the same role.
    それ以外の場合、ロールが aria-posinset と aria-setsize をサポートしている場合は、親（DOM 親または aria-owns によって定義された親）を処理し、同じロールを持つ項目をカウントします。

    Because these value are 1-based, include the current item in the computation. For aria-posinset, include the current item and other group items if they are before the current item in the DOM. For aria-setsize, add to that the number of items in the same group after the current item in the DOM.
    これらの値は 1 から始まるため、現在の項目を計算に含めます。 aria-posinset の場合、DOM 内の現在の項目の前にある場合は、現在の項目と他のグループ項目を含めます。 aria-setsize の場合、DOM 内の現在の項目の後に同じグループ内の項目の数を追加します。

If the author provides one or more of aria-setsize and aria-posinset, it is the author's responsibility to supply them for all elements in the set. User agent correction of missing values in this case is not defined.
作成者が aria-setsize と aria-posinset の1つ以上を提供する場合、セット内のすべての要素にそれらを提供するのは作成者の責任です。 この場合の欠落値のユーザーエージェントによる修正は定義されていません。

MSAA/IAccessible2 API mappings involve an additional function, groupPosition() [IAccessible2], when aria-level, aria-posinset, and/or aria-setsize are present on an element, or are computed by the user agent. When this occurs:
MSAA / IAccessible2 API マッピングには、aria-level、aria-posinset、および/または aria-setsize が要素に存在する場合、またはユーザーエージェントによって計算される場合、追加の関数 groupPosition() [IAccessible2] が含まれます。 このような場合：

    aria-level is exposed in the groupLevel parameter of groupPosition(),
    aria-level は、groupPosition() の groupLevel パラメーターで公開されます。

    aria-setsize is exposed in the similarItemsInGroup parameter, and
    aria-setsize は、similarItemsInGroup パラメーターで公開されます。

    aria-posinset is exposed in the positionInGroup parameter.
    aria-posinset は positionInGroup パラメーターで公開されます。





5.7 Actions §
5.7 アクション §

As part of mapping roles to accessible objects as defined in Role Mapping, users agents expose a default action on the object.
「ロールのマッピング」で定義されているように、アクセス可能なオブジェクトにロールをマッピングする一環として、ユーザーエージェントはオブジェクトに対するデフォルトのアクションを公開します。

    MSAA: If an AT calls DoDefaultAction on an accessible object, the user agent SHOULD simulate a click on the DOM element which is mapped to that accessible object.
    MSAA：AT がアクセス可能なオブジェクトに対して DoDefaultAction を呼び出す場合、ユーザーエージェントはそのアクセス可能なオブジェクトにマップされている DOM 要素のクリックをシミュレートするべきです（SHOULD）。

    IAccessible2: If an AT calls the IAccessibleAction on an accessible object, the user agent SHOULD simulate a click on the DOM element which is mapped to that accessible object.
    IAccessible2：AT がアクセス可能なオブジェクトに対して IAccessibleAction を呼び出す場合、ユーザーエージェントはそのアクセス可能なオブジェクトにマップされている DOM 要素のクリックをシミュレートするべきです（SHOULD）。

    UIA Automation: If an AT calls any UIA pattern method on an accessible object, the user agent SHOULD simulate a click on the DOM element which is mapped to that accessible object.
    UIA 自動化：AT がアクセス可能なオブジェクトで UIA パターンメソッドのどれかを呼び出す場合、ユーザーエージェントはそのアクセス可能なオブジェクトにマップされている DOM 要素のクリックをシミュレートするべきです（SHOULD）。

    ATK/AT-SPI: If an AT calls an action on an accessible object, the user agent SHOULD simulate a click on the DOM element which is mapped to that accessible object.
    ATK / AT-SPI：AT がアクセス可能なオブジェクトに対してアクションを呼び出す場合、ユーザーエージェントはそのアクセス可能なオブジェクトにマップされている DOM 要素のクリックをシミュレートするべきです（SHOULD）。

    AX API: If an AT triggers an AXPress action on an accessible object, the user agent SHOULD simulate a click on the DOM element which is mapped to that accessible object.
    AX API：AT がアクセス可能なオブジェクトに対して AXPress アクションをトリガーする場合、ユーザーエージェントはそのアクセス可能なオブジェクトにマップされている DOM 要素のクリックをシミュレートするべきです（SHOULD）。

Note
注

Authors will need to create handlers for those click events that update WAI-ARIA states and properties in the DOM accordingly, so that those updated states can be populated by the user agent in the Accessibility API.
作成者は、DOM の WAI-ARIA 状態とプロパティを適宜更新するクリックイベントのハンドラーを作成する必要があります。 これにより、これらの更新された状態は、ユーザーエージェントがアクセシビリティ API に入力できます。




5.8 Events §
5.8 イベント §

User agents fire events for user actions, WAI-ARIA state changes, changes to document content or node visibility, changes in selection and operation of menus as defined in the following sections.
ユーザーエージェントは、次のセクションで定義されているように、ユーザーアクション、WAI-ARIA 状態の変更、文書コンテンツやノードの可視性の変更、選択の変更とメニューの操作に対してイベントを発火させます。 




5.8.1 State and Property Change Events §
5.8.1 状態とプロパティの変更イベント §

User agents MUST notify assistive technology of state changes as defined in the table below, SHOULD notify assistive technology of property changes if the accessibility API defines a change event for the property, and SHOULD NOT notify assistive technology of property changes if the accessibility API does not define a change event for the property. For example, IAccessible2 defines an event to be used when aria-activedescendant changes. WAI-ARIA properties that are expected to change include aria-activedescendant, aria-valuenow, and aria-valuetext.
ユーザーエージェントは、以下の表で定義されているように、状態の変化を支援技術に通知する必要があり（MUST）、アクセシビリティ API がプロパティの変更イベントを定義している場合は、プロパティの変更を支援技術に通知するべきであり（SHOULD）、アクセシビリティ API がプロパティの変更イベントを定義しない場合は、プロパティの変更を支援技術に通知するべきではありません（SHOULD NOT）。 たとえば、IAccessible2 は、aria-activedescendant が変更されたときに使用されるイベントを定義します。 変更が予想される WAI-ARIA プロパティには、aria-activedescendant、aria-valuenow、および aria-valuetext が含まれます。

See the Name and Description Change Events section of the Accessible Name and Description Computation document regarding how different accessibility APIs expose changes to aria-describedby, aria-label, and aria-labelledby.
さまざまなアクセシビリティ API が aria-describedby、aria-label、および aria-labelledby への変更を公開する方法については、「アクセス可能な名前と説明の計算」の文書の「名前と説明の変更イベント（Name and Description Change Events）」のセクションを参照してください。（訳注：セクションが無くなっている）

Note
注

In some APIs, AT will only be notified of events to which it has subscribed.
一部の API では、AT には AT が購読したイベントについてのみ通知されます。

For simplicity and performance the user agent MAY trim out change events for state or property changes that assistive technologies typically ignore, such as events that are happening in a window that does not currently have focus.
単純さとパフォーマンスのために、ユーザーエージェントは、現在フォーカスがないウィンドウで発生しているイベントなど、支援技術が通常無視する状態またはプロパティの変更の変更イベントをトリミングできます（MAY）。

Note
注

Translators: For label text associated with the following table and its toggle buttons, see the mappingTableLabels object in the <head> section of this document.
翻訳者：次の表とそのトグルボタンに関連付けられているラベルテキストについては、この文書の <head> セクションにある mappingTableLabels オブジェクトを参照してください。


Table of events to be fired in each API for changes in WAI-ARIA states and properties State or Property 	MSAA + IAccessible2 event 	UIA event 	ATK/AT-SPI event 	AX API Notification
WAI-ARIA の状態とプロパティの変更のために各 API で発火するイベントの表 状態またはプロパティ 	MSAA + IAccessible2 イベント 	UIA イベント 	ATK / AT-SPI イベント 	AXAPI 通知


aria-activedescendant 	See Controlling focus with aria-activedescendant
aria-activedescendant 	「aria-activedescendant によるフォーカスの制御」を参照してください

In addition:
加えて：

IA2_EVENT_ACTIVE_DESCENDANT_CHANGED

	See Controlling focus with aria-activedescendant 	See Controlling focus with aria-activedescendant 	See Controlling focus with aria-activedescendant
 	「aria-activedescendant によるフォーカスの制御」を参照してください 	「aria-activedescendant によるフォーカスの制御」を参照してください 	「aria-activedescendant によるフォーカスの制御」を参照してください

In addition: AXSelectedChildrenChanged
加えて：AXSelectedChildrenChanged 


aria-busy (state) 	EVENT_OBJECT_STATECHANGE 	PropertyChangedEvent 	object:state-changed:busy 	AXElementBusyChanged
aria-busy（状態） 	EVENT_OBJECT_STATECHANGE 	PropertyChangedEvent 	object:state-changed:busy 	AXElementBusyChanged


aria-checked (state) 	EVENT_OBJECT_STATECHANGE 	ToggleStateProperty as part of toggle pattern 	object:state-changed:checked 	AXValueChanged
aria-checked（状態） 	EVENT_OBJECT_STATECHANGE 	トグルパターンの一部としての ToggleStateProperty 	object:state-changed:checked 	AXValueChanged


aria-current (state) 	IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED 	PropertyChangedEvent 	object:state-changed:active 	No notification
aria-current（状態） 	IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED 	PropertyChangedEvent 	object:state-changed:active 	通知なし


aria-disabled (state) 	EVENT_OBJECT_STATECHANGE 	No event 	object:state-changed:enabled and object:state-changed:sensitive 	No notification
aria-disabled（状態） 	EVENT_OBJECT_STATECHANGE 	イベントなし 	object:state-changed:enabled と object:state-changed:sensitive 	通知なし


aria-dropeffect (property) 	IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED 	No event 	object:property-change 	No notification
aria-dropeffect（プロパティ） 	IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED 	イベントなし 	object:property-change 	通知なし


aria-expanded (state) 	EVENT_OBJECT_STATECHANGE 	expand/collapse pattern events 	object:state-changed:expanded 	AXRowExpanded,
aria-expanded（状態） 	EVENT_OBJECT_STATECHANGE 	展開/折りたたみのパターンのイベント 	object:state-changed:expanded 	AXRowExpanded,

AXRowCollapsed,

AXRowCountChanged


aria-grabbed (state) 	
aria-grabbed（状態） 	

EVENT_OBJECT_SELECTION

IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED

	No event 	object:property-change 	No notification
	イベントなし 	object:property-change 	通知なし


aria-hidden (state) 	IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED 	StructureChangedEvent 	object:property-change 	AXUIElementDestroyed,
aria-hidden（状態） 	IA2_EVENT_OBJECT_ATTRIBUTE_CHANGED 	StructureChangedEvent 	object:property-change 	AXUIElementDestroyed,

AXUIElementCreated


aria-invalid (state) 	EVENT_OBJECT_STATECHANGE 	No event 	object:state-changed:invalid_entry 	AXInvalidStatusChanged
aria-invalid（状態） 	EVENT_OBJECT_STATECHANGE 	イベントなし 	object:state-changed:invalid_entry 	AXInvalidStatusChanged


aria-pressed (state) 	EVENT_OBJECT_STATECHANGE 	No event 	object:state-changed:pressed 	No notification
aria-pressed（状態） 	EVENT_OBJECT_STATECHANGE 	イベントなし 	object:state-changed:pressed 	通知なし


aria-readonly 	EVENT_OBJECT_STATECHANGE 	No event 	object:state-changed:readonly 	No notification
aria-readonly 	EVENT_OBJECT_STATECHANGE 	イベントなし 	object:state-changed:readonly 	通知なし


aria-required 	EVENT_OBJECT_STATECHANGE 	No event 	object:state-changed:required 	No notification
aria-required 	EVENT_OBJECT_STATECHANGE 	イベントなし 	object:state-changed:required 	通知なし


aria-selected (state) 	See section Selection for details. 	See section Selection for details. 	See section Selection for details. 	See section Selection for details.
aria-selected（状態） 	詳細については、セクション「選択」を参照してください。 	詳細については、セクション「選択」を参照してください。 	詳細については、セクション「選択」を参照してください。 	詳細については、セクション「選択」を参照してください。


aria-valuenow 	EVENT_OBJECT_VALUECHANGE 	ValueProperty property change as part of value pattern 	object:property-change:accessible-value 	AXValueChanged
aria-valuenow 	EVENT_OBJECT_VALUECHANGE 	値パターンの一部としての ValueProperty プロパティの変更 	object:property-change:accessible-value 	AXValueChanged


aria-valuetext 	EVENT_OBJECT_VALUECHANGE 	No event 	object:property-change:accessible-value 	AXValueChanged
aria-valuetext 	EVENT_OBJECT_VALUECHANGE 	イベントなし 	object:property-change:accessible-value 	AXValueChanged




5.8.2 Changes to document content or node visibility §
5.8.2 文書コンテンツやノードの可視性の変更 §

Processing document changes is important regardless of WAI-ARIA. The events described in the table below are used by user agents to inform AT of changes to the DOM via the accessibility tree. For the purposes of conformance with this standard, user agents MUST implement the behavior described in this section whenever WAI-ARIA attributes are applied to dynamic content on a Web page.
WAI-ARIA に関係なく、文書の変更を処理することは重要です。 以下の表で説明されているイベントは、ユーザーエージェントがアクセシビリティツリーを介して DOM の変更を AT に通知するために使用されます。 この標準に準拠するために、ユーザーエージェントは、WAI-ARIA 属性がウェブページの動的コンテンツに適用される場合は常に、このセクションで説明されている振る舞いを実装する必要があります（MUST）。


Table of document change scenarios and events to be fired in each API Scenario 	MSAA + IAccessible2 event 	UIA event 	ATK/AT-SPI event 	AX API Notification
文書変更シナリオと各 API で発火するイベントの表 シナリオ 	MSAA + IAccessible2 イベント 	UIA イベント 	ATK / AT-SPI イベント 	AXAPI 通知 


When text is removed 	IA2_EVENT_TEXT_REMOVED 	EVENT_OBJECT_LIVEREGIONCHANGED 	text_changed::delete 	If in a live region, AXLiveRegionChanged.
テキストが削除されたとき 	IA2_EVENT_TEXT_REMOVED 	EVENT_OBJECT_LIVEREGIONCHANGED 	text_changed::delete 	ライブリージョンにある場合、AXLiveRegionChanged。

If in aria-errormessage, AXValidationErrorChanged.
aria-errormessage の場合、AXValidationErrorChanged。


When text is inserted 	IA2_EVENT_TEXT_INSERTED 	EVENT_OBJECT_LIVEREGIONCHANGED 	text_changed::insert 	If in a live region, AXLiveRegionChanged.
テキストが挿入されたとき 	IA2_EVENT_TEXT_INSERTED 	EVENT_OBJECT_LIVEREGIONCHANGED 	text_changed::insert 	ライブリージョンにある場合、AXLiveRegionChanged。

If in aria-errormessage, AXValidationErrorChanged.
aria-errormessage の場合、AXValidationErrorChanged。


When text is changed 	IA2_EVENT_TEXT_REMOVE and IA2_EVENT_TEXT_INSERTED 	EVENT_OBJECT_LIVEREGIONCHANGED 	text_changed::delete and text_changed::insert 	If in a live region, AXLiveRegionChanged.
テキストが変更されたとき 	IA2_EVENT_TEXT_REMOVE and IA2_EVENT_TEXT_INSERTED 	EVENT_OBJECT_LIVEREGIONCHANGED 	text_changed::delete と text_changed::insert 	ライブリージョンにある場合、AXLiveRegionChanged。

If in aria-errormessage, AXValidationErrorChanged.
aria-errormessage の場合、AXValidationErrorChanged。


Fire these events for node changes where the node in question is an element and has an accessible object:
問題のノードが要素であり、アクセス可能なオブジェクトがある場合、ノードの変更に対してこれらのイベントを発火させます。


Table of document change scenarios and events to be fired in each API Scenario 	MSAA 	Microsoft UIA event 	ATK/AT-SPI event 	AX API Notification
文書変更シナリオと各 API で発火するイベントの表 シナリオ 	MSAA 	Microsoft UIA イベント 	ATK / AT-SPI イベント 	AX API 通知 


When an accessibility subtree is hidden 	EVENT_OBJECT_HIDE
アクセシビリティサブツリーが非表示になっている場合 	EVENT_OBJECT_HIDE

The MSAA event called EVENT_OBJECT_DESTROY is not used because this has a history of stability issues and assistive technology avoids it. In any case, from the user's point of view, there is no difference between something that is hidden or destroyed. 	AutomationElement..::.StructureChangedEvent 	children_changed::remove 	
EVENT_OBJECT_DESTROY と呼ばれる MSAA イベントは使用されません。 これは、安定性の問題の履歴があり、支援技術がそれを回避するためです。 いずれにせよ、ユーザーの観点からは、非表示になっているものと破壊されているものの間に違いはありません。 	AutomationElement..::.StructureChangedEvent 	children_changed::remove 	

AXUIElementDestroyed

If in a live region, AXLiveRegionChanged
ライブリージョンにある場合、AXLiveRegionChanged


When an accessibility subtree is removed 	EVENT_OBJECT_REORDER
アクセシビリティサブツリーが取り除かれたとき 	EVENT_OBJECT_REORDER

The MSAA event called EVENT_OBJECT_DESTROY is not used because this has a history of stability issues and assistive technology avoids it. In any case, from the user's point of view, there is no difference between something that is hidden or destroyed. 	AutomationElement..::.StructureChangedEvent 	children_changed::remove 	
EVENT_OBJECT_DESTROY と呼ばれる MSAA イベントは使用されません。 これは、安定性の問題の履歴があり、支援技術がそれを回避するためです。 いずれにせよ、ユーザーの観点からは、非表示になっているものと破壊されているものの間に違いはありません。 	AutomationElement..::.StructureChangedEvent 	children_changed::remove 	

AXUIElementDestroyed

If in a live region, AXLiveRegionChanged
ライブリージョンにある場合、AXLiveRegionChanged


When an accessibility subtree is shown 	EVENT_OBJECT_SHOW 	  	children_changed::add 	
アクセシビリティサブツリーが表示されている場合 	EVENT_OBJECT_SHOW 	  	children_changed::add 	

AXUIElementCreated

If in a live region, AXLiveRegionChanged
ライブリージョンにある場合、AXLiveRegionChanged


When an accessibility subtree is inserted 	EVENT_OBJECT_REORDER 	  	children_changed::add 	
アクセシビリティサブツリーが挿入されたとき 	EVENT_OBJECT_REORDER 	  	children_changed::add 	

AXUIElementCreated

If in a live region, AXLiveRegionChanged
ライブリージョンにある場合、AXLiveRegionChanged


When an accessibility subtree is moved 	Treat it as a removal from one place and insertion in another 	Treat it as a removal from one place and insertion in another 	Treat it as a removal from one place and insertion in another 	
アクセシビリティサブツリーが移動されたとき 	ある場所からの取り外しと別の場所への挿入として扱います 	ある場所からの取り外しと別の場所への挿入として扱います 	ある場所からの取り外しと別の場所への挿入として扱います 	

AXUIElementDestroyed/ AXUIElementCreated

If in a live region, AXLiveRegionChanged
ライブリージョンにある場合、AXLiveRegionChanged


When an accessibility subtree is changed (e.g. replaceNode) 	Treat it as a removal and insertion 	Treat it as a removal and insertion 	Treat it as a removal and insertion 	
アクセシビリティサブツリーが変更されたとき（replaceNode など） 	取り外しと挿入として扱います 	取り外しと挿入として扱います 	取り外しと挿入として扱います 	

AXUIElementDestroyed/ AXUIElementCreated

If in a live region, AXLiveRegionChanged
ライブリージョンにある場合、AXLiveRegionChanged


In some cases, node changes may occur where the node is not an element or has no accessible object. For example, a numbered list bullet ("12.") may have a node in the accessibility tree but not in the DOM tree. For text within a paragraph marked in HTML as <strong>, the <strong> element has a node in the DOM tree but may not have one in the accessibility tree. The text itself will of course be in the accessibility tree along with the identification of the range of text that is formatted as strong. If any of the changes described in the table above occur on such a node, user agents SHOULD compute and fire relevant text change events as described above.
場合によっては、ノードが要素ではないか、アクセス可能なオブジェクトがない場合に、ノードの変更が発生することがあります。 たとえば、番号付きリストの箇条書き（"12."）には、アクセシビリティツリーにはノードがありますが、DOM ツリーにはありません。 HTML で <strong> としてマークされた段落内のテキストの場合、<strong> 要素には DOM ツリーにノードがありますが、アクセシビリティツリーにはノードがない場合があります。 もちろん、テキスト自体は、strong としてフォーマットされたテキストの範囲の識別とともに、アクセシビリティツリーに含まれます。 上記の表に記載されている変更のいずれかがそのようなノードで発生した場合、ユーザーエージェントは上記のように関連するテキスト変更イベントを計算して発火させるべきです（SHOULD）。

User agents SHOULD ensure that an assistive technology, running in process can receive notification of a node being removed prior to removal. This allows an assistive technology, such as a screen reader, to refer back to the corresponding DOM node being deleted. This is important for live regions where removals are important. For example, a screen reader would want to notify a user that another user has left a chat room. The event in MSAA would be EVENT_OBJECT_HIDE. For ATK/AT-SPI this would be children_changed::remove. And in macOS, the event is AXLiveRegionChanged. This also requires the user agent to provide a unique ID in the accessibility API notification identifying the unique node being removed.
ユーザーエージェントは、処理中の支援技術が、ノードが取り除かれる前にノードが取り除かれたという通知を受信できることを確認するべきです（SHOULD）。 これにより、スクリーンリーダーなどの支援技術が、削除される対応する DOM ノードを参照できるようになります。 これは、除去が重要なライブリージョンにとって重要です。 たとえば、スクリーンリーダーは、別のユーザーがチャットルームを離れたことをユーザーに通知したいとします。 MSAA のイベントは EVENT_OBJECT_HIDE になります。 ATK / AT-SPI の場合、これは children_changed::remove になります。 そして macOS では、イベントは AXLiveRegionChanged です。 これには、ユーザーエージェントがアクセシビリティ API 通知で一意の ID を提供して、取り除かれる一意のノードを識別する必要もあります。

When firing any of the above-mentioned change events, it is very useful to provide information about whether the change was caused by user input (as opposed to a timeout initiated from the page load, etc.). This allows the assistive technology to have different rules for presenting changes from the real world as opposed to from user action. Mouse hovers are not considered explicit user input because they can occur from accidental bumps of the mouse.
上記の変更イベントのいずれかを発生させる場合、変更がユーザー入力によって引き起こされたかどうかに関する情報を提供することは非常に役立ちます（ページの読み込みなどから開始されるタイムアウトではありません）。 これにより、支援技術は、ユーザーの操作からではなく、現実の世界からの変更を提示するためのさまざまな規則を持つことができます。 マウスホバーは、マウスの偶発的な衝突によって発生する可能性があるため、明示的なユーザー入力とは見なされません。

To expose whether a change occurred from user input:
次のように、ユーザー入力から変更が発生したかどうかを公開します。

    In ATK/AT-SPI this can be provided by appending the string ":system" to the event name when the user did not cause the change.
    ATK / AT-SPI では、ユーザーが変更を行わなかったときに、イベント名に文字列 ":system" を追加することでこれを提供できます。

    In IAccessible2, which screen readers typically access in process on the same thread, the best practice is to expose the object attribute event-from-user-input:true on the accessible object for the event, if the user caused the change.
    スクリーンリーダーが通常同じスレッドで処理中にアクセスする IAccessible2 では、ユーザーが変更を加えた場合、ベストプラクティスは、イベントのアクセス可能なオブジェクトでオブジェクト属性 event-from-user-input:true を公開することです。

Exposing additional useful information about the context of the change:
次のように、変更のコンテキストに関する追加の有用な情報を公開します。

    In ATK/AT-SPI and IAccessible2, the RELATION_MEMBER_OF relation on the accessible event's target accessible object SHOULD point to any ancestor with aria-atomic="true" (if any).
    ATK / AT-SPI および IAccessible2 では、アクセス可能なイベントの対象であるアクセス可能なオブジェクトの RELATION_MEMBER_OF 関係は、aria-atomic="true"（存在する場合）を持つすべての祖先を指すべきです（SHOULD）。

    In ATK/AT-SPI and IAccessible2, the container-live, container-relevant, container-busy, container-atomic object attributes SHOULD be exposed on the accessible event object, providing the computed value for the related WAI-ARIA properties. The computed value is the value of the closest ancestor. It is recommended to not expose the object attribute if the default value is used.
    ATK / AT-SPI および IAccessible2 では、container-live、container-relevant、container-busy、container-atomic オブジェクト属性をアクセス可能なイベントオブジェクトに公開し、関連する WAI-ARIA プロパティの計算値を提供するべきです（SHOULD）。 計算された値は、最も近い祖先の値です。 デフォルト値を使用する場合は、オブジェクト属性を公開しないことをお勧めします。

Additional MSAA events may be necessary:
次のように、追加の MSAA イベントが必要になる場合があります。

    If something changes in an ancestor with a mapped MSAA role of ROLE_SYSTEM_ALERT, then an EVENT_SYSTEM_ALERT event SHOULD be fired for the alert. The alert role has an implied value of "assertive" for the aria-live property.
    マップされた MSAA ロールが ROLE_SYSTEM_ALERT である祖先で何かが変更された場合、アラートに対して EVENT_SYSTEM_ALERT イベントを発火させるべきです（SHOULD）。 アラートロールには、aria-live プロパティの "assertive" という暗黙の値があります。

    Menu events may need to be fired. See Special Events for Menus.
    メニューイベントを発火させる必要がある場合があります。 「メニューの特別イベント」を参照してください。





5.8.3 Selection §
5.8.3 選択 §

There are two cases for selection:
選択には次の2つのケースがあります。

    Single selection
    単一選択（Single selection）

    Multiple selection
    複数選択（Multiple selection）

In the single selection case, selection follows focus (see the section "Focus States and Events Table" for information about focus events). User agents MUST fire the following events when aria-selected changes:
単一選択の場合、選択はフォーカスに従います（フォーカスイベントについては、「フォーカスの状態とイベントの表」のセクションを参照してください）。 aria-selected　が変更された場合、ユーザーエージェントは次のイベントを発火させる必要があります（MUST）。


Single selection events Scenario 	MSAA 	Microsoft UIA 	ATK/AT-SPI 	AX API
単一選択のイベント シナリオ 	MSAA 	Microsoft UIA 	ATK / AT-SPI 	AX API 


Focus change 	EVENT_OBJECT_SELECTION and EVENT_OBJECT_STATECHANGE on newly focused item. 	UIA_SelectionItem_ElementSelectedEventId on the newly focused element.
フォーカスの変更 	EVENT_OBJECT_SELECTION および EVENT_OBJECT_STATECHANGE（新しくフォーカスされた項目について）。 	UIA_SelectionItem_ElementSelectedEventId（新しくフォーカスされた要素について）。

If on a gridcell, row, option, or tab, fire UIA_SelectionItem_ElementSelectedEventId.
グリッドセル、行、オプション、またはタブの場合は、UIA_SelectionItem_ElementSelectedEventId を発火します。

	

    object:selection-changed on the current container,
    object:selection-changed（現在のコンテナについて）、

    object:state-changed:selected on the descendant accessible object whose selection has changed:
    object:state-changed:selected（選択が変更された子孫のアクセス可能なオブジェクトについて）：

        detail1 = 1 for the descendant which just became selected.
        選択されたばかりの子孫では detail1 = 1。

        detail1 = 0 for the descendant which just became unselected.
        選択解除されたばかりの子孫では detail1 = 0。

	AXSelectedChildrenChanged


The multiple selection case occurs when aria-multiselectable="true" on an element with a role that supports that property. User agents MUST fire the following events when aria-selected changes on a descendant, as follows:
複数選択の場合は、そのプロパティをサポートするロールを持つ要素で aria-multiselectable="true" の場合に発生します。 ユーザーエージェントは、次のように、子孫で aria-selected が変更されたときに、次のイベントを発火させる必要があります（MUST）。

The multiple selection case occurs when aria-multiselectable="true" on an element with a role that supports that property. There are several important aspects:
複数選択の場合は、そのプロパティをサポートするロールを持つ要素で aria-multiselectable="true" の場合に発生します。 次のいくつかの重要な側面があります。

    In Microsoft UIA, the Selection and SelectionItem Control Patterns expose the selection availability, state, and methods.
    Microsoft UIA では、選択および選択項目のコントロールパターンは、選択の可用性、状態、およびメソッドを公開します。

    User agents MUST fire the following events when aria-selected changes on a descendant, as follows:
    ユーザーエージェントは、次のように、子孫で aria-selected が変更されたときに、次のイベントを発火させる必要があります（MUST）。


Multiple selection events Scenario 	MSAA 	Microsoft UIA 	ATK/AT-SPI 	AX API
複数選択のイベント シナリオ 	MSAA 	Microsoft UIA 	ATK / AT-SPI 	AX API 


Toggle aria-selected 	EVENT_OBJECT_SELECTIONADD/EVENT_OBJECT_SELECTIONREMOVE on the item. 	SelectionItem Control Pattern:UIA_SelectionItem_ElementAddedToSelectionEventId or UIA_SelectionItem_ElementRemovedFromSelectionEventId on the current container. 	
aria-selected のトグル 	EVENT_OBJECT_SELECTIONADD / EVENT_OBJECT_SELECTIONREMOVE（項目について）。 	選択項目コントロールパターン：UIA_SelectionItem_ElementAddedToSelectionEventId または UIA_SelectionItem_ElementRemovedFromSelectionEventId（現在のコンテナについて）。 	

    object:selection-changed on the current container,
    object:selection-changed（現在のコンテナについて）、

    object:state-changed:selected on any descendant accessible object whose selection has changed:
    object:state-changed:selected（選択が変更された子孫のアクセス可能なオブジェクトについて）：

        detail1 = 1 for any descendant which just became selected.
        選択されたばかりの子孫では detail1 = 1。

        detail1 = 0 for any descendant which just became unselected.
        選択解除されたばかりの子孫では detail1 = 0。

	AXSelectedChildrenChanged


Selection follows focus 	EVENT_OBJECT_SELECTION and EVENT_OBJECT_STATECHANGE on newly focused item. 	FocusChangedEvent should be fired but individual selection event may not happen, to avoid redundancy. 	
選択はフォーカスに従う 	EVENT_OBJECT_SELECTION および EVENT_OBJECT_STATECHANGE（新しくフォーカスされた項目について）。 	FocusChangedEvent は発火させるべきですが、冗長性を避けるために、個別の選択イベントは発火しないかもしれません。	 	

    object:selection-changed on the current container,
    object:selection-changed（現在のコンテナについて）、

    object:state-changed:selected on any descendant accessible object whose selection has changed:
    object:state-changed:selected（選択が変更された子孫のアクセス可能なオブジェクトについて）：

        detail1 = 1 for any accessible object which just became selected.
        選択されたばかりのアクセス可能なオブジェクトでは detail1 = 1。

        detail1 = 0 for any accessible object which just became unselected.
        選択解除されたばかりのアクセス可能なオブジェクトでは detail1 = 0。

	AXSelectedChildrenChanged


Select or deselect many items at once 	User agent MAY fire an EVENT_OBJECT_SELECTIONWITHIN. If this event is fired the other events noted above MAY be trimmed out for performance. 	For each element selected or deselected, fire SelectionItem Control Pattern: UIA_SelectionItem_ElementAddedToSelectionEventId or UIA_SelectionItem_ElementRemovedFromSelectionEventId on the current container. User agents MAY choose to fire the Selection Control Pattern Invalidated event, which indicates that the selection in a container has changed significantly and requires sending more addition and removal events than the InvalidateLimit constant permits. 	
一度に多くの項目を選択または選択解除 	ユーザーエージェントは、EVENT_OBJECT_SELECTIONWITHIN を発火できます（MAY）。 このイベントが発火した場合、上記の他のイベントはパフォーマンスのためにトリミングできます（MAY）。 	選択または選択解除された要素ごとに、現在のコンテナーで選択項目コントロールパターン：UIA_SelectionItem_ElementAddedToSelectionEventId または UIA_SelectionItem_ElementRemovedFromSelectionEventId を発火します。 ユーザーエージェントは、選択コントロールパターンの無効化（Selection Control Pattern Invalidated）イベントを発火させることを選択できます（MAY）。 これは、コンテナー内の選択が大幅に変更され、InvalidateLimit 定数が許可するよりも多くの追加および削除イベントを送信する必要があることを示します。 	

    the user agent MAY fire a single object:selection-changed event on the container, vs. multiple events, for performance,
    ユーザーエージェントは、パフォーマンスのために、複数のイベントではなく、単一の object:selection-changed イベントをコンテナ上で発火できます（MAY）、

    object:state-changed:selected on any descendant accessible object whose selection has changed:
    object:state-changed:selected（選択が変更された子孫のアクセス可能なオブジェクトについて）：

        detail1 = 1 for any accessible object which just became selected.
        選択されたばかりのアクセス可能なオブジェクトでは detail1 = 1。

        detail1 = 0 for any accessible object which just became unselected.
        選択解除されたばかりのアクセス可能なオブジェクトでは detail1 = 0。

	AXSelectedChildrenChanged




5.8.4 Special Events for Menus §
5.8.4 メニューの特別イベント §

Some APIs, provide special events whenever a menu is opened or closed. User agents SHOULD provide the events as described in the table below. If provided, because menus can be made visible or hidden using a variety of techniques, a user agent MUST ensure that the events are nested and symmetrical.
一部の API は、メニューを開いたり閉じたりするたびに特別なイベントを提供します。 ユーザーエージェントは、以下の表で説明されているようにイベントを提供するべきです（SHOULD）。 提供されている場合、メニューはさまざまな手法を使用して表示または非表示にできるため、ユーザーエージェントは、イベントがネストされ、対称的であることを確認する必要があります（MUST）。

Frequently, a menubar is used to organize a hierarchy of menus. In those cases, the menubar MUST be a DOM parent of the associated menuitems, or one defined by aria-owns. In other cases, no menubar is involved; for example, when the menu is associated with a toolbar button, or is a context menu. Nonetheless the relevant menu events are provided as described in the following table.
多くの場合、メニューバーはメニューの階層を整理するために使用されます。 そのような場合、メニューバーは、関連するメニュー項目の DOM 親、または aria-owns によって定義されたものでなければなりません（MUST）。 その他の場合、メニューバーは含まれません。 たとえば、メニューがツールバーボタンに関連付けられている場合、またはコンテキストメニューである場合です。 それでも、次の表に示すように、関連するメニューイベントが提供されます。


Menu events Scenario 	MSAA 	Microsoft UIA 	AX API
メニューイベント シナリオ 	MSAA 	Microsoft UIA 	AX API 


Menubar is currently not active, and user moves focus to the menubar from elsewhere thereby activating it. As a result, a menuitem in the menubar is focused.
メニューバーは現在アクティブではなく、ユーザーはフォーカスを他の場所からメニューバーに移動してアクティブにします。 その結果、メニューバーのメニュー項目がフォーカスされます。

	Activate the menubar and fire EVENT_SYSTEM_MENUSTART on the accessible object for the menubar. 	MenuModeStartEvent on the accessible object for the menu. 	AXMenuOpenedNotification
	メニューバーをアクティブにして、メニューバーのアクセス可能なオブジェクトで EVENT_SYSTEM_MENUSTART を発火します。 	メニューのアクセス可能なオブジェクトの MenuModeStartEvent。 	AXMenuOpenedNotification 


Focus a menuitem while menubar is activated, or focus a menuitem in a menu.
メニューバーがアクティブになっているときにメニュー項目にフォーカスするか、メニュー内のメニュー項目にフォーカスします。

	EVENT_OBJECT_FOCUS 	AutomationFocusChangedEvent 	AXMenuItemSelectedNotification


Menu popup made visible (menu is opened).
メニューポップアップが表示されます（メニューが開きます）。

Should only be fired once until the menu is closed and opened again.
メニューを閉じて再度開くまで、1回だけ発火する必要があります。

	EVENT_SYSTEM_MENUPOPUPSTART 	MenuOpenedEvent, then a focus event on a menuitem. 	AXMenuOpenedNotification
	EVENT_SYSTEM_MENUPOPUPSTART 	MenuOpenedEvent、次にメニュー項目のフォーカスイベント。 	AXMenuOpenedNotification


Menu popup hidden (menu is closed). 	EVENT_SYSTEM_MENUPOPUPEND once only for accessible menu object and only if EVENT_SYSTEM_MENUPOPUPSTART was fired for it. 	MenuClosedEvent 	AXMenuClosedNotification
メニューポップアップが非表示になります（メニューが閉じます）。 	EVENT_SYSTEM_MENUPOPUPEND は、アクセス可能なメニューオブジェクトに対して1回だけ、EVENT_SYSTEM_MENUPOPUPSTART が発火された場合にのみ実行されます。 	MenuClosedEvent 	AXMenuClosedNotification


Any open menus are closed including sub-menus, and user moves focus away from the menubar; menubar is deactivated. 	EVENT_SYSTEM_MENUEND on the menubar and deactivate the menubar. 	MenuClosedEvent, then MenuModeEndEvent 	AXMenuClosedNotification
サブメニューを含む開いているメニューはすべて閉じられ、ユーザーはメニューバーからフォーカスを移動します。 メニューバーが非アクティブになります。 	メニューバーで EVENT_SYSTEM_MENUEND を発火し、メニューバーを非アクティブにします。 	MenuClosedEvent、次に MenuModeEndEvent 	AXMenuClosedNotification




6. Special Document Handling Procedures §
6. 特別な文書処理手順 §



6.1 CSS Selectors §
6.1 CSS セレクター §

Note
注

This section might be removed in a future version.
このセクションは、将来のバージョンで取り除かれる可能性があります。

Support for attribute selectors MUST include WAI-ARIA attributes. For example, .fooMenuItem[aria-haspop="true"] would select all elements with class fooMenuItem, and WAI-ARIA property aria-haspopup with value of true. The presentation MUST be updated for dynamic changes to WAI-ARIA attributes. This allows authors to match styling with WAI-ARIA semantics.
属性セレクターのサポートには、WAI-ARIA 属性を含める必要があります（MUST）。 たとえば、.fooMenuItem[aria-haspop="true"] は、クラスが fooMenuItem で、WAI-ARIA プロパティ aria-haspopup の値が true のすべての要素を選択します。 WAI-ARIA 属性の動的に変更に対して、プレゼンテーションを更新する必要があります。 これにより、作成者はスタイリングを WAI-ARIA 意味論と一致させることができます。 




6.2 Author Errors §
6.2 作成者エラー §

In general, user agents do not do much validation of WAI-ARIA properties. User agents MAY do some minor validation on request, such as making sure valid IDs are specified for WAI-ARIA relations, and enforcing things like aria-posinset being within 1 and aria-setsize, inclusive. User agents are not responsible for logical validation, such as the following:
一般に、ユーザーエージェントは WAI-ARIA プロパティの検証をあまり行いません。 ユーザーエージェントは、WAI-ARIA 関係に有効な ID が指定されていることを確認したり、aria-posinset が 1 以内で aria-setsize を含むように強制したりするなど、要求に応じていくつかのマイナーな検証を行うことができます（MAY）。 ユーザーエージェントは、次のような論理的な検証については責任を負いません。

    Circular references created by relations, such as specifying that two elements own each other.
    2つの要素が相互に所有することを指定するなど、関係によって作成された循環参照。

    Correct usage with regard to DOM tree structure, such as an aria-activedescendant being a DOM-descendant of the element with the relation.
    関係を持つ要素の DOM 子孫である aria-activedescendant など、DOM ツリー構造に関する正しい使用法。

    Elements with WAI-ARIA roles correctly implement the behavior of the specified role. For example, user agents do not verify that an element with a role of checkbox actually behaves like a checkbox.
    WAI-ARIA ロールを持つ要素は、指定されたロールの振る舞いを正しく実装します。 たとえば、ユーザーエージェントは、チェックボックスロールを持つ要素が実際にチェックボックスのように振る舞うことを確認しません。

    Elements that do not correctly observe required child / parent role relationships or that appear elsewhere than in their required parent.
    必要な子/親のロールの関係性を正しく観察しない要素、または必要な親以外の場所に表れる要素。

    Determining whether aria-activedescendant actually points to a descendant or another owned element.
    aria-activedescendant が実際に子孫を指しているのか、別の所有要素を指しているのかの判断。

    Determining implicit values of aria-setsize and aria-posinset when they are specified on some but not all the elements of the set.
    セットのすべてではないが一部の要素で指定されている場合の aria-setsize および aria-posinset の暗黙的な値の決定。

If the author specifies a non-numeric value for a decimal or integer value type, the user agent SHOULD do the following:
作成者が10進数値タイプまたは整数値タイプに数値以外の値を指定する場合、ユーザーエージェントは次のことを行うべきです（SHOULD）。

    When asked for the string version of the property, return the string if specified by the author.
    プロパティの文字列バージョンを要求されたら、作成者が指定した場合は文字列を返します。

    When asked for the numeric version:
    数値バージョンを求められた場合：

        Follow the guidance in the Default values for missing required attributes table below, if applicable.
        該当する場合は、以下の「欠落している必須属性のデフォルト値」の表のガイダンスに従ってください。

        Otherwise, return a default value of 0.0 for decimal value types and 0 for integer value types.
        それ以外の場合は、10進値タイプの場合は 0.0、整数値タイプの場合は 0 のデフォルト値を返します。

If a WAI-ARIA property contains an unknown or disallowed value, the user agent SHOULD expose to platform accessibility APIs as follows:
WAI-ARIA プロパティに不明な値または許可されていない値が含まれている場合、ユーザーエージェントは次のようにプラットフォームのアクセシビリティ API に公開するべきです（SHOULD）。

    When exposing as an object attribute, expose the unknown value — do not vet it against possible values.
    オブジェクト属性として公開する場合は、不明な値を公開してください。 可能性のある値と照合しないでください。

    When exposing as a platform API Boolean state:
    プラットフォーム API のブール状態として公開する場合：

        For values of "" (empty string), "undefined" or no attribute present:
        値が "" （空の文字列）、"undefined" 、または属性が存在しない場合：

            Follow the guidance in the Default values for missing required attributes table below, if applicable.
            該当する場合は、以下の「欠落している必須属性のデフォルト値」の表のガイダンスに従ってください。

            Otherwise, treat as false.
            それ以外の場合は、false として扱います。

        Treat any other value as true.
        その他の値はすべて true として扱います。

    Otherwise, ignore the value and treat the property as not present.
    それ以外の場合は、値を無視して、プロパティを存在しないものとして扱います。

Note
注意

In UIA, the user agent might leave the corresponding property set to "unsupported."
UIA では、ユーザーエージェントは、対応するプロパティを「サポートされていない（unsupported）」に設定したままにする場合があります。

User agents MUST NOT expose WAI-ARIA attributes that reference unresolved IDs. For example:
ユーザーエージェントは、未解決の ID を参照する WAI-ARIA 属性を公開してはなりません（MUST NOT）。 例えば：

    When the state or property has only one ID reference that cannot be resolved, treat as if the state or property is not present.
    状態またはプロパティに ID 参照が1つしかなく、それが解決できない場合は、状態またはプロパティが存在しないかのように扱います。

    When the state or property has a list of ID references, ignore any that can't be resolved. If none in the list can be resolved, treat as if the state or property is not present.
    状態またはプロパティに ID 参照のリストがある場合、解決できないものはすべて無視してください。 リストに解決できるものがない場合は、状態またはプロパティが存在しないかのように扱います。

User Agents MUST NOT expose aria-roledescription when:
ユーザーエージェントは、次の場合に aria-roledescription を公開してはなりません（MUST NOT）。

    The element it is applied to has an invalid WAI-ARIA role, or
    適用される要素に無効な WAI-ARIA ロールがある、または

    The element does not have an implicit WAI-ARIA role
    要素には暗黙の WAI-ARIA ロールがない

If a required WAI-ARIA attribute for a given role is missing, user agents SHOULD process the attribute as if the values given in the following table were provided.
特定のロールに必要な WAI-ARIA 属性が欠落している場合、ユーザーエージェントは、次の表に示されている値が提供されているかのように属性を処理するべきです（SHOULD）。


Default values for missing required attributes WAI-ARIA role 	Required Attribute 	Default value
欠落している必須属性のデフォルト値 WAI-ARIA ロール 	必須属性 	デフォルト値


checkbox 	aria-checked 	See aria-checked="false" in State and Property mapping table.
checkbox 	aria-checked 	「状態とプロパティのマッピング表」の aria-checked="false" を参照してください。


menuitem 	aria-haspopup 	See aria-haspopup="false" in State and Property mapping table.
menuitem 	aria-haspopup 	「状態とプロパティのマッピング表」の aria-haspopup="false" を参照してください。


menuitemcheckbox 	aria-checked 	See aria-checked="false" in State and Property mapping table.
menuitemcheckbox 	aria-checked 	「状態とプロパティのマッピング表」の aria-checked="false" を参照してください。


menuitemradio 	aria-checked 	See aria-checked="false" in State and Property mapping table.
menuitemradio 	aria-checked 	「状態とプロパティのマッピング表」の aria-checked="false" を参照してください。


radio 	aria-checked 	See aria-checked="false" in State and Property mapping table.
radio 	aria-checked 	「状態とプロパティのマッピング表」の aria-checked="false" を参照してください。


switch 	aria-checked 	See aria-checked="false" in State and Property mapping table.
switch 	aria-checked 	「状態とプロパティのマッピング表」の aria-checked="false" を参照してください。


combobox 	aria-expanded 	See aria-expanded="false" in State and Property mapping table.
combobox 	aria-expanded 	「状態とプロパティのマッピング」の aria-expanded="false" を参照してください。


combobox 	aria-haspopup 	See aria-haspopup="listbox" in State and Property mapping table.
combobox 	aria-haspopup 	「状態とプロパティのマッピング表」の aria-haspopup="listbox" を参照してください。


heading 	aria-level 	2


scrollbar 	aria-controls 	no mapping
scrollbar 	aria-controls 	マッピングなし


scrollbar 	aria-orientation 	See aria-orientation="vertical" in State and Property mapping table.
scrollbar 	aria-orientation 	「状態とプロパティのマッピング表」の aria-orientation="vertical" を参照してください。


scrollbar 	aria-valuemax 	100


scrollbar 	aria-valuemin 	0


scrollbar 	aria-valuenow 	(aria-valuemax - aria-valuemin) / 2


slider 	aria-valuemax 	100


slider 	aria-valuemin 	0


slider 	aria-valuenow 	(aria-valuemax - aria-valuemin) / 2


spinbutton 	aria-valuemax 	A value indicating that the spinbutton has no upper bound (Accessibility API dependent).
spinbutton 	aria-valuemax 	スピンボタンに上限がないことを示す値（アクセシビリティ API に依存）。


spinbutton 	aria-valuemin 	A value indicating that the spinbutton has no lower bound (Accessibility API dependent).
spinbutton 	aria-valuemin 	スピンボタンに下限がないことを示す値（アクセシビリティ API に依存）。


spinbutton 	aria-valuenow 	0




A. Appendices §
A. 付録 §




A.1 Change Log: substantive changes since the WAI-ARIA 1.0 User Agent Implementation Guide Recommendation §
A.1 変更ログ：「WAI-ARIA 1.0 ユーザーエージェント実装ガイドの勧告」以降の実質的な変更 §

    07-Sep-2017: Add statement to ATK and MSAA/IA2 mappings for aria-owns indicating that user agents MAY modify the accessibility tree as an alternative to using accessible relations.
    2017年9月7日：ユーザーエージェントがアクセス可能な関係を使用する代わりにアクセシビリティツリーを変更できる（MAY）ことを示す、aria-owns の ATK および MSAA / IA2 マッピングにステートメントを追加します。

    04-Sep-2017: Fix AXSubrole for button with aria-pressed defined: Should be AXToggle; not AXToggleButton.
    2017年9月4日：aria-pressed が定義されたボタンの AXSubrole を修正：AXToggle にする必要があります。 AXToggleButton ではありません。

    04-Sep-2017: Fix AXSubrole for tabpanel: Should be AXTabPanel; not TabPanel.
    2017年9月4日：タブパネルの AXSubrole を修正：AXTabPanel にする必要があります。 TabPanel ではありません。

    28-Aug-2017: Remove AXSortButton as an alternative role mapping for columnheader.
    2017年8月28日：columnheader の代替ロールマッピングとして AXSortButton を削除します。

    17-Aug-2017: Remove Localized Landmark Type when it is redundant to the Landmark Type.
    2017年8月17日：ランドマークタイプと重複している場合は、ローカライズされたランドマークタイプを削除します。

    17-Aug-2017: Remove exposure of HTML's href attribute from link role mapping for UIA.
    2017年8月17日：UIA のリンクロールのマッピングから HTML の href 属性の公開を削除します。

    17-Aug-2017: Add TableItem Control Pattern to role=cell mapping.
    2017年8月17日：テーブル項目コントロールパターンを role=cell マッピングに追加します。

    17-Aug-2017: Add Localized Control Type for cell, gridcell, and row.
    2017年8月17日：セル、グリッドセル、および行のローカライズされたコントロールタイプを追加します。

    17-Aug-2017: Fix name of UIA pattern for range roles (should be RangeValue; not Range) and add it to focusable separator.
    2017年8月17日：範囲ロールの UIA パターンの名前を修正し（Range ではなく RangeValue である必要があります）、フォーカス可能なセパレーターに追加します。

    17-Aug-2017: Remove SelectionPattern from list role; add it to listbox role.
    2017年8月17日：リストロールから選択パターンを削除して、リストボックスロールに追加します。

    14-Aug-2017: Fix AXRoleDescription for table role, which should be "table"; not "grid".
    2017年8月14日：テーブルロールの AXRoleDescription を修正しました。 これは "table" である必要があり、"grid" ではありません。

    09-Aug-2017: Add macOS AXValidationError/AXValidationErrorChanged for aria-errormessage.
    2017年8月9日：aria-errormessage の macOS AXValidationError / AXValidationErrorChanged を追加します。

    08-Aug-2017: Remove erroneous statement about not exposing submenus in ATK. Menu items are expected to be contained in menus/submenus; not in other menuitems.
    2017年8月8日：ATK でサブメニューを公開しないことに関する誤ったステートメントを削除します。 メニュー項目は、メニュー/サブメニューに含まれていることが期待されます。 他のメニュー項目にはありません。

    08-Aug-2017: Update UIA mappings for link, term, timer, marquee, alert, cell, and aria-autocomplete.
    2017年8月8日：リンク、用語、タイマー、マーキー、アラート、セル、および aria-autocomplete の UIA マッピングを更新します。

    07-Aug-2017: Update ATK mappings for indeterminate setsize, colcount, and rowcount.
    2017年8月7日：不確定な setsize、colcount、および rowcount の ATK マッピングを更新します。

    04-Aug-2017: Correct IAccessible2 mapping for term role, changing it from ROLE_SYSTEM_LISTITEM to IA2_ROLE_TEXT_FRAME.
    2017年8月4日：用語ロールの IAccessible2 マッピングを修正し、ROLE_SYSTEM_LISTITEM か らIA2_ROLE_TEXT_FRAME に変更しました。

    04-Aug-2017: Correct MSAA mapping for aria-pressed="mixed", changing it from STATE_SYSTEM_PRESSED to STATE_SYSTEM_MIXED.
    2017年8月4日：aria-pressed="mixed" の MSAA マッピングを修正し、STATE_SYSTEM_PRESSED から STATE_SYSTEM_MIXED に変更しました。

    04-Aug-2017: Add MSAA mapping for the switch role.
    2017年8月4日：スイッチロールに MSAA マッピングを追加します。

    02-Aug-2017: Replace STATE_LINKED with STATE_SYSTEM_LINKED for MSAA + IAccessible2 mapping of role link.
    2017年8月2日：リンクロールの MSAA + IAccessible2 マッピングの STATE_LINKED を STATE_SYSTEM_LINKED に置き換えます。

    02-Aug-2017: Change mapping of aria-readonly="false" from exposing ATK_STATE_EDITABLE on textbox to clearing ATK_STATE_READ_ONLY. For aria-readonly="true", add statement that AtkEditableText should not be implemented, and that ATK_STATE_CHECKABLE not be exposed on roles which support aria-checked.
    2017年8月2日：aria-readonly="false" のマッピングを、テキストボックスでの ATK_STATE_EDITABLE の公開から ATK_STATE_READ_ONLY のクリアに変更します。 aria-readonly="true" の場合、AtkEditableText を実装しないこと、および aria-checked をサポートするロールで ATK_STATE_CHECKABLE を公開しないことを示すステートメントを追加します。

    01-Aug-2017: Remove explicit "do not expose STATE_EDITABLE" for roles which are by definition not editable from the ATK mappings.
    2017年8月1日：定義上、ATK マッピングから編集できないロールの明示的な「STATE_EDITABLE を公開しない」を削除します。

    27-Jul-2017: Update aria-orientation defaults and add mappings for aria-orientation with an undefined value.
    2017年7月27日：aria-orientation のデフォルトを更新し、aria-orientation が未定義の値のマッピングを追加します。

    26-Jul-2017: Map definition role to ROLE_DESCRIPTION_VALUE for ATK.
    2017年7月26日：ATK の定義ロールを ROLE_DESCRIPTION_VALUE にマップします。

    21-Jul-2017: Add aria-current mapping to "true" when value is not in list of allowed alues.
    2017年7月21日：値が許可された値のリストにない場合、"true" への aria-current マッピングを追加します。

    20-Jul-2017: Change AXRoleDescription for contentinfo from "content" to "content information".
    2017年7月20日：contentinfoのAXRoleDescription を "content" から "content information" に変更します。

    20-Jul-2017: Change AXRoleDescription for AXCheckBox from "check box" to "checkbox".
    2017年7月20日：AXCheckBox の AXRoleDescription を "check box" から "checkbox" に変更します。

    20-Jul-2017: Add role exposure via xml-roles object attribute for searchbox and switch to ATK mappings.
    2017年7月20日：検索ボックスの xml-roles オブジェクト属性を介してロール公開を追加し、ATK マッピングに切り替えます。

    20-Jul-2017: Correct IA2 mapping for aria-errormessage: It should be IA2_RELATION_ERROR; not IA2_RELATION_ERROR_MESSAGE.
    2017年7月20日：aria-errormessage の正しい IA2 マッピング：IA2_RELATION_ERROR である必要があります。 IA2_RELATION_ERROR_MESSAGE ではありません。

    06-Jul-2017: Remove AXPress action from the macOS mapping of aria-haspopup.
    2017年7月6日：aria-haspopup の macOS マッピングから AXPress アクションを削除します。

    01-May-2017: Changed AX API AXSubrole for role="feed" from "<nil>" to "AXApplicationGroup" and its AXRoleDescription from "group" to "feed".
    2017年5月1日：role="feed" の AXAPIAXSubrole を "<nil>" から "AXApplicationGroup" に変更し、その AXRoleDescription を "group" から "feed" に変更しました。

    28-Apr-2017: Updated AX API AXRole and AXRoleDescription for role="button" where aria-haspoppup is not false. In this instance, the button element should be exposed as AXPopUpButton with a subrole of 'pop up button'.
    2017年4月28日：aria-haspoppup が false ではない role="button" の AX API AXRole および AXRoleDescription を更新しました。 この場合、ボタン要素は 'pop up button' のサブロールを持つ AXPopUpButton として公開する必要があります。

    27-Apr-2017: Updated AX API AXRoleDescription for role="grid" to 'table'. It was formerly 'grid'.
    2017年4月27日：role = "grid"の AXAPIAXRoleDescription を 'table' に更新しました。 以前は 'grid' でした。

    27-Apr-2017: Replaced deprecated AX API accessibilityIsAttributeSettable() with AXUIElementIsAttributeSettable().
    2017年4月27日：非推奨の AX API の accessibilityIsAttributeSettable() を AXUIElementIsAttributeSettable() に置き換えました。

    24-Apr-2017: Changed AX API AXRoleDescription for role="status" from "status" to "application status".
    2017年4月24日：role="status" の AXAPIAXRoleDescription を "status" から "application status" に変更しました。

    13-Apr-2017: Changed AX API AXSubrole for role="group" from "<nil>" to "AXApplicationGroup".
    2017年4月13日：role="group" の AXAPIAXSubrole を "<nil>" から "AXApplicationGroup" に変更しました。

    28-Mar-2017: Changed MSAA/IA2 and ATK/AT-SPI object attribute for aria-current mapping from "active" to "current".
    2017年3月28日：aria-current マッピングの MSAA / IA2 および ATK / AT-SPI オブジェクト属性を "active" から "current" に変更しました。

    20-Mar-2017: Modified AX API AXRoleDescription mappings of roles dialog and alertdialog to be "web dialog" and "web alert dialog", respectively.
    2017年3月20日：ダイアログロールとアラートダイアログロールの AX API AXRoleDescription マッピングを、それぞれ "web dialog" と "web alert dialog" に変更しました。

    14-Mar-2017: Undid the 1.1 addition of RELATION_POPUP_FOR to ATK/AT-SPI mappings of aria-haspopup. While the addition is correct in terms of platform expectations, the ARIA spec provides no means through which user agents could reliably implement this.
    2017年3月14日：aria-haspopup の ATK / AT-SPI マッピングへの RELATION_POPUP_FOR の 1.1 の追加を元に戻しました。 この追加はプラットフォームの期待に関しては正しいものですが、ARIA 仕様は、ユーザーエージェントがこれを確実に実装できる手段を提供していません。

    20-Jan-2017: Added AX API mappings for aria-colcount, aria-colspan, aria-colindex, aria-rowcount, aria-rowindex, and aria-rowspan.
    2017年1月20日：aria-colcount、aria-colspan、aria-colindex、aria-rowcount、aria-rowindex、および aria-rowspan の AX API マッピングが追加されました。

    07-Dec-2016: Added UIA mappings for roles feed, figure, and term, and for aria-colcount, aria-colspan, aria-colindex, aria-rowcount, aria-rowindex, aria-rowspan, and aria-details. Added UIA Range Value Pattern for range related roles scrollbar, slider, and spinbutton.
    2016年12月7日：フィードロール、図ロール、用語ロール、および aria-colcount、aria-colspan、aria-colindex、aria-rowcount、aria-rowindex、aria-rowspan、および aria-details の UIA マッピングが追加されました。 範囲関連のロールのスクロールバー、スライダー、およびスピンボタンに UIA 範囲値パターンを追加しました。

    24-Oct-2016: Changed name of IA2 object property name for aria-placeholder to "placeholder-text" (was "placeholder").
    2016年10月24日：aria-placeholder の IA2 オブジェクトプロパティ名の名前を "placeholder-text"（以前は "placeholder"）に変更しました。

    04-Oct-2016: Add reverse relationships for aria-details and aria-errormessage on platforms MSAA/IA2 and ATK/ATSPI
    2016年10月4日：プラットフォーム MSAA / IA2 および ATK / ATSPI で aria-details および aria-errormessage の逆の関係性を追加します

    03-Oct-2016: Added aria-roledescription mappings for empty and whitespace strings as well as error handling text.
    2016年10月3日：空の文字列と空白文字列の aria-roledescription マッピング、およびエラー処理テキストを追加しました。

    12-Sep-2016: Added RELATION_POPUP_FOR to ATK/AT-SPI mappings of aria-haspopup, for ARIA 1.1. N.B. This change has subsequently been undone. See entry for 14-Mar-2017.
    2016年9月12日：ARIA 1.1 の aria-haspopup の ATK / AT-SPI マッピングに RELATION_POPUP_FOR を追加しました。 N.B. この変更はその後取り消されました。 2017年3月14日のエントリを参照してください。

    08-Sep-2016: Added figure role, term role, feed role, aria-colspan, and aria-rowspan mappings. Updated table properties for row and column for MSAA/IA2 and ATK/AT-SPI. Added MSAA+IA2 and ATK/AT-SPI mappings of aria-details and aria-errormessage.
    2016年9月8日：図ロール、用語ロール、フィードロール、aria-colspan、および aria-rowspan のマッピングが追加されました。 MSAA / IA2 および ATK / AT-SPI の行と列のテーブルプロパティを更新しました。 aria-details および aria-errormessage の MSAA + IA2 および ATK / AT-SPI マッピングを追加しました。

    08-Aug-2016: Modified ATK/AT-SPI mappings of aria-readonly.
    2016年8月8日：aria-readonly の ATK / AT-SPI マッピングを変更しました。

    04-Jul-2016: Added AX API mapping for aria-keyshortcuts.
    2016年7月4日：aria-keyshortcuts の AX API マッピングを追加しました。

    27-Jun-2016: For MSAA+IA2, UIA, and ATK/AT-SPI, modified mappings of role="separator" when it is a window splitter.
    2016年6月27日：MSAA + IA2、UIA、および ATK / AT-SPI の場合、ウィンドウスプリッターの場合の role="separator"のマッピングを変更しました。

    27-Jun-2016: Added ATK/AT-SPI mapping for aria-keyshortcuts.
    2016年6月27日：aria-keyshortcuts の ATK / AT-SPI マッピングを追加しました。

    08-Jun-2016: Removed role text.
    2016年6月8日：テキストロールを削除しました。

    06-Jun-2016: Added MSAA+IA2, UIA, and ATK/AT-SPI mappings for the new values of aria-haspopup added for ARIA 1.1.
    2016年6月6日：ARIA 1.1 に追加された aria-haspopup の新しい値の MSAA + IA2、UIA、および ATK / AT-SPI マッピングが追加されました。

    03-Jun-2016: Added MSAA+IA2 mapping of aria-keyshortcuts.
    2016年6月3日：aria-keyshortcuts の MSAA + IA2 マッピングを追加しました。

    20-May-2016: Added UIA mapping of aria-keyshortcuts.
    2016年5月20日：aria-keyshortcuts の UIA マッピングを追加しました。

    05-May-2016: Updated AX API mapping of role region to reflect its inheritance from the landmark role.
    2016年5月5日：ランドマークロールからの継承を反映するように、リージョンロールの AX API マッピングを更新しました。

    02-May-2016: Modified MSAA+IA2 and ATK/AT-SPI mappings of 'form' role to use IA2_ROLE_LANDMARK and ROLE_LANDMARK, respectively, plus the xml-roles object attribute set to 'form'.
    2016年5月2日：「form」ロールの MSAA + IA2 および ATK / AT-SPI マッピングを変更して、それぞれ IA2_ROLE_LANDMARK および ROLE_LANDMARK を使用し、さらに 'form' に設定された xml-roles オブジェクト属性を使用します。

    11-Apr-2016: Added AX API mappings for aria-modal="true" and aria-modal="false".
    2016年4月11日：aria-modal="true" および aria-modal="false" の AX API マッピングを追加しました。

    11-Apr-2016: For role="application", replaced AX API subrole AXLandmarkAppliction with AXWebAppliction, and role description 'application' with 'web application'.
    2016年4月11日：role="application" の場合、AX API サブロール AXLandmarkAppliction を AXWebAppliction に置き換え、ロールの説明  'application' を 'webapplication' に置き換えました。

    04-Apr-2016: Added new UIA FullDescription property for mapping aria-describedby.
    2016年4月4日：aria-describedby をマッピングするための新しい UIAFullDescription プロパティが追加されました。

    06-May-2016: Added changes for revised values for aria-haspopup for ATK/AT-SPI and MSAA+IA2 along with error handling
    2016年5月6日：エラー処理とともに、ATK / AT-SPI および MSAA + IA2 の aria-haspopup の改訂値の変更を追加しました

    11-Mar-2016: Added details to UIA mappings of radio and menuitemradio roles reqarding how aria-checked values are exposed in the Toggle and SelectionItem patterns; removed aria-describedat from states and properties mapping table.
    2016年3月11日：Toggle および SelectionItem パターンで aria-checked 値がどのように公開されるかを要求する radio および menuitemradio ロールの UIA マッピングに詳細を追加しました。 状態とプロパティのマッピング表から aria-describedat を削除しました。

    10-Mar-2016: Updated default values for aria-valuemin, aria-valuemax, and aria-valuenow for spinbutton role. Default for aria-valuenow is 0 (zero), default for aria-valuemin is no lower bound, and for aria-valuemax, no upper bound.
    2016年3月10日：スピンボタンロールの aria-valuemin、aria-valuemax、および aria-valuenow のデフォルト値を更新しました。 aria-valuenow のデフォルトは 0（ゼロ）、aria-valuemin のデフォルトは下限なし、aria-valuemax のデフォルトは上限なしです。

    07-Mar-2016: Updated all UIA mappings for landmark roles to include Landmark Type and Localized Landmark Type.
    2016年3月7日：ランドマークロールのすべての UIA マッピングを更新して、ランドマークタイプとローカライズされたランドマークタイプを含めました。

    22-Feb-2016: IA2 mapping of role="text" changed to ROLE_SYSTEM_STATICTEXT from IA2_TEXT_FRAME.
    2016年2月22日：role="text" の IA2 マッピングが IA2_TEXT_FRAME から ROLE_SYSTEM_STATICTEXT に変更されました。

    02-Feb-2016: Modified UIA mapping of main role to include a Landmark Type and a Localized Landmark Type. Added UIA mapping for aria-errormessage.
    2016年2月2日：ランドマークタイプとローカライズされたランドマークタイプを含むように、メインロールの UIA マッピングを変更しました。 aria-errormessage の UIA マッピングが追加されました。

    25-Jan-2016: Added AX API mappings for aria-current.
    2016年1月25日：aria-current の AX API マッピングを追加しました。

    15-Jan-2016: Added UIA mappings for aria-current.
    2016年1月15日：aria-current の UIA マッピングを追加しました。

    11-Jan-2016: Modified UIA mapping for roles article and application. Finalized IA2 mapping of aria-current.
    2016年1月11日：ロールの記事とアプリケーションのUIAマッピングを変更しました。 aria-currentのIA2マッピングが完成しました。

    03-Jan-2016: Added UIA mappings for aria-colindex and aria-rowindex. Added placeholders for the other AAPIs.
    2016年1月3日：aria-colindex および aria-rowindex の UIA マッピングを追加しました。 他の AAPI のプレースホルダーを追加しました。

    27-Nov-2015: Added UIA mapping of role="text" as a Text control pattern; and ATK/AT-SPI mapping as ROLE_STATIC.
    2015年11月27日：テキストコントロールパターンとして role="text" の UIA マッピングを追加。 ROLE_STATIC としての ATK / AT-SPI マッピング。

    03-Oct-2015: Modified UIA role mappings of application, banner, complementary, contentinfo, main, search, navigation, article, definition, log, math, and note.
    2015年10月3日：アプリケーション、バナー、補完、コンテンツ情報、メイン、検索、ナビゲーション、記事、定義、ログ、数学、メモの UIA ロールマッピングを変更しました。 

    28-Sep-2015: Added IA2 mapping of role="text".
    2015年9月28日：role="text" の IA2 マッピングを追加しました。

    28-Sep-2015: Removed all MSAA+UIA Express mappings.
    2015年9月28日：すべての MSAA + UIA Express マッピングを削除しました。

    24-Aug-2015: Modified mappings of region role in light of its new status as a landmark.
    2015年8月24日：ランドマークとしての新しいステータスに照らして、リージョンロールのマッピングを変更しました。

    18-Aug-2015: Added mappings of aria-roledescription for MSAA+IA2, UIA, ATK/AT-SPI and AX API.
    2015年8月18日：MSAA + IA2、UIA、ATK / AT-SPI、および AX API の aria-roledescription のマッピングを追加しました。

    31-Jul-2015: Finalized all mappings of aria-placeholder.
    2015年7月31日：aria-placeholder のすべてのマッピングを完了しました。

    02-Jul-2015: Modified default values for missing required attributes table for aria-level with heading role, aria-checked with switch, and aria-valuemin, aria-valuemax, and aria-valuenow with scrollbar, slider, and spinbutton.
    2015年7月2日：見出しロールでの aria-level、スイッチロールでの aria-checked、およびスクロールバーロール、スライダーロール、スピンボタンロールでの aria-valuemin、aria-valuemax、aria-valuenow の「欠落している必須属性のデフォルト値」の表を変更しました。 

    02-Jul-2015: Added special case of switch role to mappings of aria-checked="mixed" and undefined aria-checked.
    2015年7月2日：aria-checked="mixed" と未定義の aria-checked のマッピングにスイッチロールの特別なケースを追加しました。

    25-Jun-2015: ATK/AT-SPI mapping for aria-current.
    2015年6月25日：aria-current の ATK / AT-SPI マッピング。

    16-Jun-2015: Modified MSAA+UIA Express and ATK/AT-SPI mappings of rowgroup role.
    2015年6月16日：行グループロールの MSAA + UIA Express および ATK / AT-SPI マッピングを変更しました。

    15-Jun-2015: Modified MSAA+IA2 mappings of presentation / none roles for required owned descendants.
    2015年6月15日：必要な所有子孫のプレゼンテーション/なしロールの MSAA + IA2 マッピングを変更しました。

    02-Jun-2015: Modified ATK/AT-SPI and UIA mappings of presentation / none roles for required owned descendants.
    2015年6月2日：必要な所有子孫のプレゼンテーション/なしロールの ATK / AT-SPI および UIA マッピングを変更しました。

    02-Jun-2015: MSAA+UIA Express and UIA mappings for aria-placeholder.
    2015年6月2日：aria-placeholder の MSAA + UIA Express および UIA マッピング。

    28-Apr-2015: ATK/AT-SPI mappings for aria-placeholder.
    2015年4月28日：aria-placeholder の ATK / AT-SPI マッピング。

    31-Mar-2015: AX API mappings for aria-owns.
    2015年3月31日：aria-owns の AX API マッピング。

    11-Mar-2015: Mappings for searchbox.
    2015年3月11日：検索ボックスのマッピング。

    04-Mar-2015: Additional mappings for switch.
    2015年3月4日：スイッチの追加マッピング。

    23-Feb-2015: Mappings for presentation / none.
    2015年2月23日：プレゼンテーション/なしのマッピング。

    23-Feb-2015: Mappings for switch.
    2015年2月23日：スイッチのマッピング。

    14-Jan-2015: Mappings for rowgroup.
    2015年1月14日：行グループのマッピング。

    19-Dec-2015: Modify mappings to convey grid role beyond table.
    2015年12月19日：マッピングを変更して、テーブルを超えてグリッドロールを伝えます。

    27-Nov-2014: Added mappings for role text and aria-modal property.
    2014年11月27日：テキストロールと aria-modal プロパティのマッピングを追加しました。

    14-Nov-2014: Fixed mappings of aria-invalid=<unknown value>.
    2014年11月14日：aria-invalid=<unknown value> のマッピングを修正しました。

    11-Nov-2014: Added informative section on relationship between ATK and AT-SPI.
    2014年11月11日：ATK と AT-SPI の関係性に関する情報的なセクションを追加しました。

    03-Nov-2014: Specified UIA mappings of aria-level when used in conjunction with role heading.
    2014年11月3日：見出しロールと組み合わせて使用​​した場合の aria-level の指定された UIA マッピング。

    27-Oct-2014: Moved text alternative computation section to its own document.
    2014年10月27日：テキストの代替計算セクションを独自の文書に移動しました。

    29-Aug-2014: Modified mappings of grid role to differentiate a grid from a table.
    2014年8月29日：グリッドとテーブルを区別するためにグリッドロールのマッピングを変更しました。

    05-Jun-2014: Modified ATK/AT-SPI mappings for article, checkbox, menuitemcheckbox, menuitemradio, and aria-checked.
    2014年6月5日：記事、チェックボックス、メニュー項目チェックボックス、メニュー項目ラジオボタン、および aria-checked の ATK / AT-SPI マッピングを変更しました。

    30-May-2014: Modified ATK/AT-SPI mappings for focus event, banner, listbox, log, marquee, math, navigation, note, radiogroup, row, timer, and treeitem.
    2014年5月30日：フォーカスイベント、バナー、リストボックス、ログ、マーキー、数学、ナビゲーション、メモ、ラジオグループ、行、タイマー、ツリー項目の ATK / AT-SPI マッピングを変更しました。

    21-May-2014: Added additional AX API mapping for aria-busy.
    2014年5月21日：aria-busy 用の追加の AX API マッピングを追加しました。

    15-May-2014: Provided IA2 and ATK/AT-SPI mappings of aria-pressed and tablist.
    2014年5月15日：aria-pressed および tablist の IA2 および ATK / AT-SPI マッピングを提供しました。

    15-May-2014: Change AX API mapping for aria-busy.
    2014年5月15日：aria-busy の AX API マッピングを変更します。

    25-March-2014: Added text to Group Position section about computing implicit level information for a tree.
    2014年3月25日：ツリーの暗黙的なレベル情報の計算に関するテキストを「グループ位置」セクションに追加しました。

    24-March-2014: Updated mapping of aria-hidden=true to indicate that user agents should not expose unless the accessible object is focused or fires an accessibility event.
    2014年3月24日：aria-hidden=true のマッピングを更新して、アクセス可能なオブジェクトがフォーカスされるか、アクセシビリティイベントを発火させない限り、ユーザーエージェントが公開しないように指示しました。

    21-March-2014: Added back UIA columns to all mapping tables that were removed after the 1.0 Candidate Recommendation.
    2014年3月21日：1.0 勧告候補の後に UIA 列が削除されたすべてのマッピングテーブルに UIA 列を再び追加しました。 





A.2 Acknowledgments §
A.2 謝辞 §

This section is non-normative.
このセクションは非規範的です。

The following people contributed to the development of this document.
以下の人々がこの文書の作成に貢献しました。 




A.2.1 Participants active in the ARIA WG at the time of publication §
A.2.1 発行時に ARIA WG で活動している参加者 §

    Ann Abbott (IBM Corporation)

    Irfan Ali (Educational Testing Service)

    Amelia Bellamy-Royds (Invited Expert)

    Michiel Bijl (Invited Expert)

    Christy Blew (University of Illinois at Urbana-Champaign)

    David Bolter (Mozilla Foundation)

    Bogdan Brinza (Microsoft Corporation)

    Michael Cooper (W3C/MIT)

    James Craig (Apple Inc.)

    Joanmarie Diggs (Igalia)

    Steve Faulkner (The Paciello Group, LLC)

    John Foliot (Deque Systems, Inc.)

    Bryan Garaventa (SSB BART Group)

    Matt Garrish (DAISY Consortium)

    Jon Gunderson (University of Illinois at Urbana-Champaign)

    Markus Gylling (DAISY Consortium)

    Markku Hakkinen (Educational Testing Service)

    Matthew King (Facebook)

    JaEun Jemma Ku (University of Illinois at Urbana-Champaign)

    Dominic Mazzoni (Google, Inc.)

    Shane McCarron (Invited Expert, Aptest)

    James Nurthen (Oracle Corporation)

    Ian Pouncey (The Paciello Group, LLC)

    Janina Sajka (Invited Expert, The Linux Foundation)

    Joseph Scheuhammer (Invited Expert, Inclusive Design Research Centre, OCAD University)

    Stefan Schnabel (SAP SE)

    Richard Schwerdtfeger (Knowbility)

    Lisa Seeman-Kestenbaum (Invited Expert)

    Tzviya Siegman (Wiley)

    Alexander Surkov (Mozilla Foundation)

    Job van Achterberg (Invited Expert)

    Léonie Watson (The Paciello Group, LLC)

    Evan Yamanishi (W. W. Norton)

    Jason White (Educational Testing Service)





A.2.2 Other ARIA contributors, commenters, and previously active participants §
A.2.2 その他の ARIA 寄稿者、コメント投稿者、および以前にアクティブだった参加者 §

    Shadi Abou-Zahra (W3C)

    Jim Allan (TSB)

    Jonny Axelsson (Opera Software)

    David Baron (Mozilla Foundation)

    Art Barstow (Nokia Corporation)

    Simon Bates

    Chris Blouch (AOL)

    Judy Brewer (W3C/MIT)

    Mark Birbeck (Sidewinder Labs)

    Sally Cain (Royal National Institute of Blind People (RNIB))

    Gerardo Capiel (Benetech)

    Ben Caldwell (Trace)

    Sofia Celic-Li

    Jaesik Chang (Samsung Electronics Co., Ltd.)

    Alex Qiang Chen (University of Manchester)

    Charles Chen (Google, Inc.)

    Christian Cohrs

    Deborah Dahl

    Erik Dahlström (Opera Software)

    Dimitar Denev (Frauenhofer Gesellschaft)

    Micah Dubinko (Invited Expert)

    Mandana Eibegger

    Beth Epperson (Websense)

    Fred Esch (IBM Corporation)

    Donald Evans (AOL)

    Chris Fleizach (Apple Inc.)

    Kelly Ford (Microsoft Corporation)

    Geoff Freed (Invited Expert, NCAM)

    Christopher Gallelo (Microsoft Corporation)

    Billy Gregory (The Paciello Group, LLC)

    Karl Groves (The Paciello Group, LLC)

    Birkir Gunnarsson (Deque Systems, Inc.)

    Kentarou Fukuda (IBM Corporation)

    Bryan Garaventa

    Guido Geloso

    Ali Ghassemi

    Becky Gibson (IBM)

    Alfred S. Gilman

    Andres Gonzalez (Adobe Systems Inc.)

    Scott González (JQuery Foundation)

    James Graham

    Georgios Grigoriadis (SAP AG)

    Jeff Grimes (Oracle)

    Loretta Guarino Reid (Google, Inc.)

    Katie Haritos-Shea (Knowbility)

    Barbara Hartel

    James Hawkins (Google, Inc.)

    Benjamin Hawkes-Lewis

    Sean Hayes (Microsoft Corporation)

    Mona Heath (University of Illinois at Urbana-Champaign)

    Jan Heck

    Shawn Henry

    Tina Homboe

    Nicholas Hoyt

    John Hrvatin (Microsoft Corporation)

    Takahiro Inada

    Masayasu Ishikawa (W3C)

    Jim Jewitt

    Kenny Johar (Microsoft Corporation)

    Shilpi Kapoor (BarrierBreak Technologies)

    Masahiko Kaneko (Microsoft Corporation)

    Marjolein Katsma

    Susann Keohane (IBM Corporation)

    George Kerscher (International Digital Publishing Forum)

    Jason Kiss (Department of Internal Affairs, New Zealand Government)

    Todd Kloots

    Jamie Knight (British Broadcasting Corporation)

    Johannes Koch

    Gerard K. Cohen

    Sam Kuper

    Earl Johnson (Sun)

    Jael Kurz

    Rajesh Lal (Nokia Corporation)

    Diego La Monica (International Webmasters Association / HTML Writers Guild (IWA-HWG))

    Aaron Leventhal (IBM Corporation)

    Gez Lemon (International Webmasters Association / HTML Writers Guild (IWA-HWG))

    Alex Li (SAP)

    Chris Lilley

    Thomas Logan (HiSoftware Inc.)

    Brian Loh

    William Loughborough (Invited Expert)

    Linda Mao (Microsoft)

    David MacDonald (Invited Expert, CanAdapt Solutions Inc.)

    Carolyn MacLeod

    Anders Markussen (Opera Software)

    Krzysztof Maczyński

    Matthew May (Adobe Systems Inc.)

    Mark McCarthy

    Charles McCathie Nevile (Yandex)

    Mary Jo Mueller (IBM Corporation)

    Alexandre Morgaut (4D)

    Ann Navarro (Invited Expert)

    Joshue O Connor (Invited Expert, CFIT)

    Artur Ortega (Microsoft Corporation)

    Sailesh Panchang (Deque)

    Lisa Pappas (Society for Technical Communication (STC))

    Marta Pawlowlska (Samsung Electronics Co., Ltd.)

    Dave Pawson (RNIB)

    Steven Pemberton (CWI Amsterdam)

    Simon Pieters (Opera Software)

    Jean-Bernard Piot (4D)

    David Poehlman, Simon Pieters (Opera Software)

    Sarah Pulis (Media Access Australia)

    T.V. Raman (Google, Inc.)

    Jan Richards

    Gregory Rosmaita (Invited Expert)

    Tony Ross (Microsoft Corporation)

    Alex Russell (Dojo Foundation) (

    Mark Sadecki (Invited Expert)

    Mario Sánchez Prada (Samsung Electronics Co., Ltd. and Gnome Foundation)

    Martin Schaus (SAP AG)

    Doug Schepers (W3C)

    Cynthia Shelly (Microsoft Corporation)

    Matthias Schmitt

    Marc Silbey (Microsoft Corporation)

    Leif Halvard Sili

    Henri Sivonen (Mozilla)

    Michael Smith (W3C)

    Andi Snow-Weaver (IBM Corporation)

    Ville Skyttä

    Henny Swan (BBC)

    Neil Soiffer (Design Science)

    Vitaly Sourikov

    Mike Squillace (IBM)

    Maciej Stachowiak (Apple Inc.)

    Christophe Strobbe

    Suzanne Taylor (Pearson plc)

    Terrill Thompson

    David Todd

    Gregg Vanderheiden (Invited Expert, Trace)

    Anne van Kesteren

    Wen He (Tencent)

    Wu Wei (W3C / RITT)

    Ryan Williams (Oracle)

    Tom Wlodkowski

    Sam White (Apple Inc.)

    Marco Zehe (Mozilla Foundation)

    Gottfried Zimmermann (Invited Expert, Access Technologies Group)




A.2.3 Enabling funders §
A.2.3 可能にする資金提供者

This publication has been funded in part with U.S. Federal funds from the Department of Education, National Institute on Disability, Independent Living, and Rehabilitation Research (NIDILRR), initially under contract number ED-OSE-10-C-0067 and currently under contract number HHSP23301500054C. The content of this publication does not necessarily reflect the views or policies of the U.S. Department of Education, nor does mention of trade names, commercial products, or organizations imply endorsement by the U.S. Government.
この出版物は、教育省、国立障害者、自立生活、およびリハビリテーション研究所（NIDILRR）からの米国連邦資金によって部分的に資金提供されており、当初は契約番号 ED-OSE-10-C-0067 で、現在は契約番号 HHSP23301500054C で提供されています。 この出版物の内容は、必ずしも米国教育省の見解や方針を反映しているわけではなく、商号、商品、または組織についての言及は、米国政府による承認を意味するものでもありません。




B. References §
B. 参考文献 §




B.1 Normative references §
B.1 規範的な参考文献 §

[RFC2119]

    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 

[wai-aria-1.1]

    Accessible Rich Internet Applications (WAI-ARIA) 1.1. Joanmarie Diggs; Shane McCarron; Michael Cooper; Richard Schwerdtfeger; James Craig. W3C. 14 December 2017. W3C Recommendation. URL: https://www.w3.org/TR/wai-aria-1.1/ 

[wai-aria-implementation-1.0]

    WAI-ARIA 1.0 User Agent Implementation Guide. Joseph Scheuhammer; Michael Cooper. W3C. 20 March 2014. W3C Recommendation. URL: https://www.w3.org/TR/wai-aria-implementation/ 





B.2 Informative references §
B.2 情報的な参考文献 §

[accname-aam-1.1]

    Accessible Name and Description: Computation and API Mappings 1.1. Joseph Scheuhammer; James Craig; Andi Snow-Weaver; Aaron Leventhal. W3C. 17 March 2016. W3C Working Draft. URL: https://www.w3.org/TR/accname-aam-1.1/ 
    Accessible Name and Description Computation 1.1 [accname-1.1]（訳注：文書名や内容が変更されていて、この文書と整合性が取れていない）

[AT-SPI]

    Assistive Technology Service Provider Interface. The GNOME Project. URL: https://developer.gnome.org/libatspi/stable/ 

[ATK]

    ATK - Accessibility Toolkit. The GNOME Project. URL: https://developer.gnome.org/atk/stable/ 

[AXAPI]

    The NSAccessibility Protocol for macOS. Apple, Inc. URL: https://developer.apple.com/documentation/appkit/nsaccessibility 

[core-aam-1.1]

    Core Accessibility API Mappings 1.1. Joanmarie Diggs; Joseph Scheuhammer; Richard Schwerdtfeger; Michael Cooper; Andi Snow-Weaver; Aaron Leventhal. W3C. 14 December 2017. W3C Recommendation. URL: https://www.w3.org/TR/core-aam-1.1/ 

[html5]

    HTML5. Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Theresa O'Connor; Silvia Pfeiffer. W3C. 28 October 2014. W3C Recommendation. URL: https://www.w3.org/TR/html5/ 

[IAccessible2]

    IAccessible2. Linux Foundation. URL: https://www.linuxfoundation.org/collaborate/workgroups/accessibility/iaccessible2 

[MSAA]

    Microsoft Active Accessibility (MSAA) 2.0. Microsoft Corporation. URL: https://msdn.microsoft.com/en-us/library/ms697707.aspx 

[UAAG10]

    User Agent Accessibility Guidelines 1.0. Ian Jacobs; Jon Gunderson; Eric Hansen. W3C. 17 December 2002. W3C Recommendation. URL: https://www.w3.org/TR/UAAG10/ 

[UI-AUTOMATION]

    UI Automation. Microsoft Corporation. URL: https://msdn.microsoft.com/en-us/library/ee684009%28v=vs.85%29.aspx 

[UIA-EXPRESS]

    The IAccessibleEx Interface. Microsoft Corporation. URL: https://msdn.microsoft.com/en-us/library/windows/desktop/dd561898%28v=vs.85%29.aspx 

[wai-aria-practices-1.1]

    WAI-ARIA Authoring Practices 1.1. Matthew King; James Nurthen; Michiel Bijl; Michael Cooper; Joseph Scheuhammer; Lisa Pappas; Richard Schwerdtfeger. W3C. 14 December 2017. W3C Note. URL: https://www.w3.org/TR/wai-aria-practices-1.1/ 

[wai-aria-roadmap]

    Roadmap for Accessible Rich Internet Applications (WAI-ARIA Roadmap). Richard Schwerdtfeger. W3C. 4 February 2008. W3C Working Draft. URL: https://www.w3.org/TR/wai-aria-roadmap/ 

[WCAG20]

    Web Content Accessibility Guidelines (WCAG) 2.0. Ben Caldwell; Michael Cooper; Loretta Guarino Reid; Gregg Vanderheiden et al. W3C. 11 December 2008. W3C Recommendation. URL: https://www.w3.org/TR/WCAG20/ 

↑
