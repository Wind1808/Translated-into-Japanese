（訳注：
英単語で表記すべき所もほとんどを日本語に翻訳して、英単語は必要と思われる所でカッコ内に示しています。
ただし、キーボードに関しては、キーに書かれた英単語を優先しています。
）

W3C

WAI-ARIA Authoring Practices 1.1
WAI-ARIA の著作の実践 1.1

W3C Working Group Note 14 August 2019
W3C ワーキンググループノート 2019年8月14日

This version:
このバージョン：

    https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/ 

Latest published version:
最新の公開バージョン：

    https://www.w3.org/TR/wai-aria-practices-1.1/ 

Latest editor's draft:
最新の編集者の下書き：

    https://w3c.github.io/aria-practices/

Previous version:
前のバージョン：

    https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190207/

Editors:
編集者：

    Matt King (Facebook) 

    JaEun Jemma Ku (University of Illinois) 

    James Nurthen (Adobe) 

    Zoë Bijl (Invited Expert) 

    Michael Cooper (W3C) 

Former editors:
元編集者：

    Joseph Scheuhammer (Inclusive Design Research Centre, OCAD University) (Editor until October 2014)

    Lisa Pappas (SAS) (Editor until October 2009)

    Rich Schwerdtfeger (IBM Corporation) (Editor until October 2014)

Copyright © 2015-2019 W3C® (MIT, ERCIM, Keio, Beihang). W3C liability, trademark and permissive document license rules apply.
Copyright © 2015-2019 W3C®（MIT、ERCIM、慶應義塾大学、北京航空航天大学）。 W3C の責任、商標、および寛容な文書ライセンス規則が適用されます。



Abstract
概要

This document provides readers with an understanding of how to use WAI-ARIA 1.1 [WAI-ARIA] to create accessible rich internet applications. It describes considerations that might not be evident to most authors from the WAI-ARIA specification alone and recommends approaches to make widgets, navigation, and behaviors accessible using WAI-ARIA roles, states, and properties. This document is directed primarily to Web application developers, but the guidance is also useful for user agent and assistive technology developers.
この文書は、WAI-ARIA 1.1 [WAI-ARIA] を使用してアクセス可能なリッチインターネットアプリケーションを作成する方法を読者に理解してもらうためのものです。  WAI-ARIA 仕様だけではほとんどの作成者には明らかではないかもしれない考慮事項について説明し、WAI-ARIA のロール（roles、役割）、状態（states）、およびプロパティ（properties）を使用してウィジェット、ナビゲーション、および振る舞いをアクセス可能にするアプローチを推奨します。 この文書は主にウェブアプリケーション開発者を対象としていますが、ガイダンスはユーザーエージェントおよび支援技術開発者にも役立ちます。

This document is part of the WAI-ARIA suite described in the WAI-ARIA Overview.
この文書は、WAI-ARIA の概要で説明されている WAI-ARIA スイートの一部です。




Status of This Document
この文書のステータス

This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the W3C technical reports index at https://www.w3.org/TR/.
このセクションでは、発行時のこの文書のステータスについて説明します。 他の文書がこの文書に取って代わる場合があります。 現在の W3C 出版物のリストとこのテクニカルレポートの最新リビジョンは、https://www.w3.org/TR/ の W3C テクニカルレポートインデックスにあります。


This is the WAI-ARIA Authoring Practices 1.1 Working Group Note by the Accessible Rich Internet Applications Working Group. It supports the Accessible Rich Internet Applications 1.1 W3C Recommendation [wai-aria-1.1], providing detailed advice and examples beyond what would be appropriate to a technical specification but which are important to understand the specification.
これは、アクセス可能なリッチインターネットアプリケーションのワーキンググループ（Accessible Rich Internet Applications Working Group）による WAI-ARIA の著作の実践 1.1 のワーキンググループノート （WAI-ARIA Authoring Practices 1.1 Working Group Note）です。 これは、アクセス可能なリッチインターネットアプリケーション 1.1 W3C 勧告（Accessible Rich Internet Applications 1.1 W3C Recommendation） [wai-aria-1.1] をサポートし、技術仕様に適切であるが仕様を理解するために重要なものを超えた詳細なアドバイスと例を提供します。

WAI-ARIA Authoring Practices 1.1 was previously published as a Working Group Note in December 2017, to accompany the WAI-ARIA 1.1 Recommendation, and was republished in July 2018 and February 2019 with additional design pattern and examples, quality improvements, and improveed support for WAI-ARIA 1.1. Details of changes are described in the change log. Separately, WAI-ARIA Authoring Practices 1.2 includes the improvements in this document plus additional features specific to WAI-ARIA 1.2.
WAI-ARIA の著作の実践 1.1 は、WAI-ARIA 1.1 勧告に付随して、2017年12月にワーキンググループノートとして以前に発行され、2018年7月と2019年2月に再発行され、追加のデザインパターンと例、品質の改善、WAI-ARIA 1.1 のサポートの改善が行われました。 変更の詳細は、変更ログに記載されています。 これとは別に、WAI-ARIA の著作の実践 1.2 には、この文書の改善点に加えて、WAI-ARIA 1.2 に固有の追加機能が含まれています。

To comment, file an issue in the W3C ARIA Practices GitHub repository, or if that is not possible, send email to public-aria@w3.org (comment archive).
コメントするには、W3C ARIA Practices GitHub リポジトリーに問題を提出するか、それが不可能な場合は、public-aria@w3.org（コメントアーカイブ）に電子メールを送信してください。

This document was published by the Accessible Rich Internet Applications Working Group as a Working Group Note.
この文書は、Accessible Rich Internet Applications ワーキンググループによってワーキンググループノートとして公開されました。

Comments regarding this document are welcome. Please send them to public-aria@w3.org (archives).
この文書に関するコメントは大歓迎です。 それらを public-aria@w3.org（アーカイブ）に送ってください。

Publication as a Working Group Note does not imply endorsement by the W3C Membership. This is a draft document and may be updated, replaced or obsoleted by other documents at any time. It is inappropriate to cite this document as other than work in progress.
ワーキンググループノートとしての発行は、W3C メンバーシップによる承認を意味するものではありません。 これはドラフト文書であり、いつでも他の文書によって更新、置換、または廃止される可能性があります。 この文書を進行中の作業以外のものとして引用することは不適切です。

This document was produced by a group operating under the W3C Patent Policy.
この文書は、W3C 特許ポリシーに基づいて運営されているグループによって作成されました。

This document is governed by the 1 March 2019 W3C Process Document.
この文書は、2019年3月1日の W3C プロセス文書に準拠しています。




Table of Contents
目次

    1.

    Introduction
    序文

    2.

    Read Me First
    最初に私を読んでください

        2.1

        No ARIA is better than Bad ARIA
        ARIA なしは悪い ARIA よりも優れています

        2.2

        Browser and Assistive Technology Support
        ブラウザーと支援技術のサポート

        2.3

        Mobile and Touch Support
        モバイルとタッチのサポート

    3.

    Design Patterns and Widgets
    デザインパターンとウィジェット

        3.1

        Accordion (Sections With Show/Hide Functionality)
        アコーディオン（表示/非表示機能のあるセクション）

        3.2

        Alert
        アラート

        3.3

        Alert and Message Dialogs
        アラートとメッセージのダイアログ

        3.4

        Breadcrumb
        パンくずリスト

        3.5

        Button
        ボタン

        3.6

        Carousel (Slide Show or Image Rotator)
        カルーセル（スライドショーまたはイメージローテーター）

        3.7

        Checkbox
        チェックボックス

        3.8

        Combo Box
        コンボボックス

        3.9

        Dialog (Modal)
        ダイアログ（モーダル）

        3.10

        Disclosure (Show/Hide)
        開示（表示/非表示）

        3.11

        Feed
        フィード

        3.12

        Grids : Interactive Tabular Data and Layout Containers
        グリッド：インタラクティブな表形式データとレイアウトコンテナー

        3.13

        Link
        リンク

        3.14

        Listbox
        リストボックス

        3.15

        Menu or Menu bar
        メニューやメニューバー

        3.16

        Menu Button
        メニューボタン

        3.17

        Radio Group
        ラジオグループ

        3.18

        Slider
        スライダー

        3.19

        Slider (Multi-Thumb)
        スライダー（複数つまみ）

        3.20

        Spinbutton
        スピンボタン

        3.21

        Table
        テーブル

        3.22

        Tabs
        タブ

        3.23

        Toolbar
        ツールバー

        3.24

        Tooltip Widget
        ツールチップウィジェット

        3.25

        Tree View
        ツリービュー

        3.26

        Treegrid
        ツリーグリッド

        3.27

        Window Splitter
        ウィンドウスプリッター

    4.

    Landmark Regions
    ランドマークリージョン

        4.1

        HTML Sectioning Elements
        HTML セクショニング要素

        4.2

        General Principles of Landmark Design
        ランドマークデザインの一般原則

        4.3

        Landmark Roles
        ランドマークのロール

            4.3.1

            Banner
            バナー

            4.3.2

            Complementary
            補足

            4.3.3

            Contentinfo
            コンテンツ情報

            4.3.4

            Form
            フォーム

            4.3.5

            Main
            メイン

            4.3.6

            Navigation
            ナビゲーション

            4.3.7

            Region
            リージョン

            4.3.8

            Search
            サーチ

    5.

    Providing Accessible Names and Descriptions
    アクセス可能な名前と説明の提供

        5.1

        What ARE Accessible Names and Descriptions?
        アクセス可能な名前と説明とは何ですか？

        5.2

        How Are Name and Description Strings Derived?
        名前と説明の文字列はどのように導き出されますか？

        5.3

        Accessible Names
        アクセス可能な名前

            5.3.1

            Cardinal Rules of Naming
            命名の基本的なルール

                5.3.1.1

                Rule 1: Heed Warnings and Test Thoroughly
                ルール1：警告に留意し、徹底的にテストする

                5.3.1.2

                Rule 2: Prefer Visible Text
                ルール2：可視テキストを優先する

                5.3.1.3

                Rule 3: Prefer Native Techniques
                ルール3：ネイティブな手法を優先する

                5.3.1.4

                Rule 4: Avoid Browser Fallback
                ルール4：ブラウザーのフォールバックを回避する

                5.3.1.5

                Rule 5: Compose Brief, Useful Names
                ルール5：簡潔で便利な名前を作成する

            5.3.2

            Naming Techniques
            命名手法

                5.3.2.1

                Naming with Child Content
                子コンテンツによる命名

                5.3.2.2

                Naming with a String Attribute Via aria-label
                aria-label を介した文字列属性による命名

                5.3.2.3

                Naming with Referenced Content Via aria-labelledby
                aria-labelledby を介した参照コンテンツによる命名

                5.3.2.4

                Naming Form Controls with the Label Element
                ラベル要素によるフォームコントロールの命名

                5.3.2.5

                Naming Fieldsets with the Legend Element
                凡例要素によるフィールドセットの命名

                5.3.2.6

                Naming Tables and Figures with Captions
                キャプションによるテーブルと図の命名

                5.3.2.7

                Fallback Names Derived from Titles and Placeholders
                タイトルとプレースホルダーから導き出されたフォールバック名

            5.3.3

            Composing Effective and User-friendly Accessible Names
            効果的でユーザーフレンドリーなアクセス可能な名前の構成

            5.3.4

            Accessible Name Guidance by Role
            ロール別のアクセス可能な名前ガイダンス

            5.3.5

            Accessible name calculation
            アクセス可能な名前の計算

                5.3.5.1

                Examples of non-recursive accessible name calculation
                非再帰的なアクセス可能な名前の計算の例

                5.3.5.2

                Examples of recursive accessible name calculation
                再帰的なアクセス可能な名前の計算の例

        5.4

        Accessible Descriptions
        アクセス可能な説明

            5.4.1

            Describing Techniques
            説明手法

                5.4.1.1

                Describing by referencing content with aria-describedby
                aria-describedby でコンテンツを参照することによる説明

                5.4.1.2

                Describing Tables and Figures with Captions
                キャプションによるテーブルと図の説明

                5.4.1.3

                Descriptions Derived from Titles
                タイトルから導き出された説明

            5.4.2

            Accessible description calculation
            アクセス可能な説明の計算

    6.

    Developing a Keyboard Interface
    キーボードインターフェースの開発

        6.1

        Fundamental Keyboard Navigation Conventions
        基本的なキーボードナビゲーション規則

        6.2

        Discernible and Predictable Keyboard Focus
        識別可能で予測可能なキーボードフォーカス

        6.3

        Focus VS Selection and the Perception of Dual Focus
        フォーカス VS 選択とデュアルフォーカスの認識

        6.4

        Deciding When to Make Selection Automatically Follow Focus
        フォーカスに従って自動的に選択を行うかの決定

        6.5

        Keyboard Navigation Between Components (The Tab Sequence)
        コンポーネント間のキーボードナビゲーション（タブシーケンス）

        6.6

        Keyboard Navigation Inside Components
        コンポーネント内のキーボードナビゲーション

            6.6.1

            Managing Focus Within Components Using a Roving tabindex
            動き回るタブインデックスを使用したコンポーネント内のフォーカスの管理

            6.6.2

            Managing Focus in Composites Using aria-activedescendant
            aria-activedescendant を使用した複合ウィジェットでのフォーカスの管理

        6.7

        Focusability of disabled controls
        無効化されたコントロールのフォーカス可能性

        6.8

        Key Assignment Conventions for Common Functions
        共通機能のキー割り当て規則

        6.9

        Keyboard Shortcuts
        キーボードショートカット

            6.9.1

            Designing the Scope and Behavior of Keyboard Shortcuts
            キーボードショートカットの範囲と振る舞いの設計

                6.9.1.1

                Ensure Basic Access Via Navigation
                ナビゲーションによる基本的なアクセスの確保

                6.9.1.2

                Choose Appropriate Shortcut Behavior
                適切なショートカットの振る舞いを選択する

                6.9.1.3

                Choose Where to Add Shortcuts 
                ショートカットを追加する場所を選択する

            6.9.2

            Assigning Keyboard Shortcuts
            キーボードショートカットの割り当て

                6.9.2.1

                Operating System Key Conflicts
                オペレーティングシステムのキーの競合

                6.9.2.2

                Assistive Technology Key Conflicts
                支援技術のキーの競合

                6.9.2.3

                Browser Key Conflicts
                ブラウザーのキーの競合

                6.9.2.4

                Intentional Key Conflicts
                意図的なキーの競合

    7.

    Grid and Table Properties
    グリッドとテーブルのプロパティ

        7.1

        Using aria-rowcount and aria-rowindex
        aria-rowcount と aria-rowindex の使用

        7.2

        Using aria-colcount and aria-colindex
        aria-colcount と aria-colindex の使用

            7.2.1

            Using aria-colindex When Column Indices Are Contiguous
            列インデックスが連続している場合の aria-colinde xの使用

            7.2.2

            Using aria-colindex When Column Indices Are Not Contiguous
            列インデックスが連続していない場合の aria-colindex の使用

        7.3

        Defining cell spans using aria-colspan and aria-rowspan
        aria-colspan および aria-rowspan を使用したセルスパンの定義

        7.4

        Indicating sort order with aria-sort
        aria-sort で並べ替え順を示す

    8.

    Intentionally Hiding Semantics with the presentation Role
    プレゼンテーションロールで意味論を意図的に隠す

        8.1

        Effects of Role presentation
        プレゼンテーションロールの効果

        8.2

        Conditions That Cause Role presentation to be Ignored
        プレゼンテーションロールが無視される原因となる条件

        8.3

        Example Demonstrating Effects of the presentation Role 
        プレゼンテーションロールの効果を示す例

    9.

    Roles That Automatically Hide Semantics by Making Their Descendants Presentational
    子孫をプレゼンテーション化することによって意味論を自動的に隠すロール

    A.

    Indexes
    インデックス

    B.

    Change History
    変更履歴

        B.1

        Changes in July 2019 Publication of Note Release 4
        2019年7月の変更点ノートリリース4の発行

        B.2

        Changes in January 2019 Publication of Note Release 3
        2019年1月の変更点ノートリリース3の発行

        B.3

        Changes in July 2018 Publication of Note Release 2
        2018年7月の変更点ノートリリース2の発行

        B.4

        Changes in December 2017 Publication as Note
        2017年12月発行の変更点

        B.5

        Changes in June 2017 Working Draft
        2017年6月のワーキングドラフトの変更

    C.

    Acknowledgements
    謝辞

        C.1

        Major Contributors to Version 1.1
        バージョン 1.1 の主な貢献者

        C.2

        Participants active in the ARIA Authoring Practices Task Force
        ARIA の著作の実践のタスクフォースで活動している参加者

        C.3

        Other commenters and contributors to Version 1.1
        バージョン 1.1 のその他のコメント投稿者および寄稿者

        C.4

        Enabling funders
        資金提供者の有効化

    D.

    References
    参考文献

        D.1

        Informative references
        有益な参考文献





1. Introduction
1. 序文

This section is informative.
このセクションは参考情報となります。

WAI-ARIA Authoring Practices is a guide for understanding how to use WAI-ARIA 1.1 to create an accessible Rich Internet Application. It provides guidance on the appropriate application of WAI-ARIA, describes recommended WAI-ARIA usage patterns, and explains concepts behind them.
WAI-ARIA の著作の実践は、WAI-ARIA 1.1 を使用してアクセス可能なリッチインターネットアプリケーションを作成する方法を理解するためのガイドです。 WAI-ARIA の適切なアプリケーションに関するガイダンスを提供し、推奨される WAI-ARIA の使用パターンを説明し、その背後にある概念を説明します。

Languages used to create rich and dynamic web sites, e.g., HTML, JavaScript, CSS, and SVG, do not natively include all the features required to make sites usable by people who use assistive technologies (AT) or who rely on keyboard navigation. The W3C Web Accessibility Initiative's (WAI) Accessible Rich Internet Applications working group (ARIA WG) is addressing these deficiencies through several W3C standards efforts. The WAI-ARIA Overview provides additional background on WAI-ARIA, summarizes those efforts, and lists the other documents included in the WAI-ARIA suite.
HTML、JavaScript、CSS、SVG などのリッチで動的なウェブサイトの作成に使用される言語には、支援技術（assistive technologies、AT）を使用するユーザーやキーボードナビゲーションに依存するユーザーがサイトを使用できるようにするために必要なすべての機能がネイティブに含まれているわけではありません。 W3C ウェブアクセシビリティイニシアチブ（W3C Web Accessibility Initiative、WAI）のアクセス可能なリッチインターネットアプリケーションのワーキンググループ（Accessible Rich Internet Applications working group、ARIA WG）は、いくつかの W3C 標準の取り組みを通じてこれらの欠陥に取り組んでいます。 WAI-ARIA の概要（WAI-ARIA Overview）では、WAI-ARIA に関する追加の背景情報を提供し、それらの取り組みを要約し、WAI-ARIA スイートに含まれる他の文書を一覧表示します。

After a brief "Read Me First" section, the guide begins with ARIA implementation patterns for common widgets that both enumerate expected behaviors and demonstrate those behaviors with working code. The implementation patterns and examples refer to detailed explanations of supporting concepts in subsequent guidance sections. The guidance sections cover more general topics such as use of ARIA landmarks, practices for keyboard interfaces, grid and table properties, and the effects of role presentation.
簡単な「最初に私を読んでください」のセクションの後、ガイドは、予想される振る舞いを列挙し、動作するコードでそれらの振る舞いを示す一般的なウィジェットの ARIA 実装パターンから始まります。 実装パターンと例は、後続のガイダンスのセクションでサポートする概念の詳細な説明を参照しています。 ガイダンスのセクションでは、ARIA ランドマークの使用、キーボードインターフェイスの実践、グリッドとテーブルのプロパティ、プレゼンテーションロールの効果など、より一般的なトピックについて説明します。




2. Read Me First
2. 最初に私を読んでください






2.1 No ARIA is better than Bad ARIA
2.1 ARIA なしは悪い ARIA よりも優れています

Functionally, ARIA roles, states, and properties are analogous to a CSS for assistive technologies. For screen reader users, ARIA controls the rendering of their non-visual experience. Incorrect ARIA misrepresents visual experiences, with potentially devastating effects on their corresponding non-visual experiences.
機能的には、ARIA のロール、状態、およびプロパティは、支援技術のための CSS に類似しています。 スクリーンリーダーのユーザーの場合、ARIA は非視覚的なエクスペリエンスのレンダリングを制御します。 誤った ARIA は視覚的なエクスペリエンスを誤って表現し、対応する非視覚的なエクスペリエンスに壊滅的な影響を与える可能性があります。

Before using ARIA or any of the guidance in this document, please take time to understand the following two essential principles.
ARIA またはこの文書のガイダンスを使用する前に、次の2つの基本原則を理解してください。




Principle 1: A role is a promise
原則1：ロールは約束です

This code:
次のコードは：

        <div role="button">Place Order</div>
        <div role="button">注文する</div>

Is a promise that the author of that <div> has also incorporated JavaScript that provides the keyboard interactions expected for a button. Unlike HTML input elements, ARIA roles do not cause browsers to provide keyboard behaviors or styling.
その <div> の作成者が、ボタンに期待されるキーボードの相互作用を提供する JavaScript も組み込んでいることを約束します。 HTML 入力要素とは異なり、ARIA ロールは、ブラウザーにキーボードの振る舞いやスタイル設定を提供させません。

Using a role without fulfilling the promise of that role is similar to making a "Place Order" button that abandons an order and empties the shopping cart.
そのロールの約束を果たさずにロールを使用することは、注文を放棄してショッピングカートを空にする「注文する」ボタンを作成することに似ています。

One of the objectives of this guide is to define expected behaviors for each ARIA role.
このガイドの目的の1つは、各 ARIA ロールに期待される振る舞いを定義することです。




Principle 2: ARIA Can Both Cloak and Enhance, Creating Both Power and Danger
原則2：ARIA はマントと強化の両方が可能であり、力と危険の両方を生み出します

The information assistive technologies need about the meaning and purpose of user interface elements is called accessibility semantics. From the perspective of assistive technologies, ARIA gives authors the ability to dress up HTML and SVG elements with critical accessibility semantics that the assistive technologies would not otherwise be able to reliably derive.
ユーザーインターフェイス要素の意味と目的について支援技術が必要とする情報は、アクセシビリティの意味論と呼ばれます。 支援技術の観点から、ARIA は、支援技術が他の方法では確実に導き出すことができない重要なアクセシビリティの意味論で HTML 要素および SVG 要素をドレスアップする機能を作成者に提供します。

Some of ARIA is like a cloak; it covers up, or overrides, the original semantics or content.
ARIA のいくつかはマントのようなものです。 元の意味論またはコンテンツを覆い隠すか、オーバーライドします。

        <a role="menuitem">Assistive tech users perceive this element as an item in a menu, not a link.</a>
        <a role="menuitem">支援技術ユーザーは、この要素をリンクではなくメニューの項目として認識します。</a>

        <a aria-label="Assistive tech users can only perceive the contents of this aria-label, not the link text">Link Text</a>
        <a aria-label="支援技術ユーザーは、リンクテキストではなく、この aria-label のコンテンツのみを認識できます。">リンクテキスト</a>

On the other hand, some uses of ARIA are more like suspenders or belts; they add meaning that provides essential support to the original content.
一方、ARIA のいくつかの用途は、サスペンダーやベルトのようなものです。 それらは、元のコンテンツに不可欠なサポートを提供する意味を追加します。

        <button aria-pressed="false">Mute</button>
        <button aria-pressed="false">ミュート</button>

This is the power of ARIA. It enables authors to describe nearly any user interface component in ways that assistive technologies can reliably interpret, thus making components accessible to assistive technology users.
これが ARIA の力です。 これにより、作成者は、支援技術が確実に解釈できる方法でほぼすべてのユーザーインターフェイスコンポーネントを記述できるため、支援技術のユーザーがコンポーネントにアクセスできるようになります。

This is also the danger of ARIA. Authors can inadvertently override accessibility semantics.
これは ARIA の危険でもあります。 作成者は、アクセシビリティの意味論を誤ってオーバーライドする可能性があります。


  <table role="log">

    <!--

      Table that assistive technology users will not perceive as a table.
       支援技術のユーザーがテーブルとして認識しないテーブル。

      The log role tells browser this is a log, not a table.
       ログロールは、これがテーブルではなくログであることをブラウザーに通知します。

    -->

  </table>

  <ul role="navigation">

    <!-- This is a navigation region, not a list. -->
    <!-- これはナビゲーションリージョンであり、リストではありません。 -->

    <li><a href="uri1">nav link 1</li>

    <li><a href="uri2">nav link 2</li>

    <!-- ERROR! Previous list items are not in a list! -->
    <!-- エラー！ 前のリスト項目はリストに入っていません！ -->

  </ul>





2.2 Browser and Assistive Technology Support
2.2 ブラウザーと支援技術のサポート

Testing assistive technology interoperability is essential before using code from this guide in production. Because the purpose of this guide is to illustrate appropriate use of ARIA 1.1 as defined in the ARIA specification, the design patterns, reference examples, and sample code intentionally do not describe and implement coding techniques for working around problems caused by gaps in support for ARIA 1.1 in browsers and assistive technologies. It is thus advisable to test implementations thoroughly with each browser and assistive technology combination that is relevant within a target audience.
このガイドのコードを本番環境で使用する前に、支援技術の相互運用性をテストすることが不可欠です。 このガイドの目的は、ARIA 仕様で定義されている ARIA 1.1 の適切な使用法を説明することであるため、デザインパターン、参照例、およびサンプルコードは、ブラウザーと支援技術における ARIA 1.1 のサポートのギャップによって引き起こされる問題を回避するためのコーディング手法を意図的に説明および実装していません。 したがって、対象者（target audience）内で関連する各ブラウザーと支援技術の組み合わせを使用して実装を徹底的にテストすることをお勧めします。

Similarly, JavaScript and CSS in this guide is written to be compatible with the most recent version of Chrome, Firefox, Internet Explorer, and Safari at the time of writing. In particular, some JavaScript and CSS may not function correctly in Internet Explorer version 10 or earlier.
同様に、このガイドの JavaScript と CSS は、執筆時点での Chrome、Firefox、Internet Explorer、および Safari の最新バージョンと互換性があるように記述されています。 特に、一部の JavaScript および CSS は、Internet Explorer バージョン 10 以前では正しく機能しない場合があります。

Except in cases where the ARIA Working Group and other contributors have overlooked an error, examples in this guide that do not function well in a particular browser or with a specific assistive technology are demonstrating browser or assistive technology bugs. Browser and assistive technology developers can thus utilize code in this guide to help assess the quality of their support for ARIA 1.1.
ARIA ワーキンググループや他の寄稿者がエラーを見落としている場合を除いて、このガイドおいて特定のブラウザーまたは特定の支援技術ではうまく機能しない例は、ブラウザーまたは支援技術のバグを示しています。 したがって、ブラウザーおよび支援技術の開発者は、このガイドのコードを利用して、ARIA 1.1 のサポートの品質を評価できます。




2.3 Mobile and Touch Support
2.3 モバイルとタッチのサポート

Currently, this guide does not indicate which examples are compatible with mobile browsers or touch interfaces. While some of the examples include specific features that enhance mobile and touch support, some ARIA features are not supported in any mobile browser. In addition, there is not yet a standardized approach for providing touch interactions that work across mobile browsers.
現在、このガイドは、どの例がモバイルブラウザーまたはタッチインターフェイスと互換性があるかを示していません。 一部の例には、モバイルとタッチのサポートを強化する特定の機能が含まれていますが、一部の ARIA 機能はどのモバイルブラウザーでもサポートされていません。 さらに、モバイルブラウザー間で動作するタッチの相互作用を提供するための標準化されたアプローチはまだありません。

More guidance about touch and mobile support is planned for future releases of the guide.
タッチとモバイルのサポートに関する詳細なガイダンスは、ガイドの将来のリリースで計画されています。




3. Design Patterns and Widgets
3. デザインパターンとウィジェット

This section demonstrates how to make common rich internet application patterns and widgets accessible by applying WAI-ARIA roles, states, and properties and implementing keyboard support.
このセクションでは、WAI-ARIA のロール、状態、およびプロパティを適用し、キーボードサポートを実装することにより、一般的なリッチインターネットアプリケーションのパターンとウィジェットにアクセスできるようにする方法を示します。




3.1 Accordion (Sections With Show/Hide Functionality)
3.1 アコーディオン（表示/非表示機能のあるセクション）

An accordion is a vertically stacked set of interactive headings that each contain a title, content snippet, or thumbnail representing a section of content. The headings function as controls that enable users to reveal or hide their associated sections of content. Accordions are commonly used to reduce the need to scroll when presenting multiple sections of content on a single page.
アコーディオン（accordion）は、垂直方向に積み重ねられたインタラクティブな見出しのセットであり、それぞれにコンテンツのセクションを表すタイトル、コンテンツスニペット、またはサムネイルが含まれています。 見出しは、ユーザーがコンテンツの関連セクションを表示または非表示にできるようにするコントロールとして機能します。 アコーディオンは通常、コンテンツの複数のセクションを1つのページに提示するときにスクロールする必要性を減らすために使用されます。

Terms for understanding accordions include:
アコーディオンを理解するための用語は次のとおりです。

Accordion Header:
アコーディオンヘッダー（Accordion Header）：

    Label for or thumbnail representing a section of content that also serves as a control for showing, and in some implementations, hiding the section of content. 
    コンテンツのセクションを表示するためのコントロールとしても機能するコンテンツのセクションを表すラベルまたはサムネイル。 一部の実装ではコンテンツのセクションを非表示にします。

Accordion Panel:
アコーディオンパネル（Accordion Panel）：

    Section of content associated with an accordion header.
    アコーディオンヘッダーに関連付けられたコンテンツのセクション。

In some accordions, there are additional elements that are always visible adjacent to the accordion header. For instance, a menubutton may accompany each accordion header to provide access to actions that apply to that section. And, in some cases, a snippet of the hidden content may also be visually persistent.
一部のアコーディオンでは、アコーディオンヘッダーに隣接して常に可視な追加の要素があります。 例えば、メニューボタンを各アコーディオンヘッダーに付けて、そのセクションに適用されるアクションへのアクセスを提供することができます。 また、場合によっては、非表示コンテンツのスニペットが視覚的に永続的である可能性もあります。




Example
例

Accordion Example: demonstrates a form divided into three sections using an accordion to show one section at a time.
アコーディオンの例：アコーディオンを使用して3つのセクションに分割されたフォームを示し、一度に1つのセクションを表示します。




Keyboard Interaction
キーボードの相互作用

    Enter or Space:
    Enter またはスペース：

        When focus is on the accordion header for a collapsed panel, expands the associated panel. If the implementation allows only one panel to be expanded, and if another panel is expanded, collapses that panel.
        折りたたまれたパネルのアコーディオンヘッダーにフォーカスがある場合、関連するパネルを展開します。 実装では1つのパネルのみを展開し、別のパネルを展開する場合は、展開していたパネルを折りたたむようになっています。

        When focus is on the accordion header for an expanded panel, collapses the panel if the implementation supports collapsing. Some implementations require one panel to be expanded at all times and allow only one panel to be expanded; so, they do not support a collapse function.
        展開したパネルのアコーディオンヘッダーにフォーカスがある場合、実装が折りたたみをサポートしている場合はパネルを折りたたみます。 一部の実装では、常に1つのパネルを展開する必要があり、1つのパネルのみを展開できます。 そのため、折りたたみ機能はサポートしていません。

    Tab: Moves focus to the next focusable element; all focusable elements in the accordion are included in the page Tab sequence.
    Tab：フォーカスを次のフォーカス可能な要素に移動します。 アコーディオン内のすべてのフォーカス可能な要素は、ページのタブシーケンスに含まれています。

    Shift + Tab: Moves focus to the previous focusable element; all focusable elements in the accordion are included in the page Tab sequence.
    Shift + Tab：フォーカスを前のフォーカス可能な要素に移動します。 アコーディオン内のすべてのフォーカス可能な要素は、ページのタブシーケンスに含まれています。

    Down Arrow (Optional): If focus is on an accordion header, moves focus to the next accordion header. If focus is on the last accordion header, either does nothing or moves focus to the first accordion header.
    下矢印（任意）：フォーカスがアコーディオンヘッダーにある場合、フォーカスを次のアコーディオンヘッダーに移動します。 フォーカスが最後のアコーディオンヘッダーにある場合、何もしないか、フォーカスを最初のアコーディオンヘッダーに移動します。

    Up Arrow (Optional): If focus is on an accordion header, moves focus to the previous accordion header. If focus is on the first accordion header, either does nothing or moves focus to the last accordion header.
    上矢印（任意）：フォーカスがアコーディオンヘッダーにある場合、フォーカスを前のアコーディオンヘッダーに移動します。 フォーカスが最初のアコーディオンヘッダーにある場合、何もしないか、フォーカスを最後のアコーディオンヘッダーに移動します。

    Home (Optional): When focus is on an accordion header, moves focus to the first accordion header.
    Home（任意）：フォーカスがアコーディオンヘッダーにある場合、フォーカスを最初のアコーディオンヘッダーに移動します。

    End (Optional): When focus is on an accordion header, moves focus to the last accordion header.
    End（任意）：フォーカスがアコーディオンヘッダーにある場合、フォーカスを最後のアコーディオンヘッダーに移動します。




WAI-ARIA Roles, States, and Properties:
WAI-ARIA のロール、状態、およびプロパティ：

    The title of each accordion header is contained in an element with role button.
    各アコーディオンヘッダーのタイトルは、ボタン（button）ロールのある要素に含まれています。

    Each accordion header button is wrapped in an element with role heading that has a value set for aria-level that is appropriate for the information architecture of the page.
    各アコーディオンヘッダーのボタンは、ページの情報アーキテクチャに適した aria-level に設定された値を持つ見出し（heading）ロールを持つ要素にラップされています。

        If the native host language has an element with an implicit heading and aria-level, such as an HTML heading tag, a native host language element may be used.
        ネイティブホスト言語に、HTML 見出しタグなど、暗黙的な見出しと aria-level の要素がある場合は、ネイティブホスト言語の要素を使用できます。

        The button element is the only element inside the heading element. That is, if there are other visually persistent elements, they are not included inside the heading element.
        ボタン要素は、見出し要素内の唯一の要素です。 つまり、他の視覚的に永続的な要素がある場合、それらは見出し要素内に含まれません。

    If the accordion panel associated with an accordion header is visible, the header button element has aria-expanded set to true. If the panel is not visible, aria-expanded is set to false.
    アコーディオンヘッダーに関連付けられたアコーディオンパネルが可視の場合、ヘッダーのボタン要素の aria-expanded は true に設定されています。 パネルが可視でない場合、aria-expanded は false に設定されます。

    The accordion header button element has aria-controls set to the ID of the element containing the accordion panel content.
    アコーディオンヘッダーのボタン要素には、アコーディオンパネルのコンテンツを含む要素の ID に設定された aria-controls があります。

    If the accordion panel associated with an accordion header is visible, and if the accordion does not permit the panel to be collapsed, the header button element has aria-disabled set to true.
    アコーディオンヘッダーに関連付けられたアコーディオンパネルが可視で、アコーディオンがパネルを折りたたむことを許可していない場合、ヘッダーのボタン要素の aria-disabled は true に設定されています。

    Optionally, each element that serves as a container for panel content has role region and aria-labelledby with a value that refers to the button that controls display of the panel.
    任意で、パネルコンテンツのコンテナーとして機能する各要素には、リージョン（region）ロールとパネルの表示を制御するボタンを参照する値を持つ aria-labelledby があります。

        Avoid using the region role in circumstances that create landmark region proliferation, e.g., in an accordion that contains more than approximately 6 panels that can be expanded at the same time.
        同時に展開できる約6つを超えるパネルを含むアコーディオンなど、ランドマークリージョンの増殖を引き起こす状況では、リージョンロールを使用しないでください。

        Role region is especially helpful to the perception of structure by screen reader users when panels contain heading elements or a nested accordion.
        リージョンロールは、パネルに見出し要素またはネストされたアコーディオンが含まれている場合に、スクリーンリーダーユーザーによる構造の認識に特に役立ちます。





3.2 Alert
3.2 アラート

An alert is an element that displays a brief, important message in a way that attracts the user's attention without interrupting the user's task. Dynamically rendered alerts are automatically announced by most screen readers, and in some operating systems, they may trigger an alert sound. It is important to note that, at this time, screen readers do not inform users of alerts that are present on the page before page load completes.
アラート（alert）は、ユーザーのタスクを中断することなく、ユーザーの注意を引く方法で簡潔で重要なメッセージを表示する要素です。 動的にレンダリングされたアラートは、ほとんどのスクリーンリーダーによって自動的にアナウンスされ、一部のオペレーティングシステムでは、アラート音が鳴る場合があります。 現時点では、ページの読み込みが完了する前にページに存在するアラートをスクリーンリーダーがユーザーに通知しないことに注意してください。

Because alerts are intended to provide important and potentially time-sensitive information without interfering with the user's ability to continue working, it is crucial they do not affect keyboard focus. The alert dialog is designed for situations where interrupting work flow is necessary.
アラートは、ユーザーが作業を継続する能力を妨げることなく、重要で時間に敏感な可能性のある情報を提供することを目的としているため、キーボードのフォーカスに影響を与えないことが重要です。 アラートダイアログは、ワークフローの中断が必要な状況向けに設計されています。

It is also important to avoid designing alerts that disappear automatically. An alert that disappears too quickly can lead to failure to meet WCAG 2.0 success criterion 2.2.3. Another critical design consideration is the frequency of interruption caused by alerts. Frequent interruptions inhibit usability for people with visual and cognitive disabilities, which makes meeting the requirements of WCAG 2.0 success criterion 2.2.4 more difficult.
自動的に消えるアラートを設計しないようにすることも重要です。 アラートがすぐに消えると、WCAG 2.0 の達成基準 2.2.3 を満たさなくなる可能性があります。 もう1つの重要な設計上の考慮事項は、アラートによって引き起こされる中断の頻度です。 頻繁な中断は、視覚障害および認知障害を持つ人々のユーザビリティを阻害し、WCAG 2.0 の達成基準 2.2.4 の要件を満たすことをより困難にします。




Example
例

Alert Example
アラートの例




Keyboard Interaction
キーボードの相互作用

An alert (WAI-ARIA live region) does not require any keyboard interaction.
アラート（WAI-ARIA ライブリージョン）では、キーボードの相互作用は必要ありません。




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

The widget has a role of alert.
ウィジェットにはアラート（alert）ロールがあります。




3.3 Alert and Message Dialogs
3.3 アラートとメッセージのダイアログ

An alert dialog is a modal dialog that interrupts the user's workflow to communicate an important message and acquire a response. Examples include action confirmation prompts and error message confirmations. The alertdialog role enables assistive technologies and browsers to distinguish alert dialogs from other dialogs so they have the option of giving alert dialogs special treatment, such as playing a system alert sound.
アラートダイアログ（alert dialog）は、ユーザーのワークフローを中断して重要なメッセージを伝達し、応答を取得するモーダルダイアログです。 例には、アクション確認プロンプトやエラーメッセージ確認が含まれます。 アラートダイアログ（alertdialog）ロールにより、支援技術とブラウザーはアラートダイアログを他のダイアログと区別できるため、システムアラートサウンドの再生など、アラートダイアログに特別な処理を与えることができます。




Example
例

Alert Dialog Example: A confirmation prompt that demonstrates an alert dialog.
アラートダイアログの例：アラートダイアログを示す確認プロンプト。




Keyboard Interaction
キーボードの相互作用

See the keyboard interaction section for the modal dialog pattern.
モーダルダイアログのパターンのキーボードの相互作用のセクションを参照してください。




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that contains all elements of the dialog, including the alert message and any dialog buttons, has role alertdialog.
    アラートメッセージやダイアログボタンなどのダイアログのすべての要素を含む要素には、アラートダイアログ（alertdialog）ロールがあります。

    The element with role alertdialog has either:
    アラートダイアログロールを持つ要素には、次のいずれかがあります。

        A value for aria-labelledby that refers to the element containing the title of the dialog if the dialog has a visible label.
        ダイアログに可視ラベルがある場合に、ダイアログのタイトルを含む要素を参照する aria-labelledby の値。

        A value for aria-label if the dialog does not have a visible label.
        ダイアログに可視ラベルがない場合の aria-label の値。

    The element with role alertdialog has a value set for aria-describedby that refers to the element containing the alert message.
    アラートダイアログロールを持つ要素には、アラートメッセージを含む要素を参照する aria-describeby に値が設定されています。





3.4 Breadcrumb
3.4 パンくずリスト

A breadcrumb trail consists of a list of links to the parent pages of the current page in hierarchical order. It helps users find their place within a website or web application. Breadcrumbs are often placed horizontally before a page's main content.
パンくずリスト（breadcrumb trail）は、現在のページの親ページへのリンクを階層順にリストしたものです。 これは、ユーザーがウェブサイトまたはウェブアプリケーション内で自分の場所を見つけるのに役立ちます。 パンくずリストは、多くの場合、ページのメインコンテンツの前に水平に配置されます。




Example
例

Breadcrumb design pattern example
パンくずリストのデザインパターンの例




Keyboard Interaction
キーボードの相互作用

Not applicable.
該当しません。




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    Breadcrumb trail is contained within a navigation landmark region.
    パンくずリストは、ナビゲーションランドマークリージョン内に含まれています。

    The landmark region is labelled via aria-label or aria-labelledby.
    ランドマークリージョンは、aria-label または aria-labelledby によってラベル付けされます。

    The link to the current page has aria-current set to page. If the element representing the current page is not a link, aria-current is optional.
    現在のページへのリンクでは、aria-current が page に設定されています。 現在のページを表す要素がリンクでない場合、aria-current は任意です。





3.5 Button
3.5 ボタン

A button is a widget that enables users to trigger an action or event, such as submitting a form, opening a dialog, canceling an action, or performing a delete operation. A common convention for informing users that a button launches a dialog is to append "…" (ellipsis) to the button label, e.g., "Save as…".
ボタン（button）は、ユーザーがフォームを送信したり、ダイアログを開いたり、アクションをキャンセルしたり、削除操作を実行したりするなどのアクションまたはイベントをトリガーできるようにするウィジェットです。 ボタンがダイアログを起動することをユーザーに通知するための一般的な規則は、ボタンのラベルに "…" （省略記号）を追加することです（例：「名前を付けて保存…」）。

In addition to the ordinary button widget, WAI-ARIA supports 2 other types of buttons:
通常のボタンウィジェットに加えて、WAI-ARIA は他の2種類のボタンをサポートしています。

    Toggle button: A two-state button that can be either off (not pressed) or on (pressed). To tell assistive technologies that a button is a toggle button, specify a value for the attribute aria-pressed. For example, a button labelled mute in an audio player could indicate that sound is muted by setting the pressed state true. Important: it is critical the label on a toggle does not change when its state changes. In this example, when the pressed state is true, the label remains "Mute" so a screen reader would say something like "Mute toggle button pressed". Alternatively, if the design were to call for the button label to change from "Mute" to "Unmute," the aria-pressed attribute would not be needed.
    トグルボタン：オフ（押されていない）またはオン（押されている）のいずれかが可能な2つの状態のボタン。 ボタンがトグルボタンであることを支援技術に伝えるには、aria-pressed 属性の値を指定します。 例えば、オーディオプレーヤーのミュートというラベルの付いたボタンは、押された状態を true に設定することで、サウンドがミュートされていることを示すことができます。 重要：トグルの状態が変化しても、トグルのラベルが変化しないことが重要です。 この例では、押された状態が true の場合、ラベルは「ミュート」のままなので、スクリーンリーダーは「ミュートトグルボタンが押されています」のように表示します。 代わりに、ボタンラベルを「ミュート」から「ミュート解除」に変更するように設計されている場合、aria-pressed 属性は必要ありません。

    Menu button: as described in the menu button pattern, a button is revealed to assistive technologies as a menu button if it has the property aria-haspopup set to either menu or true.
    メニューボタン：メニューボタンのパターンで説明されているように、aria-haspopup プロパティが menu または true に設定されている場合、ボタンはメニューボタンとして支援技術に表示されます。

Note
注意

The types of actions performed by buttons are distinctly different from the function of a link (see link pattern). It is important that both the appearance and role of a widget match the function it provides. Nevertheless, elements occasionally have the visual style of a link but perform the action of a button. In such cases, giving the element role button helps assistive technology users understand the function of the element. However, a better solution is to adjust the visual design so it matches the function and ARIA role.
ボタンによって実行されるアクションのタイプは、リンクの機能とは明らかに異なります（リンクのパターンを参照）。 ウィジェットの外観とロールの両方が、ウィジェットが提供する機能と一致していることが重要です。 それにもかかわらず、要素はリンクの視覚的なスタイルを持ちながら、ボタンのアクションを実行することがあります。 このような場合、要素にボタンロールを指定すると、支援技術のユーザーが要素の機能を理解するのに役立ちます。 ただし、より良い解決策は、機能と ARIA ロールが一致するようにビジュアルデザインを調整することです。




Examples
例

Button Examples: Examples of clickable HTML div and span elements made into accessible command and toggle buttons.
ボタンの例：クリック可能な HTML の div 要素と span 要素をアクセス可能なコマンドボタンとトグルボタンにした例。




Keyboard Interaction
キーボードの相互作用

When the button has focus:
ボタンにフォーカスがある場合：

    Space: Activates the button.
    スペース：ボタンをアクティブ化します。

    Enter: Activates the button.
    Enter：ボタンをアクティブ化します。

    Following button activation, focus is set depending on the type of action the button performs. For example:
    ボタンのアクティブ化に続いて、ボタンが実行するアクションのタイプに応じてフォーカスが設定されます。 例えば：

        If activating the button opens a dialog, the focus moves inside the dialog. (see dialog pattern)
        ボタンをアクティブ化するとダイアログが開き、フォーカスがダイアログ内に移動します。 （ダイアログのパターンを参照）

        If activating the button closes a dialog, focus typically returns to the button that opened the dialog unless the function performed in the dialog context logically leads to a different element. For example, activating a cancel button in a dialog returns focus to the button that opened the dialog. However, if the dialog were confirming the action of deleting the page from which it was opened, the focus would logically move to a new context.
        ボタンをアクティブ化するとダイアログが閉じる場合、ダイアログコンテキストで実行された機能が論理的に別の要素に導かれる場合を除いて、フォーカスは通常、ダイアログを開いたボタンに戻ります。 例えば、ダイアログでキャンセルボタンをアクティブ化すると、ダイアログを開いたボタンにフォーカスが戻ります。 ただし、ダイアログが開いたページを削除するアクションを確認している場合、フォーカスは論理的に新しいコンテキストに移動します。

        If activating the button does not dismiss the current context, then focus typically remains on the button after activation, e.g., an Apply or Recalculate button.
        ボタンをアクティブ化しても現在のコンテキストが閉じられない場合は、通常、アクティブ化後もボタンにフォーカスが残ります（例：適用ボタンや再計算ボタン）。

        If the button action indicates a context change, such as move to next step in a wizard or add another search criteria, then it is often appropriate to move focus to the starting point for that action.
        ボタンのアクションが、ウィザードの次のステップに移動したり、別の検索条件を追加したりするなど、コンテキストの変更を示している場合は、そのアクションの開始点にフォーカスを移動することが適切な場合がよくあります。

        If the button is activated with a shortcut key, the focus usually remains in the context from which the shortcut key was activated. For example, if Alt + U were assigned to an "Up" button that moves the currently focused item in a list one position higher in the list, pressing Alt + U when the focus is in the list would not move the focus from the list.
        ボタンがショートカットキーでアクティブ化された場合、フォーカスは通常、ショートカットキーがアクティブ化されたコンテキストに留まります。 例えば、Alt + U が、リスト内の現在フォーカスされている項目をリストの1つ上の位置に移動する「上へ」ボタンに割り当てられている場合、フォーカスがリスト内にあるときに Alt + U を押しても、フォーカスはリストから移動しません。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The button has role of button.
    ボタンはボタン（button）ロールを持ちます。

    The button has an accessible label. By default, the accessible name is computed from any text content inside the button element. However, it can also be provided with aria-labelledby or aria-label.
    ボタンにはアクセス可能なラベルが付いています。 デフォルトでは、アクセス可能な名前はボタン要素内のテキストコンテンツから計算されます。 ただし、aria-labelledby または aria-label を指定して提供することもできます。

    If a description of the button's function is present, the button element has aria-describedby set to the ID of the element containing the description.
    ボタンの機能の説明が存在する場合、ボタン要素の aria-describeby は、説明を含む要素の ID に設定されます。

    When the action associated with a button is unavailable, the button has aria-disabled set to true.
    ボタンに関連付けられているアクションが使用できない場合、ボタンの aria-disabled は true に設定されています。

    If the button is a toggle button, it has an aria-pressed state. When the button is toggled on, the value of this state is true, and when toggled off, the state is false.
    ボタンがトグルボタンの場合、aria-pressed 状態を持ちます。 ボタンをオンに切り替えると、この状態の値は true になり、オフに切り替えると、状態は false になります。





3.6 Carousel (Slide Show or Image Rotator)
3.6 カルーセル（スライドショーまたはイメージローテーター）

A carousel presents a set of items, referred to as slides, by sequentially displaying a subset of one or more slides. Typically, one slide is displayed at a time, and users can activate a next or previous slide control that hides the current slide and "rotates" the next or previous slide into view. In some implementations, rotation automatically starts when the page loads, and it may also automatically stop once all the slides have been displayed. While a slide may contain any type of content, image carousels where each slide contains nothing more than a single image are common.
カルーセル（carousel、回転木馬）は、1つまたは複数のスライドのサブセットを順番に表示することにより、スライドと呼ばれる項目のセットを提示します。 通常、一度に1つのスライドが表示され、ユーザーは次または前のスライドコントロールをアクティブ化して、現在のスライドを非表示にし、次または前のスライドを「回転」して表示することができます。 一部の実装では、ページが読み込まれると回転が自動的に開始され、すべてのスライドが表示されると自動的に停止する場合もあります。 スライドには任意のタイプのコンテンツを含めることができますが、各スライドに1つの画像しか含まれていない画像カルーセルが一般的です。

Ensuring all users can easily control and are not adversely effected by slide rotation is an essential aspect of making carousels accessible. For instance, the screen reader experience can be confusing and disorienting if slides that are not visible on screen are incorrectly hidden, e.g., displayed off-screen. Similarly, if slides rotate automatically and a screen reader user is not aware of the rotation, the user may read an element on slide one, execute the screen reader command for next element, and, instead of hearing the next element on slide one, hear an element from slide 2 without any knowledge that the element just announced is from an entirely new context.
すべてのユーザーが簡単に制御でき、スライドの回転による悪影響を受けないようにすることは、カルーセルにアクセスできるようにするための重要な側面です。 例えば、画面に可視でないスライドが誤って隠されている場合、例えば画面外に表示されている場合、スクリーンリーダーのエクスペリエンスは混乱し、混乱を招く可能性があります。 同様に、スライドが自動的に回転し、スクリーンリーダーのユーザーが回転に気付いていない場合、ユーザーはスライド1の要素を読み、次の要素のためのスクリーンリーダーコマンドを実行し、スライド1の次の要素を聞く代わりに、アナウンスされたばかりの要素がまったく新しいコンテキストからのものであるという知識なしで、スライド2の要素を聞くことになる可能性があります。

Features needed to provide sufficient rotation control include:
十分な回転コントロールを提供するために必要な機能は次のとおりです。

    Buttons for displaying the previous and next slides.
    前のスライドと次のスライドを表示するためのボタン。

    Optionally, a control, or group of controls, for choosing a specific slide to display. For example, slide picker controls can be marked up as tabs in a tablist with the slide represented by a tabpanel element.
    任意で、表示する特定のスライドを選択するためのコントロールまたはコントロールのグループ。 例えば、スライドピッカーコントロールは、タブパネル要素で表されるスライドを使用して、タブリスト内のタブとしてマークアップできます。

    If the carousel can automatically rotate, it also:
    カルーセルが自動的に回転できる場合は、次のことも行います。

        Has a button for stopping and restarting rotation. This is particularly important for supporting assistive technologies operating in a mode that does not move either keyboard focus or the mouse.
        回転を停止および再開するためのボタンがあります。 これは、キーボードフォーカスもマウスも動かさないモードで動作する支援技術をサポートするために特に重要です。

        Stops rotating when keyboard focus enters the carousel. It does not restart unless the user explicitly requests it to do so.
        キーボードフォーカスがカルーセルに入ると回転を停止します。 ユーザーが明示的に要求しない限り、再開しません。

        Stops rotating whenever the mouse is hovering over the carousel.
        マウスがカルーセルの上にあるときはいつでも回転を停止します。





Example
例

Auto-Rotating Image Carousel Example: A basic image carousel that demonstrates the accessibility features necessary for carousels that rotate automatically on page load.
自動回転画像カルーセルの例：ページの読み込み時に自動的に回転するカルーセルに必要なアクセシビリティ機能を示す基本的な画像カルーセル。




Terms
用語

The following terms are used to describe components of a carousel.
次の用語は、カルーセルのコンポーネントを説明するために使用されます。

Slide
スライド（Slide）

    A single content container within a set of content containers that hold the content to be presented by the carousel.
    カルーセルによって提示されるコンテンツを保持するコンテンツコンテナーのセット内の単一コンテンツコンテナー。

Rotation Control
回転コントロール（Rotation Control）

    An interactive element that stops and starts automatic slide rotation.
    スライドの自動回転を停止および開始するインタラクティブな要素。

Next Slide Control
次のスライドコントロール（Next Slide Control）

    An interactive element, often styled as an arrow, that displays the next slide in the rotation sequence.
    回転順序の次のスライドを表示する、多くの場合矢印のスタイルのインタラクティブな要素。

Previous Slide Control
前のスライドコントロール（Previous Slide Control）

    An interactive element, often styled as an arrow, that displays the previous slide in the rotation sequence.
    回転順序の前のスライドを表示する、多くの場合矢印のスタイルのインタラクティブな要素。

Slide Picker Controls
スライドピッカーコントロール（Slide Picker Controls）

    A group of elements, often styled as small dots, that enable the user to pick a specific slide in the rotation sequence to display.
    多くの場合小さなドットのスタイルの要素のグループ。 これにより、ユーザーは回転順序内の特定のスライドを選択して表示できます。





Keyboard Interaction
キーボードの相互作用

    If the carousel has an auto-rotate feature, automatic slide rotation stops when any element in the carousel receives keyboard focus. It does not resume unless the user activates the rotation control.
    カルーセルに自動回転機能がある場合、カルーセル内のいずれかの要素がキーボードフォーカスを受け取ると、スライドの自動回転が停止します。 ユーザーが回転コントロールをアクティブ化しない限り、再開しません。

    Tab and Shift + Tab: Move focus through the interactive elements of the carousel as specified by the page tab sequence -- scripting for Tab is not necessary.
    Tab と Shift + Tab：ページのタブシーケンスで指定されているように、カルーセルのインタラクティブな要素を介してフォーカスを移動します。 Tab キーのためのスクリプトは必要ありません。

    Button elements implement the keyboard interaction defined in the button pattern. Note: Activating the rotation control, next slide, and previous slide do not move focus, so users may easily repetitively activate them as many times as desired.
    ボタン要素は、ボタンのパターンで定義されたキーボードの相互作用を実装します。 注：回転コントロール、次のスライド、および前のスライドをアクティブ化してもフォーカスは移動しないため、ユーザーは必要な回数だけ繰り返しアクティブ化することができます。

    If present, the rotation control is the first element in the Tab sequence inside the carousel. It is essential that it precede the rotating content so it can be easily located.
     存在する場合、回転コントロールはカルーセル内のタブシーケンスの最初の要素です。 簡単に見つけられるように、回転するコンテンツの前に配置することが重要です。

    If tab elements are used for slide picker controls, they implement the keyboard interaction defined in the Tabs Pattern.
    タブ要素がスライドピッカーコントロールに使用される場合、それらはタブのパターンで定義されたキーボードの相互作用を実装します。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、プロパティ

This section describes the element composition for three styles of carousels:
このセクションでは、3つのスタイルのカルーセルの要素構成について説明します。

    Basic: Has rotation, previous slide, and next slide controls but no slide picker controls.
     基本：回転、前のスライド、次のスライドのコントロールはありますが、スライドピッカーコントロールはありません。

    Tabbed: Has basic controls plus a single tab stop for slide picker controls implemented using the tabs pattern.
     タブ付き：基本的なコントロールに加えて、タブのパターンを使用して実装されたスライドピッカーコントロール用の1つのタブストップがあります。

    Grouped: Has basic controls plus a series of tab stops in a group of slide picker controls where each control implements the button pattern. Because each slide selector button adds an element to the page tab sequence, this style is the least friendly for keyboard users.
     グループ化：基本的なコントロールに加えて、各コントロールがボタンのパターンを実装するスライドピッカーコントロールのグループに一連のタブストップがあります。 各スライド選択ボタンはページのタブシーケンスに要素を追加するため、このスタイルはキーボードユーザーにとって最も使いにくいものです。





Basic carousel elements
基本的なカルーセル要素

    A carousel container element that encompasses all components of the carousel, including both carousel controls and slides, has either role region or role group. The most appropriate role for the carousel container depends on the information architecture of the page. See the landmark regions guidance to determine whether the carousel warrants being designated as a landmark region.
    カルーセルコントロールとスライドの両方を含む、カルーセルのすべてのコンポーネントを含むカルーセルコンテナー要素には、リージョンロールまたはグループロールのいずれかがあります。 カルーセルコンテナーの最も適切なロールは、ページの情報アーキテクチャによって異なります。 カルーセルがランドマークリージョンとして指定されることを保証するかどうかを判断するには、ランドマークリージョンのガイダンスを参照してください。

    The carousel container has the aria-roledescription property set to carousel.
    カルーセルコンテナーの aria-roledescription プロパティは carousel （訳注：要ローカライズ）に設定されています。

    If the carousel has a visible label, its accessible label is provided by the property aria-labelledby on the carousel container set to the ID of the element containing the visible label. Otherwise, an accessible label is provided by the property aria-label set on the carousel container. Note that since the aria-roledescription is set to "carousel", the label does not contain the word "carousel".
    カルーセルに可視ラベルがある場合、そのアクセス可能なラベルは、可視ラベルを含む要素の ID に設定されたカルーセルコンテナーの aria-labelledby プロパティによって提供されます。 それ以外の場合、アクセス可能なラベルは、カルーセルコンテナーに設定された aria-label プロパティによって提供されます。 aria-roledescription が "carousel" に設定されているため、ラベルに「カルーセル」という単語が含まれていないことに注意してください。

    The rotation control, next slide control, and previous slide control are either native button elements (recommended) or implement the button pattern.
    回転コントロール、次のスライドコントロール、および前のスライドコントロールは、ネイティブのボタン要素（推奨）であるか、ボタンのパターンを実装しています。

    The rotation control has an accessible label provided by either its inner text or aria-label. The label changes to match the action the button will perform, e.g., "Stop slide rotation" or "Start slide rotation". A label that changes when the button is activated clearly communicates both that slide content can change automatically and when it is doing so. Note that since the label changes, the rotation control does not have any states, e.g., aria-pressed, specified.
    回転コントロールには、内部テキストまたは aria-label のいずれかによって提供されるアクセス可能なラベルがあります。 ラベルは、ボタンが実行するアクション（「スライドの回転を停止する」、「スライドの回転を開始する」など）に合わせて変更されます。 ボタンがアクティブ化すると変更されるラベルは、スライドのコンテンツが自動的に変更される可能性があることと、変更されるときの両方を明確に伝えます。 ラベルが変更されるため、回転コントロールには、例えば aria-pressed などの状態の指定がないことに注意してください。

    Each slide container has role group with the property aria-roledescription set to slide.
    各スライドコンテナーには、aria-roledescription プロパティが slide（訳注：要ローカライズ）に設定されたグループロールがあります。

    Each slide has an accessible name:
    各スライドには、アクセス可能な名前があります。

        If a slide has a visible label, its accessible label is provided by the property aria-labelledby on the slide container set to the ID of the element containing the visible label.
        スライドに可視ラベルがある場合、そのアクセス可能なラベルは、可視ラベルを含む要素の ID に設定されたスライドコンテナーの aria-labelledby プロパティによって提供されます。

        Otherwise, an accessible label is provided by the property aria-label set on the slide container.
        それ以外の場合、アクセス可能なラベルは、スライドコンテナーに設定された aria-label プロパティによって提供されます。

        If unique names that identify the slide content are not available, a number and set size can serve as a meaningful alternative, e.g., "3 of 10". Note: Normally, including set position and size information in an accessible name is not appropriate. An exception is helpful in this implementation because group elements do not support aria-setsize or aria-posinset. The tabbed carousel implementation pattern does not have this limitation.
        スライドのコンテンツを識別する一意の名前が利用できない場合は、番号とセットサイズを意味のある代替として使用できます（例：「3/10」）。 注：通常、アクセス可能な名前に設定された位置とサイズの情報を含めることは適切ではありません。 グループ要素は aria-setsize または aria-posinset をサポートしていないため、この実装では例外が役立ちます。 タブ付きカルーセルの実装パターンには、この制限はありません。

        Note that since the aria-roledescription is set to "slide", the label does not contain the word "slide."
        aria-roledescription が "slide" に設定されているため、ラベルに「スライド」という単語が含まれていないことに注意してください。

    Optionally, an element wrapping the set of slide elements has aria-atomic set to false and aria-live set to:
    任意で、スライド要素のセットをラップする要素の aria-atomic が false に設定され、aria-live が次のように設定されます。

        off: if the carousel is automatically rotating.
        off：カルーセルが自動的に回転している場合。

        polite: if the carousel is NOT automatically rotating.
        polite：カルーセルが自動的に回転しない場合。




Tabbed Carousel Elements
タブ付きカルーセル要素

The structure of a tabbed carousel is the same as a basic carousel except that:
タブ付きカルーセルの構造は、次の点を除いて基本的なカルーセルと同じです。

    Each slide container has role tabpanel in lieu of group, and it does not have the aria-roledescription property.
    各スライドコンテナーには、グループロールの代わりにタブパネル（tabpanel）ロールがあり、aria-roledescription プロパティはありません。

    It has slide picker controls implemented using the tabs pattern where:
    タブのパターンを使用して実装されたスライドピッカーコントロールがあります。

        Each control is a tab element, so activating a tab displays the slide associated with that tab.
        各コントロールはタブ要素であるため、タブをアクティブ化すると、そのタブに関連付けられたスライドが表示されます。

        The accessible name of each tab indicates which slide it will display by including the name or number of the slide, e.g., "Slide 3". Slide names are preferable if each slide has a unique name.
        各タブのアクセス可能な名前は、スライドの名前または番号を含めることで、どのスライドを表示するかを示します（例：「スライド3」）。 各スライドに一意の名前がある場合は、スライド名をお勧めします。

        The set of controls is grouped in a tablist element with an accessible name provided by the value of aria-label that identifies the purpose of the tabs, e.g., "Choose slide to display."
        コントロールのセットは、タブの目的を識別する aria-label の値によって提供されるアクセス可能な名前を持つタブリスト（tablist）要素にグループ化されます（例：「表示するスライドを選択してください」）。

        The tab, tablist, and tabpanel implement the properties specified in the tabs pattern.
        タブ、タブリスト、およびタブパネルは、タブのパターンで指定されたプロパティを実装します。





Grouped Carousel Elements
グループ化されたカルーセル要素

A grouped carousel has the same structure as a basic carousel, but it also includes slide picker controls where:
グループ化されたカルーセルは、基本的なカルーセルと同じ構造ですが、スライドピッカーコントロールも含まれています。

    The set of slide picker controls is contained in an element with role group.
    スライドピッカーコントロールのセットは、グループロールを持つ要素に含まれています。

    The group containing the picker controls has an accessible label provided by the value of aria-label that identifies the purpose of the controls, e.g., "Choose slide to display."
    ピッカーコントロールを含むグループには、コントロールの目的を識別する aria-label の値によって提供されるアクセス可能なラベルがあります（例：「表示するスライドを選択してください」）。

    Each picker control is a native button element (recommended) or implements the button pattern.
    各ピッカーコントロールは、ネイティブのボタン要素（推奨）であるか、ボタンのパターンを実装します。

    The accessible name of each picker button matches the name of the slide it displays. One technique for accomplishing this is to set aria-labelledby to a value that references the slide group element.
    各ピッカーボタンのアクセス可能な名前は、表示されるスライドの名前と一致します。 これを実現するための1つの手法は、aria-labelledby をスライドのグループ要素を参照する値に設定することです。

    The picker button representing the currently displayed slide has the property aria-disabled set to true. Note: aria-disabled is preferable to the HTML disabled attribute because this is a circumstance where screen reader users benefit from the disabled button being included in the page Tab sequence.
    現在表示されているスライドを表すピッカーボタンの aria-disabled プロパティが true に設定されています。 注：これは、スクリーンリーダーのユーザーがページのタブシーケンスに含まれている無効なボタンの恩恵を受ける状況であるため、aria-disabled は HTML の disabled 属性よりも望ましいです。





3.7 Checkbox
3.7 チェックボックス

WAI-ARIA supports two types of checkbox widgets:
WAI-ARIA は、次の2種類のチェックボックス（checkbox）ウィジェットをサポートしています。

    Dual-state: The most common type of checkbox, it allows the user to toggle between two choices -- checked and not checked.
    デュアルステート：最も一般的なタイプのチェックボックスで、ユーザーは2つの選択肢（チェックされている（オン）とチェックされていない（オフ））を切り替えることができます。

    Tri-state: This type of checkbox supports an additional third state known as partially checked.
    トライステート：このタイプのチェックボックスは、部分的チェックと呼ばれる追加の3番目の状態をサポートします。

One common use of a tri-state checkbox can be found in software installers where a single tri-state checkbox is used to represent and control the state of an entire group of install options. And, each option in the group can be individually turned on or off with a dual state checkbox.
トライステートチェックボックスの一般的な使用法の1つは、インストールオプションのグループ全体の状態を表して制御するために1つのトライステートチェックボックスが使用されるソフトウェアインストーラーにあります。 また、グループ内の各オプションは、デュアルステートチェックボックスを使用して個別にオンまたはオフにできます。

    If all options in the group are checked, the overall state is represented by the tri-state checkbox displaying as checked.
    グループ内のすべてのオプションがチェックされている場合、全体的な状態は、チェックされていると表示されるトライステートチェックボックスによって表されます。

    If some of the options in the group are checked, the overall state is represented with the tri-state checkbox displaying as partially checked.
    グループ内のいくつかのオプションがチェックされている場合、全体的な状態は、部分的にチェックされていると表示されるトライステートチェックボックスで表されます。

    If none of the options in the group are checked, the overall state of the group is represented with the tri-state checkbox displaying as not checked.
    グループ内のどのオプションもチェックされていない場合、グループの全体的な状態は、チェックされていないと表示されるトライステートチェックボックスで表されます。

The user can use the tri-state checkbox to change all options in the group with a single action:
ユーザーは、トライステートチェックボックスを使用して、グループ内のすべてのオプションを1つのアクションで変更できます。

    Checking the overall checkbox checks all options in the group.
    全体のチェックボックスをオンにすると、グループ内のすべてのオプションがオンになります。

    Unchecking the overall checkbox will uncheck all options in the group.
    全体のチェックボックスをオフにすると、グループ内のすべてのオプションがオフになります。

    And, In some implementations, the system may remember which options were checked the last time the overall status was partially checked. If this feature is provided, activating the overall checkbox a third time recreates that partially checked state where only some options in the group are checked.
    また、一部の実装では、システムは、全体的なステータスが最後に部分的にチェックされたときに、どのオプションがチェックされたかを記憶している場合があります。 この機能が提供されている場合、全体のチェックボックスを3回アクティブ化すると、グループ内の一部のオプションのみがチェックされている部分的にチェックされた状態が再作成されます。





Examples
例

    Simple Two-State Checkbox Example: Demonstrates a simple 2-state checkbox.
     単純なデュアルステートチェックボックスの例：単純なデュアルステートチェックボックスを示します。

    Tri-State Checkbox Example: Demonstrates how to make a widget that uses the mixed value for aria-checked and group collection of checkboxes with a field set.
     トライステートチェックボックスの例：aria-checked の mixed 値を使用したウィジェットの作成方法と、フィールドセットでのチェックボックスのグループコレクションの作成方法を示します。





Keyboard Interaction
キーボードの相互作用

When the checkbox has focus, pressing the Space key changes the state of the checkbox.
チェックボックスにフォーカスがある場合、スペースキーを押すとチェックボックスの状態が変わります。




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The checkbox has role checkbox.
    チェックボックスにはチェックボックス（checkbox）ロールがあります。

    The checkbox has an accessible label provided by one of the following:
    チェックボックスには、次のいずれかによって提供されるアクセス可能なラベルがあります。

        Visible text content contained within the element with role checkbox.
        チェックボックスロールのある要素内に含まれる可視テキストコンテンツ。

        A visible label referenced by the value of aria-labelledby set on the element with role checkbox.
        チェックボックスロールのある要素に設定された aria-labelledby の値によって参照される可視ラベル。

        aria-label set on the element with role checkbox.
        チェックボックスロールのある要素に設定された aria-label。

    When checked, the checkbox element has state aria-checked set to true.
    チェックすると、チェックボックス要素の aria-checked 状態が true に設定されます。

    When not checked, it has state aria-checked set to false.
    チェックされていない場合、aria-checked 状態が false に設定されます。

    When partially checked, it has state aria-checked set to mixed.
    部分的にチェックすると、aria-checked 状態が mixed に設定されます。

    If a set of checkboxes is presented as a logical group with a visible label, the checkboxes are included in an element with role group that has the property aria-labelledby set to the ID of the element containing the label.
    チェックボックスのセットが可視ラベルを持つ論理グループとして提示される場合、チェックボックスは、ラベルを含む要素の ID に設定された aria-labelledby プロパティを持つグループロールを持つ要素に含まれます。

    If the presentation includes additional descriptive static text relevant to a checkbox or checkbox group, the checkbox or checkbox group has the property aria-describedby set to the ID of the element containing the description.
    表現にチェックボックスまたはチェックボックスグループに関連する追加の説明の静的テキストが含まれている場合、チェックボックスまたはチェックボックスグループの aria-describedby プロパティは、説明を含む要素の ID に設定されます。





3.8 Combo Box
3.8 コンボボックス

A combobox is a widget made up of the combination of two distinct elements: 1) a single-line textbox, and 2) an associated pop-up element for helping users set the value of the textbox. The popup may be a listbox, grid, tree, or dialog. Many implementations also include a third optional element -- a graphical button adjacent to the textbox, indicating the availability of the popup. Activating the button displays the popup if suggestions are available.
コンボボックス（combobox）は、2つの異なる要素の組み合わせで構成されるウィジェットです。 1）単一行テキストボックスと、2）ユーザーがテキストボックスの値を設定するのに役立つ関連するポップアップ要素です。 ポップアップは、リストボックス、グリッド、ツリー、またはダイアログの場合があります。 多くの実装には、3番目の任意要素（テキストボックスに隣接するグラフィカルボタン）も含まれており、ポップアップが利用可能であることを示します。 ボタンをアクティブ化すると、提案が利用可能な場合にポップアップが表示されます。

The popup is hidden by default, and the conditions that trigger its display are specific to each implementation. Some possible popup display conditions include:
ポップアップはデフォルトで非表示になっており、その表示をトリガーする条件は各実装に固有です。 考えられるポップアップ表示条件には、次のものがあります。

    It is displayed only if a certain number of characters are typed in the textbox and those characters match some portion of one of the suggested values.
    テキストボックスに特定の数の文字がタイプ入力され、それらの文字が提案値の1つの一部と一致する場合にのみ表示されます。

    It is displayed as soon as the textbox is focused, even if the textbox is empty.
    テキストボックスが空の場合でも、テキストボックスがフォーカスされるとすぐに表示されます。

    It is displayed when the Down Arrow key is pressed or the "show" button is activated, possibly with a dependency on the content of the textbox.
    下矢印キーが押されたとき、または「表示」ボタンがアクティブ化されたときに表示されます。 テキストボックスの内容に依存している可能性があります。

    It is displayed if the value of the textbox is altered in a way that creates one or more partial matches to a suggested value.
    テキストボックスの値が、提案値と1つ以上の部分一致を成すように変更された場合に表示されます。

Combobox widgets are useful for setting the value of a single-line textbox in one of two types of scenarios:
コンボボックスウィジェットは、次の2種類のシナリオのいずれかで単一行テキストボックスの値を設定するのに役立ちます。

    The value for the textbox must be chosen from a predefined set of allowed values, e.g., a location field must contain a valid location name. Note that the listbox and menu button patterns are also useful in this scenario; differences between combobox and alternative patterns are described below.
    1. テキストボックスの値は、事前定義された許可された値のセットから選択する必要があります。 例えば、場所フィールドには有効な場所名が含まれている必要があります。 このシナリオでは、リストボックスとメニューボタンのパターンも役立つことに注意してください。 コンボボックスと代替パターンの違いを以下に説明します。

    The textbox may contain any arbitrary value, but it is advantageous to suggest possible values to the user, e.g., a search field may suggest similar or previous searches to save the user time.
    2. テキストボックスには任意の値を含めることができますが、ユーザーに可能な値を提案することは有利です。 例えば、検索フィールドは、ユーザーの時間を節約するために類似または以前の検索を提案する場合があります。

The nature of the suggested values and the way the suggestions are presented is called the autocomplete behavior. Comboboxes can have one of four forms of autocomplete:
提案値の性質と提案の提示方法は、自動補完（autocomplete、オートコンプリート）の振る舞いと呼ばれます。 コンボボックスには、自動補完の4つの形式のいずれかを含めることができます。

    No autocomplete: When the popup is triggered, the suggested values it contains are the same regardless of the characters typed in the textbox. For example, the popup suggests a set of recently entered values, and the suggestions do not change as the user types.
    1. 自動補完なし：ポップアップがトリガーされると、ポップアップに含まれる提案値は、テキストボックスに入力された文字に関係なく同じです。 例えば、ポップアップは最近入力された値のセットを提案し、ユーザーがタイプ入力しても提案は変更されません。

    List autocomplete with manual selection: When the popup is triggered, it presents suggested values that complete or logically correspond to the characters typed in the textbox. The character string the user has typed will become the value of the textbox unless the user selects a value in the popup.
    2. 手動選択によるリストの自動補完：ポップアップがトリガーされると、テキストボックスにタイプ入力された文字に完全または論理的に対応する提案値が示されます。 ユーザーがポップアップで値を選択しない限り、ユーザーがタイプ入力した文字列がテキストボックスの値になります。

    List autocomplete with automatic selection: When the popup is triggered, it presents suggested values that complete or logically correspond to the characters typed in the textbox, and the first suggestion is automatically highlighted as selected. The automatically selected suggestion becomes the value of the textbox when the combobox loses focus unless the user chooses a different suggestion or changes the character string in the textbox.
    3. 自動選択によるリストの自動補完：ポップアップがトリガーされると、テキストボックスに入力された文字に完全または論理的に対応する提案値が示され、最初の提案が選択済みとして自動的に強調表示されます。 自動的に選択された提案は、ユーザーが別の提案を選択したり、テキストボックスの文字列を変更したりしない限り、コンボボックスがフォーカスを失ったときにテキストボックスの値になります。

    List with inline autocomplete: This is the same as list with automatic selection with one additional feature. The portion of the selected suggestion that has not been typed by the user, a completion string, appears inline after the input cursor in the textbox. The inline completion string is visually highlighted and has a selected state.
    4. インライン自動補完によるリスト：これは、自動選択によるリストと同じですが、1つの追加機能があります。 選択した提案のうち、ユーザーが入力していない部分である補完文字列は、テキストボックスの入力カーソルの後にインラインで表示されます。 インライン補完文字列は視覚的に強調表示され、選択状態にされています。

With any form of list autocomplete, the popup may appear and disappear as the user types. For example, if the user types a two character string that triggers five suggestions to be displayed but then types a third character that forms a string that does not have any matching suggestions, the popup may close and, if present, the inline completion string disappears.
どの形式のリストの自動補完でも、ユーザーがタイプ入力するとポップアップが表示されたり消えたりする場合があります。 例えば、ユーザーが5つの提案を表示するトリガーとなる2文字の文字列を入力した後、一致する提案がない文字列を形成する3番目の文字を入力すると、ポップアップが閉じ、インライン補完文字列が消える場合があります。

When constructing a widget that is both visually compact and enables users to choose one value from a set of discrete values, often either a listbox or menu button is simpler to implement and use. One feature of combobox that distinguishes it from both listbox and menu button is that the value of the combobox is presented in an edit field. Thus, the combobox gives users one function that both listbox and menu button lack, namely the ability to select some or all of the value for copying to the clipboard. One feature that distinguishes both combobox and menu button widgets from listbox widgets is their ability to provide an undo mechanism. In many implementations, users can navigate the set of allowed values in a combobox or menu and then decide to revert to the value the widget had before navigating by pressing escape. In contrast, navigating a listbox immediately changes its value, and escape does not provide an undo mechanism.
視覚的にコンパクトで、ユーザーが離散値のセットから1つの値を選択できるウィジェットを構築する場合、多くの場合、リストボックスまたはメニューボタンのいずれかを実装して使用する方が簡単です。 リストボックスとメニューボタンの両方と区別するコンボボックスの機能の1つは、コンボボックスの値が編集フィールドに提示されることです。 このように、コンボボックスは、リストボックスとメニューボタンの両方に欠けている1つの機能、つまりクリップボードにコピーする値の一部またはすべてを選択する機能をユーザーに提供します。 コンボボックスウィジェットとメニューボタンウィジェットの両方をリストボックスウィジェットと区別する1つの機能は、元に戻すメカニズムを提供する機能です。 多くの実装では、ユーザーはコンボボックスまたはメニューで許可された値のセットをナビゲートし、Escape を押してナビゲートする前にウィジェットが持っていた値に戻すことを決定できます。 対照的に、リストボックスをナビゲートするとその値がすぐに変更され、Escape は元に戻すメカニズムを提供しません。

Note
注意

The options for a combobox to popup a grid, tree, or dialog were introduced in ARIA 1.1. Changes made in the ARIA 1.1 specification also add support for a code pattern that enables assistive technologies to present the textbox and popup as separately perceivable elements. both ARIA 1.0 and 1.1 patterns are described in the following sections. While using the ARIA 1.1 pattern is recommended as soon as assistive technology support is sufficient, there are no plans to deprecate the ARIA 1.0 pattern.
グリッド、ツリー、またはダイアログをポップアップするコンボボックスのオプションは、ARIA 1.1 で導入されました。 ARIA 1.1 仕様で行われた変更により、支援技術がテキストボックスとポップアップを別々に認識可能な要素として提示できるようにするコードパターンのサポートも追加されます。 次のセクションでは、ARIA 1.0 と 1.1 の両方のパターンについて説明します。 支援技術のサポートが十分になったらすぐに ARIA 1.1 パターンを使用することをお勧めしますが、ARIA 1.0 パターンを廃止する予定はありません。





Examples
例

    Examples of ARIA 1.1 Combobox with Listbox Popup: Comboboxes that demonstrate the various forms of autocomplete behavior using a listbox popup and use the ARIA 1.1 implementation pattern.
    リストボックスポップアップによる ARIA 1.1 コンボボックスの例：リストボックスポップアップを使用してさまざまな形式の自動補完の振る舞いを示し、ARIA 1.1 実装パターンを使用するコンボボックス。

    Example of ARIA 1.1 Combobox with Grid Popup: A combobox that presents suggestions in a grid, enabling users to navigate descriptive information about each suggestion.
    グリッドポップアップによる ARIA 1.1 コンボボックスの例：ユーザーが各提案に関する説明情報をナビゲートできるように、グリッドに提案を提示するコンボボックス。

    ARIA 1.0 Combobox with Both List and Inline Autocomplete: A combobox that demonstrates the autocomplete behavior known as "list with inline autocomplete" and uses the ARIA 1.0 implementation pattern.
    リストとインライン自動補完の両方を備えた ARIA 1.0 コンボボックス：「インライン自動補完によるリスト」と呼ばれる自動補完の振る舞いを示し、ARIA 1.0 の実装パターンを使用するコンボボックス。

    ARIA 1.0 Combobox with List Autocomplete: A combobox that demonstrates the autocomplete behavior known as "list with manual selection" and uses the ARIA 1.0 implementation pattern.
    リスト自動補完による ARIA 1.0 コンボボックス：「手動選択によるリスト」と呼ばれる自動補完の振る舞いを示し、ARIA 1.0 の実装パターンを使用するコンボボックス。

    ARIA 1.0 Combobox Without Autocomplete: A combo box that demonstrates the behavior associated with aria-autocomplete=none and uses the ARIA 1.0 implementation pattern.
    自動補完なしの ARIA 1.0 コンボボックス：aria-autocomplete=none に関連付けられた振る舞いを示し、ARIA 1.0 実装パターンを使用するコンボボックス。





Keyboard Interaction
キーボードの相互作用

    Tab: The textbox is in the page Tab sequence.
    Tab：テキストボックスはページのタブシーケンスにあります。

    Note: The popup indicator icon or button (if present), the popup, and the popup descendants are excluded from the page Tab sequence.
    注：ポップアップインジケーターのアイコンまたはボタン（存在する場合）、ポップアップ、およびポップアップの子孫は、ページのタブシーケンスから除外されます。





Textbox Keyboard Interaction
テキストボックスでのキーボードの相互作用

When focus is in the textbox:
フォーカスがテキストボックスにある場合：

    Down Arrow: If the popup is available, moves focus into the popup:
    下矢印：ポップアップが使用可能な場合、次のようにフォーカスをポップアップに移動します。

        If the autocomplete behavior automatically selected a suggestion before Down Arrow was pressed, focus is placed on the suggestion following the automatically selected suggestion.
        下矢印が押される前に自動補完の振る舞いによって提案が自動的に選択されている場合、自動的に選択された提案に続く提案にフォーカスが置かれます。

        Otherwise, places focus on the first focusable element in the popup.
        それ以外の場合、フォーカスをポップアップの最初のフォーカス可能な要素に置きます。

    Up Arrow (Optional): If the popup is available, places focus on the last focusable element in the popup.
    上矢印（任意）：ポップアップが使用可能な場合、フォーカスをポップアップ内の最後のフォーカス可能な要素に置きます。

    Escape: Dismisses the popup if it is visible. Optionally, clears the textbox.
    Escape：ポップアップが可視の場合は閉じます。 任意で、テキストボックスをクリアします。

    Enter: If an autocomplete suggestion is automatically selected, accepts the suggestion either by placing the input cursor at the end of the accepted value in the textbox or by performing a default action on the value. For example, in a messaging application, the default action may be to add the accepted value to a list of message recipients and then clear the textbox so the user can add another recipient.
    Enter：自動補完の提案が自動的に選択されている場合、テキストボックスの受け入れられた値の最後に入力カーソルを置くか、値に対してデフォルトのアクションを実行することにより、提案を受け入れます。 例えば、メッセージングアプリケーションでは、デフォルトのアクションは、受け入れられた値をメッセージ受信者のリストに追加してから、テキストボックスをクリアして、ユーザーが別の受信者を追加できるようにすることです。

    Printable Characters: Type characters in the textbox. Note that some implementations may regard certain characters as invalid and prevent their input.
    印刷可能な文字：テキストボックスに文字をタイプ入力します。 一部の実装では、特定の文字を無効と見なし、入力を妨げる場合があることに注意してください。

    Standard single line text editing keys appropriate for the device platform (see note below).
    デバイスプラットフォームに適した標準の単一行テキスト編集キー（下記の注を参照）。

    Alt + Down Arrow (Optional): If the popup is available but not displayed, displays the popup without moving focus.
    Alt + 下矢印（任意）：ポップアップは使用可能であるが表示されていない場合、フォーカスを移動せずにポップアップを表示します。

    Alt + Up Arrow (Optional): If the popup is displayed:
    Alt + 上矢印（任意）：ポップアップが表示されている場合：

        If the popup contains focus, returns focus to the textbox.
        1. ポップアップにフォーカスが含まれている場合は、フォーカスをテキストボックスに戻します。

        Closes the popup.
        2. ポップアップを閉じます。

Note
注

Standard single line text editing keys appropriate for the device platform:
デバイスプラットフォームに適した標準の単一行テキスト編集キー：

    include keys for input, cursor movement, selection, and text manipulation.
    1. 入力、カーソル移動、選択、およびテキスト操作用のキーが含まれています。

    Standard key assignments for editing functions depend on the device operating system.
    2. 編集機能の標準的なキー割り当ては、デバイスのオペレーティングシステムによって異なります。

    The most robust approach for providing text editing functions is to rely on browsers, which supply them for HTML inputs with type text and for elements with the contenteditable HTML attribute.
    3. テキスト編集機能を提供するための最も堅牢なアプローチは、ブラウザーに依存することであり、ブラウザーは、タイプ入力テキストによる HTML 入力と、contenteditable HTML 属性を持つ要素に対してそれらを提供します。

    IMPORTANT: Be sure that JavaScript does not interfere with browser-provided text editing functions by capturing key events for the keys used to perform them.
    4. 重要：JavaScript は、ブラウザーが提供するテキスト編集機能の実行に使用されるキーのキーイベントをキャプチャすることにより、ブラウザーが提供するテキスト編集機能に干渉しないようにしてください。





Listbox Popup Keyboard Interaction
リストボックスポップアップでのキーボードの相互作用

When focus is in a listbox popup:
フォーカスがリストボックスポップアップにある場合：

    Enter: Accepts the focused option in the listbox by closing the popup and placing the accepted value in the textbox with the input cursor at the end of the value.
    Enter：ポップアップを閉じて、リストボックスでフォーカスされたオプションを受け入れ、入力カーソルを値の最後に置いてテキストボックスに受け入れた値を配置します。


    Escape: Closes the popup and returns focus to the textbox. Optionally, clears the contents of the textbox.
    Escape：ポップアップを閉じて、フォーカスをテキストボックスに戻します。 任意で、テキストボックスの内容をクリアします。

    Right Arrow: Returns focus to the textbox without closing the popup and moves the input cursor one character to the right. If the input cursor is on the right-most character, the cursor does not move.
    右矢印：ポップアップを閉じずにフォーカスをテキストボックスに戻し、入力カーソルを1文字右に移動します。 入力カーソルが右端の文字にある場合、カーソルは移動しません。

    Left Arrow: Returns focus to the textbox without closing the popup and moves the input cursor one character to the left. If the input cursor is on the left-most character, the cursor does not move.
    左矢印：ポップアップを閉じずにフォーカスをテキストボックスに戻し、入力カーソルを1文字左に移動します。 入力カーソルが左端の文字にある場合、カーソルは移動しません。

    Any printable character: Returns the focus to the textbox without closing the popup and types the character.
    印刷可能な文字：ポップアップを閉じずにフォーカスをテキストボックスに戻し、文字をタイプ入力します。

    Backspace (Optional): Returns focus to the textbox and deletes the character prior to the cursor.
    Backspace（任意）：フォーカスをテキストボックスに戻し、カーソルの前の文字を削除します。

    Delete (Optional): Returns focus to the textbox, removes the selected state if a suggestion was selected, and removes the inline autocomplete string if present.
    Delete（任意）：フォーカスをテキストボックスに戻し、提案が選択されている場合は選択状態を削除し、存在する場合はインライン自動補完文字列を削除します。

    Down Arrow: Moves focus to and selects the next option. If focus is on the last option, either returns focus to the textbox or does nothing.
    下矢印：フォーカスを移動して次のオプションを選択します。 フォーカスが最後のオプションにある場合、フォーカスをテキストボックスに戻すか、何もしません。

    Up Arrow: Moves focus to and selects the previous option. If focus is on the first option, either returns focus to the textbox or does nothing.
    上矢印：フォーカスを前のオプションに移動して選択します。 フォーカスが最初のオプションにある場合、フォーカスをテキストボックスに戻すか、何もしません。

    Home (Optional): Either moves focus to and selects the first option or returns focus to the textbox and places the cursor on the first character.
    Home（任意）：フォーカスを最初のオプションに移動して選択するか、フォーカスをテキストボックスに戻してカーソルを最初の文字に置きます。

    End (Optional): Either moves focus to the last option or returns focus to the textbox and places the cursor after the last character.
    End（任意）：フォーカスを最後のオプションに移動するか、フォーカスをテキストボックスに戻し、カーソルを最後の文字の後に置きます。

Note
注

    DOM Focus is maintained on the combobox textbox and the assistive technology focus is moved within the listbox using aria-activedescendant as described in Managing Focus in Composites Using aria-activedescendant.
    1. DOM のフォーカスは、コンボボックスのテキストボックスで維持され、支援技術のフォーカスは、aria-activedescendant を使用した複合ウィジェットでのフォーカスの管理で説明されているように、aria-activedescendant を使用してリストボックス内で移動されます。

    Selection follows focus in the listbox; the listbox allows only one suggested value to be selected at a time for the textbox value.
    2. 選択はリストボックスのフォーカスに従います。 リストボックスでは、テキストボックスの値に対して一度に1つの提案値のみを選択できます。





Grid Popup Keyboard Interaction
グリッドポップアップでのキーボードの相互作用

In a grid popup, each suggested value may be represented by either a single cell or an entire row. See notes below for how this aspect of grid design effects the keyboard interaction design and the way that selection moves in response to focus movements.
グリッドポップアップでは、各提案値は、単一セルまたは行全体のいずれかで表すことができます。 グリッドデザインのこの側面がキーボードの相互作用のデザインにどのように影響するか、およびフォーカスの動きに応じて選択がどのように動くかについては、以下の注を参照してください。

    Enter: Accepts the currently selected suggested value by closing the popup and placing the selected value in the textbox with the input cursor at the end of the value.
    Enter：ポップアップを閉じて、選択されている値をテキストボックスに配置し、値の最後に入力カーソルを置くことで、現在選択されている提案値を受け入れます。

    Escape: Closes the popup and returns focus to the textbox. Optionally, clears the contents of the textbox.
    Escape：ポップアップを閉じて、フォーカスをテキストボックスに戻します。 任意で、テキストボックスの内容をクリアします。

    Any printable character: Returns the focus to the textbox without closing the popup and types the character.
    印刷可能な文字：ポップアップを閉じずにフォーカスをテキストボックスに戻し、文字をタイプ入力します。

    Backspace (Optional): Returns focus to the textbox and deletes the character prior to the cursor.
    Backspace（任意）：フォーカスをテキストボックスに戻し、カーソルの前の文字を削除します。

    Delete (Optional): Returns focus to the textbox, removes the selected state if a suggestion was selected, and removes the inline autocomplete string if present.
    Delete（任意）：フォーカスをテキストボックスに戻し、提案が選択されている場合は選択状態を削除し、存在する場合はインライン自動補完文字列を削除します。

    Right Arrow: Moves focus one cell to the right. Optionally, if focus is on the right-most cell in the row, focus may move to the first cell in the following row. If focus is on the last cell in the grid, either does nothing or returns focus to the textbox.
    右矢印：フォーカスを1セル右に移動します。 任意で、フォーカスが行の右端のセルにある場合、フォーカスは次の行の最初のセルに移動してもよい。 フォーカスがグリッドの最後のセルにある場合、何もしないか、フォーカスをテキストボックスに戻します。

    Left Arrow: Moves focus one cell to the left. Optionally, if focus is on the left-most cell in the row, focus may move to the last cell in the previous row. If focus is on the first cell in the grid, either does nothing or returns focus to the textbox.
    左矢印：フォーカスを1セル左に移動します。 任意で、フォーカスが行の左端のセルにある場合、フォーカスは前の行の最後のセルに移動してもよい。 フォーカスがグリッドの最初のセルにある場合、何もしないか、フォーカスをテキストボックスに戻します。

    Down Arrow: Moves focus one cell down. If focus is in the last row of the grid, either does nothing or returns focus to the textbox.
    下矢印：フォーカスを1セル下に移動します。 フォーカスがグリッドの最後の行にある場合、何もしないか、フォーカスをテキストボックスに戻します。

    Up Arrow: Moves focus one cell up. If focus is in the first row of the grid, either does nothing or returns focus to the textbox.
    上矢印：フォーカスを1セル上に移動します。 フォーカスがグリッドの最初の行にある場合、何もしないか、フォーカスをテキストボックスに戻します。

    Page Down (Optional): Moves focus down an author-determined number of rows, typically scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows. If focus is in the last row of the grid, focus does not move.
    Page Down（任意）：フォーカスを作成者が決定した行数だけ下に移動します。 通常はスクロールして、現在可視の行のセットの一番下の行が最初の可視行の1つになります。 フォーカスがグリッドの最後の行にある場合、フォーカスは移動しません。

    Page Up (Optional): Moves focus up an author-determined number of rows, typically scrolling so the top row in the currently visible set of rows becomes one of the last visible rows. If focus is in the first row of the grid, focus does not move.
    Page Up（任意）：フォーカスを作成者が決定した行数だけ上に移動します。 通常はスクロールして、現在可視の行のセットの一番上の行が最後の可視行の1つになります。 フォーカスがグリッドの最初の行にある場合、フォーカスは移動しません。

    Home (Optional): Either:
    Home（任意）：次のいずれか：

        Moves focus to the first cell in the row that contains focus. Or, if the grid has fewer than three cells per row or multiple suggested values per row, focus may move to the first cell in the grid.
        フォーカスをフォーカスを含む行の最初のセルに移動します。 あるいは、グリッドのセルが1行あたり3つ未満、または1行あたりの提案値が複数ある場合、フォーカスはグリッドの最初のセルに移動する可能性があります。

        Returns focus to the textbox and places the cursor on the first character.
        フォーカスをテキストボックスに戻し、カーソルを最初の文字に置きます。

    End (Optional): Either:
    End（任意）：次のいずれか：

        Moves focus to the last cell in the row that contains focus. Or, if the grid has fewer than three cells per row or multiple suggested values per row, focus may move to the last cell in the grid.
        フォーカスをフォーカスを含む行の最後のセルに移動します。 あるいは、グリッドのセルが1行あたり3つ未満、または1行あたりの提案値が複数ある場合、フォーカスはグリッドの最後のセルに移動する可能性があります。

        Returns focus to the textbox and places the cursor after the last character.
        フォーカスをテキストボックスに戻し、最後の文字の後にカーソルを置きます。

    Control + Home (optional): moves focus to the first row.
    Control + Home（任意）：フォーカスを最初の行に移動します。

    Control + End (Optional): moves focus to the last row.
    Control + End（任意）：フォーカスを最後の行に移動します。

Note
注

    DOM Focus is maintained on the combobox textbox and the assistive technology focus is moved within the grid using aria-activedescendant as described in Managing Focus in Composites Using aria-activedescendant.
    1. DOM のフォーカスはコンボボックスのテキストボックスで維持され、支援技術のフォーカスは、aria-activedescendant を使用した複合ウィジェットでのフォーカスの管理で説明されているように、aria-activedescendant を使用してグリッド内で移動されます。

    The grid allows only one suggested value to be selected at a time for the textbox value.
    2. グリッドでは、テキストボックスの値に対して一度に1つの提案値のみを選択できます。

    In a grid popup, each suggested value may be represented by either a single cell or an entire row. This aspect of design effects focus and selection movement:
    3. グリッドポップアップでは、各提案値は、単一セルまたは行全体のいずれかで表すことができます。 デザインのこの側面は、次のようにフォーカスと選択の動きに影響します。

        If every cell contains a different suggested value:
        1. すべてのセルに異なる提案値が含まれている場合：

            Selection follows focus so that the cell containing focus is selected.
            選択はフォーカスに従うため、フォーカスを含むセルが選択されます。

            Horizontal arrow key navigation typically wraps from one row to another.
            左右矢印キーのナビゲーションは通常、ある行から別の行に折り返されます。

            Vertical arrow key navigation typically wraps from one column to another.
            上下矢印キーのナビゲーションは通常、ある列から別の列に折り返されます。

        If all cells in a row contain information about the same suggested value:
        2. 1行のすべてのセルに同じ提案値に関する情報が含まれている場合：

            Either the row containing focus is selected or a cell containing a suggested value is selected when any cell in the same row contains focus.
            フォーカスが同じ行のいずれかのセルに含まれている場合は、フォーカスを含む行が選択されるか、提案値を含むセルが選択されます。

            Horizontal +++arrow +++key navigation may wrap from one row to another.
            左右矢印キーのナビゲーションは、ある行から別の行に折り返される場合があります。

            Vertical arrow key navigation does not wrap from one column to another.
            上下矢印キーのナビゲーションは、ある列から別の列に折り返されません。





Tree Popup Keyboard Interaction
ツリーポップアップでのキーボードの相互作用

In some implementations of tree popups, some or all parent nodes may serve as suggestion category labels so may not be selectable values. See notes below for how this aspect of the design effects the way selection moves in response to focus movements.
ツリーポップアップの一部の実装では、一部またはすべての親ノードが提案カテゴリーラベルとして機能するため、選択可能な値ではない場合があります。 デザインのこの側面が、フォーカスの動きに応じて選択がどのように動くかにどのように影響するかについては、以下の注を参照してください。

When focus is in a vertically oriented tree popup:
フォーカスが垂直方向のツリーポップアップにある場合：

    Enter: Accepts the currently selected suggested value by closing the popup and placing the selected value in the textbox with the input cursor at the end of the value.
    Enter：ポップアップを閉じて、選択されている値をテキストボックスに配置し、値の最後に入力カーソルを置くことで、現在選択されている提案値を受け入れます。

    Escape: Closes the popup and returns focus to the textbox. Optionally, clears the contents of the textbox.
    Escape：ポップアップを閉じて、フォーカスをテキストボックスに戻します。 任意で、テキストボックスの内容をクリアします。

    Any printable character: Returns the focus to the textbox without closing the popup and types the character.
    印刷可能な文字：ポップアップを閉じずにフォーカスをテキストボックスに戻し、文字をタイプ入力します。

    Right arrow:
    右矢印：

        When focus is on a closed node, opens the node; focus and selection do not move.
        フォーカスが閉じているノードにある場合、ノードを開きます。 フォーカスと選択は移動しません。

        When focus is on a open node, moves focus to the first child node and selects it if it is selectable.
        フォーカスが開いているノードにある場合、フォーカスを最初の子ノードに移動し、選択可能な場合はそれを選択します。

        When focus is on an end node, does nothing.
        フォーカスが末端ノードにある場合、何もしません。

    Left arrow:
    左矢印：

        When focus is on an open node, closes the node.
        フォーカスが開いているノードにある場合、ノードを閉じます。

        When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node and selects it if it is selectable.
        フォーカスが末端ノードまたは閉じているノードでもある子ノードにある場合、フォーカスをその親ノードに移動し、選択可能な場合はそれを選択します。

        When focus is on a root node that is also either an end node or a closed node, does nothing.
        フォーカスが末端ノードまたは閉じているノードでもあるルートノードにある場合、何もしません。

    Down Arrow: Moves focus to the next node that is focusable without opening or closing a node and selects it if it is selectable.
    下矢印：ノードを開いたり閉じたりせずにフォーカスをフォーカス可能な次のノードに移動し、選択可能な場合はそれを選択します。

    Up Arrow: Moves focus to the previous node that is focusable without opening or closing a node and selects it if it is selectable.
    上矢印：ノードを開いたり閉じたりせずにフォーカスをフォーカス可能な前のノードに移動し、選択可能な場合はそれを選択します。

    Home: Moves focus to the first node in the tree without opening or closing a node and selects it if it is selectable.
    Home：ノードを開いたり閉じたりせずにフォーカスをツリーの最初のノードに移動し、選択可能な場合はそれを選択します。

    End: Moves focus to the last node in the tree that is focusable without opening a node and selects it if it is selectable.
    End：ノードを開かずにフォーカスをフォーカス可能なツリー内の最後のノードに移動し、選択可能な場合はそれを選択します。

Note
注

    DOM Focus is maintained on the combobox textbox and the assistive technology focus is moved within the tree using aria-activedescendant as described in Managing Focus in Composites Using aria-activedescendant.
    1. DOM のフォーカスはコンボボックスのテキストボックスで維持され、支援技術のフォーカスは、aria-activedescendant を使用した複合ウィジェットでのフォーカスの管理で説明されているように、aria-activedescendant を使用してツリー内で移動されます。

    The tree allows only one suggested value to be selected at a time for the textbox value.
    2. ツリーでは、テキストボックスの値として一度に1つの提案値のみを選択できます。

    In a tree popup, some or all parent nodes may not be selectable values; they may serve as category labels for suggested values. If focus moves to a node that is not a selectable value, either:
    3. ツリーポップアップでは、一部またはすべての親ノードが選択可能な値ではない場合があります。 それらは、提案値のカテゴリーラベルとして機能する場合があります。 フォーカスが選択可能な値ではないノードに移動した場合は、次のいずれかです。

        The previously selected node, if any, remains selected until focus moves to a node that is selectable.
        以前に選択されたノードがある場合は、フォーカスが選択可能なノードに移動するまで選択されたままになります。

        There is no selected value.
        選択されている値はありません。

        In either case, focus is visually distinct from selection so users can readily see if a value is selected or not.
        いずれの場合も、フォーカスは選択と視覚的に区別されるため、ユーザーは値が選択されているかどうかを簡単に確認できます。

    If the nodes in a tree are arranged horizontally:
    4. ツリー内のノードが水平に配置されている場合：

        Down Arrow performs as Right Arrow is described above, and vice versa.
        1. 下矢印は、上記の右矢印と同様に機能し、その逆も同様です。

        Up Arrow performs as Left Arrow is described above, and vice versa.
        2. 上矢印は、上記の左矢印と同様に機能し、その逆も同様です。





Dialog Popup Keyboard Interaction
ダイアログポップアップでのキーボードの相互作用

When focus is in a dialog popup:
ダイアログポップアップにフォーカスがある場合：

    There are two ways to close the popup and return focus to the textbox:
    ポップアップを閉じてフォーカスをテキストボックスに戻すには、次の2つの方法があります。

        Perform an action in the dialog, such as activate a button, that specifies a value for the textbox.
        テキストボックスの値を指定するボタンのアクティブ化などのアクションをダイアログで実行します。

        Cancel out of the dialog, e.g., press Escape or activate the cancel button in the dialog. Canceling either returns focus to the text box without changing the textbox value or returns focus to the textbox and clears the textbox.
        ダイアログからキャンセルします。 例えば、Escape を押すか、ダイアログのキャンセルボタンをアクティブ化します。 キャンセルすると、テキストボックスの値を変更せずにテキストボックスにフォーカスが戻るか、テキストボックスにフォーカスが戻ってテキストボックスがクリアされます。

    The dialog implements the keyboard interaction defined in the modal dialog pattern.
    ダイアログは、モーダルダイアログのパターンで定義されたキーボードの相互作用を実装します。

Note
注

Unlike other combobox popups, dialogs do not support aria-activedescendant so DOM focus moves into the dialog from the textbox.
他のコンボボックスのポップアップとは異なり、ダイアログは aria-activedescendant をサポートしていないため、DOM のフォーカスはテキストボックスからダイアログに移動します。




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

The role, state, and property guidance where the ARIA 1.1 and ARIA 1.0 patterns differ is listed first. The subsequent guidance applies to both patterns.
ARIA 1.1 と ARIA 1.0 のパターンで異なるロール、状態、およびプロパティのガイダンスが最初にリストされています。 後続のガイダンスは、両方のパターンに適用されます。

    In a combobox implementing the ARIA 1.1 pattern:
    ARIA 1.1 パターンを実装するコンボボックスの場合：

        The element that serves as the combobox container has role combobox.
        コンボボックスコンテナーとして機能する要素には、コンボボックス（combobox）ロールがあります。

        The element with role combobox contains or owns a textbox element that has either role textbox or role searchbox.
        コンボボックスロールを持つ要素には、テキストボックス（textbox）ロールまたは検索ボックス（searchbox）ロールのいずれかを持つテキストボックス要素が含まれているか、所有されています。

        When the combobox popup is visible, the combobox element contains or owns an element that has role listbox, tree, grid, or dialog.
        コンボボックスのポップアップが可視の場合、コンボボックス要素には、リストボックス（listbox）、ツリー（tree）、グリッド（（grid）、またはダイアログ（dialog）のロールを持つ要素が含まれているか、所有されています。

        If the combobox popup has a role other than listbox, the element with role combobox has aria-haspopup set to a value that corresponds to the popup type. That is, aria-haspopup is set to grid, tree, or dialog. Note that elements with role combobox have an implicit aria-haspopup value of listbox.
        コンボボックスのポップアップにリストボックス以外のロールがある場合、コンボボックスロールを持つ要素では、ポップアップタイプに対応する値に設定された aria-haspopup があります。 つまり、aria-haspopup は grid、tree、または dialog に設定されます。 コンボボックスロールを持つ要素には、listbox の暗黙的な aria-haspopup 値があることに注意してください。

        When the combobox popup is visible, the textbox element has aria-controls set to a value that refers to the combobox popup element.
        コンボボックスのポップアップが可視の場合、テキストボックス要素の aria-controls は、コンボボックスのポップアップ要素を参照する値に設定されています。

    In a combobox implementing the ARIA 1.0 pattern:
    ARIA 1.0 パターンを実装するコンボボックスの場合：

        The element that serves as the textbox has role combobox.
        テキストボックスとして機能する要素には、コンボボックス（combobox）ロールがあります。

        When the combobox popup is visible, the element with role combobox has aria-owns set to a value that refers to an element with role listbox.
        コンボボックスのポップアップが可視の場合、コンボボックスロールを持つ要素には、リストボックス（listbox）ロールを持つ要素を参照する値に設定された aria-owns があります。

        the element with role combobox has a value for aria-haspopup of listbox. Note that elements with role combobox have an implicit aria-haspopup value of listbox.
        コンボボックスロールを持つ要素には、listbox の aria-haspopup の値があります。 コンボボックスロールを持つ要素には、listbox の暗黙的な aria-haspopup 値があることに注意してください。

    The textbox element has a value for aria-multiline of false. Note that the default value of aria-multiline is false.
    テキストボックス要素には、false の aria-multiline の値があります。 aria-multiline のデフォルト値は false であることに注意してください。

    When the combobox popup is not visible, the element with role combobox has aria-expanded set to false. When the popup element is visible, aria-expanded is set to true. Note that elements with role combobox have a default value for aria-expanded of false.
    コンボボックスのポップアップが可視でない場合、コンボボックスロールを持つ要素の aria-expanded は false に設定されています。 ポップアップ要素が可視の場合、aria-expanded は true に設定されます。 コンボボックスロールを持つ要素は、aria-expanded のデフォルト値が false であることに注意してください。

    When a combobox receives focus, DOM focus is placed on the textbox element.
    コンボボックスがフォーカスを受け取ると、DOM のフォーカスがテキストボックス要素に配置されます。

    When a descendant of a listbox, grid, or tree popup is focused, DOM focus remains on the textbox and the textbox has aria-activedescendant set to a value that refers to the focused element within the popup.
    リストボックス、グリッド、またはツリーのポップアップの子孫にフォーカスがある場合、DOM のフォーカスはテキストボックスに残り、テキストボックスには、ポップアップ内のフォーカスされた要素を参照する値に設定された aria-activedescendant があります。

    In a combobox with a listbox, grid, or tree popup, when a suggested value is visually indicated as the currently selected value, the option, gridcell, row, or treeitem containing that value has aria-selected set to true.
    リストボックス、グリッド、またはツリーのポップアップのあるコンボボックスで、提案値が現在選択されている値として視覚的に示される場合、その値を含むオプション（option）、グリッドセル（gridcell）、行（row）、またはツリー項目（treeitem）では、aria-selected が true に設定されます。

    If the combobox has a visible label, the element with role combobox has aria-labelledby set to a value that refers to the labelling element. Otherwise, the combobox element has a label provided by aria-label.
    コンボボックスに可視ラベルがある場合、コンボボックスロールを持つ要素には、ラベル付け要素を参照する値に設定された aria-labelledby があります。 それ以外の場合、コンボボックス要素には aria-label によって提供されるラベルがあります。

    The textbox element has aria-autocomplete set to a value that corresponds to its autocomplete behavior:
    テキストボックス要素には、次のオートコンプリートの振る舞いに対応する値に設定された aria-autocomplete があります。

        none: When the popup is displayed, the suggested values it contains are the same regardless of the characters typed in the textbox.
        none：ポップアップが表示されるとき、ポップアップに含まれる提案値は、テキストボックスにタイプ入力された文字に関係なく同じです。

        list: When the popup is triggered, it presents suggested values that complete or logically correspond to the characters typed in the textbox.
        list：ポップアップがトリガーされると、テキストボックスにタイプ入力された文字に完全に対応する、または論理的に対応する提案値が示されます。

        both: When the popup is triggered, it presents suggested values that complete or logically correspond to the characters typed in the textbox. In addition, the portion of the selected suggestion that has not been typed by the user, known as the "completion string", appears inline after the input cursor in the textbox. The inline completion string is visually highlighted and has a selected state.
        both：ポップアップがトリガーされると、テキストボックスにタイプ入力された文字に完全に対応する、または論理的に対応する提案値が示されます。 さらに、選択された提案のうち、ユーザーが入力していない部分（「補完文字列」と呼ばれる）は、テキストボックスの入力カーソルの後にインラインで現れます。 インライン補完文字列は視覚的に強調表示され、選択状態になっています。

Note
注

    When referring to the roles, states, and properties documentation for the below list of patterns used for popups, keep in mind that a combobox is a single-select widget where selection always follows focus in the popup.
    1. 以下のポップアップに使用されるパターンのリストについて、ロール、状態、およびプロパティの文書を参照する場合、コンボボックスは単一選択ウィジェットであり、選択は常にポップアップのフォーカスに従うことに注意してください。

    The roles, states, and properties for popup elements are defined in their respective design patterns:
    2. ポップアップ要素のロール、状態、およびプロパティは、それぞれのデザインパターンで定義されています。

        Listbox Roles, States, and Properties
        リストボックスのロール、状態、およびプロパティ

        Grid Roles, States, and Properties
        グリッドのロール、状態、およびプロパティ

        Tree Roles, States, and Properties
        ツリーのロール、状態、およびプロパティ

        Dialog Roles, States, and Properties
        ダイアログのロール、状態、およびプロパティ





3.9 Dialog (Modal)
3.9 ダイアログ（モーダル）

A dialog is a window overlaid on either the primary window or another dialog window. Windows under a modal dialog are inert. That is, users cannot interact with content outside an active dialog window. Inert content outside an active dialog is typically visually obscured or dimmed so it is difficult to discern, and in some implementations, attempts to interact with the inert content cause the dialog to close.
ダイアログ（dialog）は、プライマリーウィンドウまたは別のダイアログウィンドウのいずれかにオーバーレイされるウィンドウです。 モーダルダイアログ（modal dialog）の下のウィンドウは不活性です。 つまり、ユーザーはアクティブなダイアログウィンドウの外でコンテンツを操作することはできません。 アクティブなダイアログの外側の不活性コンテンツは、通常、視覚的に隠されているか、淡色表示されているため、識別が困難であり、一部の実装では、不活性コンテンツと対話しようとすると、ダイアログが閉じてしまうことがあります。

Like non-modal dialogs, modal dialogs contain their tab sequence. That is, Tab and Shift + Tab do not move focus outside the dialog. However, unlike most non-modal dialogs, modal dialogs do not provide means for moving keyboard focus outside the dialog window without closing the dialog.
非モーダルダイアログ（non-modal dialog）と同様に、モーダルダイアログにはそれ固有のタブシーケンスが含まれています。 つまり、Tab キーと Shift + Tab キーはダイアログの外にフォーカスを移動しません。 ただし、ほとんどの非モーダルダイアログとは異なり、モーダルダイアログは、ダイアログを閉じずにキーボードフォーカスをダイアログウィンドウの外に移動する手段を提供しません。

The alertdialog role is a special-case dialog role designed specifically for dialogs that divert users' attention to a brief, important message. Its usage is described in the alert dialog design pattern.
アラートダイアログ（alertdialog）ロールは、ユーザーの注意を簡潔で重要なメッセージに向けるダイアログ用に特別に設計された特殊なダイアログロールです。 その使用法は、アラートダイアログのデザインパターンで説明されています。




Examples
例

    Modal Dialog Example: Demonstrates multiple layers of modal dialogs with both small and large amounts of content.
     モーダルダイアログの例：少量と大量の両方のコンテンツを含むモーダルダイアログの複数階層を示します。

    Date Picker Dialog Example: Demonstrates a dialog containing a calendar grid for choosing a date.
     日付ピッカーダイアログの例：日付を選択するためのカレンダーグリッドを含むダイアログを示します。





Keyboard Interaction
キーボードの相互作用

In the following description, the term "tabbable element" refers to any element with a tabindex value of zero or greater. Note that values greater than 0 are strongly discouraged.
以下の説明では、「タブ可能な要素」という用語は、タブインデックス（tabindex）値がゼロ以上の要素を指します。 0 より大きい値は強く推奨されないことに注意してください。

    When a dialog opens, focus moves to an element inside the dialog. See notes below regarding initial focus placement.
    ダイアログが開くと、フォーカスはダイアログ内の要素に移動します。 初期フォーカスの配置については、以下の注を参照してください。

    Tab:

        Moves focus to the next tabbable element inside the dialog.
        フォーカスをダイアログ内の次のタブ可能な要素に移動します。

        If focus is on the last tabbable element inside the dialog, moves focus to the first tabbable element inside the dialog.
        ダイアログ内の最後のタブ可能な要素にフォーカスがある場合、フォーカスをダイアログ内の最初のタブ可能な要素に移動します。

    Shift + Tab:

        Moves focus to the previous tabbable element inside the dialog.
        フォーカスをダイアログ内の前のタブ可能な要素に移動します。

        If focus is on the first tabbable element inside the dialog, moves focus to the last tabbable element inside the dialog.
        ダイアログ内の最初のタブ可能な要素にフォーカスがある場合、フォーカスをダイアログ内の最後のタブ可能な要素に移動します。

    Escape: Closes the dialog.
    Escape：ダイアログを閉じます。

Note
注

    When a dialog opens, focus placement depends on the nature and size of the content.
    1. ダイアログが開いたときのフォーカスの配置は、コンテンツの性質とサイズによって異なります。

        In all circumstances, focus moves to an element contained in the dialog.
        すべての状況で、フォーカスはダイアログに含まれる要素に移動します。

        Unless a condition where doing otherwise is advisable, focus is initially set on the first focusable element.
        他の方法で行うことが推奨される条件でない限り、フォーカスは最初に最初のフォーカス可能な要素に設定されます。

        If content is large enough that focusing the first interactive element could cause the beginning of content to scroll out of view, it is advisable to add tabindex="-1" to a static element at the top of the dialog, such as the dialog title or first paragraph, and initially focus that element.
        コンテンツが十分に大きいため、最初のインタラクティブな要素にフォーカスを当てるとコンテンツの先頭がスクロールして表示されなくなる可能性がある場合は、ダイアログのタイトルや最初の段落など、ダイアログの上部にある静的要素に tabindex="-1" を追加して、最初にその要素にフォーカスを当てることをお勧めします。

        If a dialog contains the final step in a process that is not easily reversible, such as deleting data or completing a financial transaction, it may be advisable to set focus on the least destructive action, especially if undoing the action is difficult or impossible. The Alert Dialog Pattern is often employed in such circumstances.
        データの削除や金融取引の完了など、簡単に元に戻せないプロセスの最終ステップがダイアログに含まれている場合、特にアクションを元に戻すことが困難または不可能な場合は、最も破壊的でないアクションにフォーカスを当てることをお勧めします。 アラートダイアログのパターンは、このような状況でよく使用されます。

        If a dialog is limited to interactions that either provide additional information or continue processing, it may be advisable to set focus to the element that is likely to be most frequently used, such as an "OK" or "Continue" button.
        ダイアログが追加情報を提供するか処理を続行する相互作用に限定されている場合は、「OK」ボタンや「続行」ボタンなど、最も頻繁に使用される可能性のある要素にフォーカスを設定することをお勧めします。

    When a dialog closes, focus returns to the element that invoked the dialog unless either:
    2. ダイアログが閉じると、次のいずれかを除いて、フォーカスはダイアログを呼び出した要素に戻ります。

        The invoking element no longer exists. Then, focus is set on another element that provides logical work flow.
        呼び出し元の要素はもう存在しません。 次に、論理的なワークフローを提供する別の要素にフォーカスを当てます。

        The work flow design includes the following conditions that can occasionally make focusing a different element a more logical choice:
        ワークフローの設計には、次の条件が含まれており、時として異なる要素にフォーカスを当てることがより論理的な選択になる場合があります。

            It is very unlikely users need to immediately re-invoke the dialog.
            1. ユーザーがすぐにダイアログを再度呼び出す必要はほとんどありません。

            The task completed in the dialog is directly related to a subsequent step in the work flow.
            2. ダイアログで完了したタスクは、ワークフローの後続のステップに直接関連しています。

        For example, a grid has an associated toolbar with a button for adding rows. the Add Rows button opens a dialog that prompts for the number of rows. After the dialog closes, focus is placed in the first cell of the first new row.
        例えば、グリッドには、行を追加するためのボタンが関連付けられたツールバーがあります。 行の追加ボタンをクリックすると、行数の入力を求めるダイアログが開きます。 ダイアログが閉じた後、フォーカスは最初の新しい行の最初のセルに配置されます。

    It is strongly recommended that the tab sequence of all dialogs include a visible element with role button that closes the dialog, such as a close icon or cancel button.
    3. すべてのダイアログのタブシーケンスに、閉じるアイコンやキャンセルボタンなど、ダイアログを閉じるボタンロールを持つ可視要素を含めることを強くお勧めします。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that serves as the dialog container has a role of dialog.
    ダイアログコンテナーとして機能する要素には、ダイアログ（dialog）ロールがあります。

    All elements required to operate the dialog are descendants of the element that has role dialog.
    ダイアログを操作するために必要なすべての要素は、ダイアログロールを持つ要素の子孫です。

    The dialog container element has aria-modal set to true.
    ダイアログコンテナー要素では、aria-modal が true に設定されています。

    The dialog has either:
    ダイアログには次のいずれかがあります。

        A value set for the aria-labelledby property that refers to a visible dialog title.
        可視のダイアログのタイトルを参照する aria-labelledby プロパティに設定された値。

        A label specified by aria-label.
        aria-label で指定されたラベル。

    Optionally, the aria-describedby property is set on the element with the dialog role to indicate which element or elements in the dialog contain content that describes the primary purpose or message of the dialog. Specifying descriptive elements enables screen readers to announce the description along with the dialog title and initially focused element when the dialog opens.
    任意で、aria-describeby プロパティは、ダイアログロールを持つ要素に設定され、ダイアログ内のどの要素に、ダイアログの主な目的またはメッセージを説明するコンテンツが含まれるかを示します。 説明要素を指定すると、スクリーンリーダーは、ダイアログが開いたときに、ダイアログのタイトルと最初にフォーカスされた要素とともに説明をアナウンスできます。

Note
注

    Because marking a dialog modal by setting aria-modal to true can prevent users of some assistive technologies from perceiving content outside the dialog, users of those technologies will experience severe negative ramifications if a dialog is marked modal but does not behave as a modal for other users. So, mark a dialog modal only when both:
    aria-modal を true に設定してダイアログをモーダルにマークすると、一部の支援技術のユーザーがダイアログの外部のコンテンツを認識できなくなる可能性があるため、それらの技術のユーザーは、ダイアログがモーダルとマークされていても他のユーザーにはモーダルとして振る舞わない場合、深刻な悪影響を経験します。 したがって、次の両方の場合にのみ、ダイアログをモーダルとしてマークします。

        Application code prevents all users from interacting in any way with content outside of it.
        1. アプリケーションコードは、すべてのユーザーがその外部のコンテンツと何らかの方法で対話することを防ぎます。

        Visual styling obscures the content outside of it.
        2. 視覚的なスタイリングは、その外側のコンテンツを覆い隠します。

    The aria-modal property introduced by ARIA 1.1 replaces aria-hidden for informing assistive technologies that content outside a dialog is inert. However, in legacy dialog implementations where aria-hidden is used to make content outside a dialog inert for assistive technology users, it is important that:
    ARIA 1.1 によって導入された aria-modal プロパティは、ダイアログ外のコンテンツが不活性であることを支援技術に通知するための aria-hidden を置き換えます。 ただし、aria-hidden を使用してダイアログ外のコンテンツを支援技術ユーザーに対して不活性にする従来のダイアログ実装では、次のことが重要です。

        aria-hidden is set to true on each element containing a portion of the inert layer.
        1. aria-hidden は、不活性階層の一部を含む各要素で true に設定されます。

        The dialog element is not a descendant of any element that has aria-hidden set to true.
        2. ダイアログ要素は、aria-hidden が true に設定されている要素の子孫ではありません。





3.10 Disclosure (Show/Hide)
3.10 開示（表示/非表示）

A disclosure is a button that controls visibility of a section of content. When the controlled content is hidden, it is often styled as a typical push button with a right-pointing arrow or triangle to hint that activating the button will display additional content. When the content is visible, the arrow or triangle typically points down.
開示（disclosure）は、コンテンツのセクションの可視性を制御するボタンです。 制御されたコンテンツが非表示になっている場合、ボタンをアクティブ化すると追加のコンテンツが表示されることを示唆する右向きの矢印または三角形が付いた一般的なプッシュボタンのスタイルになることがよくあります。 コンテンツが可視の場合、矢印または三角形は通常下向きです。




Examples
例

    Disclosure (Show/Hide) of Image Description
     画像の説明の開示（表示/非表示）

    Disclosure (Show/Hide) of Answers to Frequently Asked Questions
     よくある質問への回答の開示（表示/非表示）

    Disclosure (Show/Hide) for Navigation Menus
     ナビゲーションメニューの開示（表示/非表示）





Keyboard Interaction
キーボードの相互作用

When the disclosure control has focus:
開示コントロールにフォーカスが当てられている場合：

    Enter: activates the disclosure control and toggles the visibility of the disclosure content.
     Enter：開示コントロールをアクティブ化し、開示コンテンツの表示を切り替えます。

    Space: activates the disclosure control and toggles the visibility of the disclosure content.
     スペース：開示コントロールをアクティブ化し、開示コンテンツの表示を切り替えます。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that shows and hides the content has role button.
     コンテンツを表示および非表示にする要素には、ボタン（button）ロールがあります。

    When the content is visible, the element with role button has aria-expanded set to true. When the content area is hidden, it is set to false.
     コンテンツが可視の場合、ボタンロールのある要素の aria-expanded は true に設定されています。 コンテンツ領域が非表示の場合、false に設定されます。

    Optionally, the element with role button has a value specified for aria-controls that refers to the element that contains all the content that is shown or hidden.
     任意で、ボタンロールのある要素には、表示または非表示のすべてのコンテンツを含む要素を参照する aria-controls に指定された値があります。





3.11 Feed
3.11 フィード

A feed is a section of a page that automatically loads new sections of content as the user scrolls. The sections of content in a feed are presented in article elements. So, a feed can be thought of as a dynamic list of articles that often appears to scroll infinitely.
フィード（feed）は、ユーザーがスクロールするとコンテンツの新しいセクションを自動的に読み込むページのセクションです。 フィード内のコンテンツのセクションは、記事（article）要素で示されます。 したがって、フィードは、無限にスクロールするように見える記事の動的リストと考えることができます。

The feature that most distinguishes feed from other ARIA patterns that support loading data as users scroll, e.g., a grid, is that a feed is a structure, not a widget. Consequently, assistive technologies with a reading mode, such as screen readers, default to reading mode when interacting with feed content. However, unlike most other WAI-ARIA structures, a feed establishes an interoperability contract between the web page and assistive technologies. The contract governs scroll interactions so that assistive technology users can read articles, jump forward and backward by article, and reliably trigger new articles to load while in reading mode.
フィードを、ユーザーがスクロールするときにデータを読み込むことをサポートする他の ARIA パターン（グリッドなど）と最も区別する機能は、フィードがウィジェットではなく構造であるということです。 その結果、スクリーンリーダーなどの読み取りモードを備えた支援技術は、フィードコンテンツを操作するときにデフォルトで読み取りモードになります。 ただし、他のほとんどの WAI-ARIA 構造とは異なり、フィードはウェブページと支援技術の間の相互運用性の契約を確立します。 契約はスクロールの相互作用を管理するため、支援技術のユーザーは記事を読んだり、記事ごとに前後にジャンプしたり、読み取りモードで新しい記事を確実に読み込んだりできます。

For example, a product page on a shopping site may have a related products section that displays five products at a time. As the user scrolls, more products are requested and loaded into the DOM. While a static design might include a next button for loading five more products, a dynamic implementation that automatically loads more data as the user scrolls simplifies the user experience and reduces the inertia associated with viewing more than the first five product suggestions. But, unfortunately when web pages load content dynamically based on scroll events, it can cause usability and interoperability difficulties for users of assistive technologies.
例えば、ショッピングサイトの商品ページには、一度に5つの商品を表示する関連商品セクションがある場合があります。 ユーザーがスクロールすると、より多くの製品が要求され、DOM に読み込まれます。 静的な設計にはさらに5つの製品を読み込むための次へボタンが含まれる場合がありますが、ユーザーがスクロールすると自動的により多くのデータを読み込む動的な実装により、ユーザーエクスペリエンスが簡素化され、最初の5つ以上の製品提案の表示に関連する慣性が軽減されます。 ただし、残念ながら、ウェブページがスクロールイベントに基づいてコンテンツを動的に読み込むと、支援技術のユーザーにとって使いやすさと相互運用性の問題が発生する可能性があります。

The feed pattern enables reliable assistive technology reading mode interaction by establishing the following interoperability agreement between the web page and assistive technologies:
フィードのパターンは、ウェブページと支援技術の間に次のような相互運用性の合意を確立することにより、信頼性の高い支援技術の読み取りモードの相互作用を可能にします。

    In the context of a feed, the web page code is responsible for:
    1. フィードのコンテキストでは、ウェブページのコードは次の責任があります。

        Appropriate visual scrolling of the content based on which article contains DOM focus.
        どの記事に DOM のフォーカスが含まれているかに基づいて、コンテンツを適切に視覚的にスクロールします。

        Loading or removing feed articles based on which article contains DOM focus.
        DOM のフォーカスが含まれている記事に基づいてフィード記事を読み込みまたは削除します。

    In the context of a feed, assistive technologies with a reading mode are responsible for:
    2. フィードのコンテキストでは、読み取りモードを備えた支援技術が次の責任を負います。

        Indicating which article contains the reading cursor by ensuring the article element or one of its descendants has DOM focus.
        記事要素またはその子孫の1つに DOM のフォーカスがあることを確認して、どの記事に読み取りカーソルが含まれているかを示します。

        providing reading mode keys that move DOM focus to the next and previous articles.
        DOM のフォーカスを次の記事と前の記事に移動する読み取りモードキーを提供します。

        Providing reading mode keys for moving the reading cursor and DOM focus past the end and before the start of the feed.
        フィードの終わりと始めを超えて、読み取りカーソルと DOM のフォーカスを移動するための読み取りモードキーを提供します。

Thus, implementing the feed pattern allows a screen reader to reliably read and trigger the loading of feed content while staying in its reading mode.
このように、フィードのパターンを実装すると、スクリーンリーダーは、読み取りモードを維持したまま、フィードコンテンツを確実に読み取り、読み込みをトリガーできます。

Another feature of the feed pattern is its ability to facilitate skim reading for assistive technology users. Web page authors may provide both an accessible name and description for each article. By identifying the elements inside of an article that provide the title and the primary content, assistive technologies can provide functions that enable users to jump from article to article and efficiently discern which articles may be worthy of more attention.
フィードのパターンのもう1つの機能は、支援技術のユーザーが速読を容易に行えることです。 ウェブページの作成者は、各記事にアクセス可能な名前と説明の両方を提供できます。 タイトルと主要コンテンツを提供する記事内の要素を識別することにより、支援技術は、ユーザーが記事から記事にジャンプし、どの記事がより注目に値するかを効率的に識別することを可能にする機能を提供できます。




Example
例

Example Implementation of Feed Pattern
フィードのパターンの実装例




Keyboard Interaction
キーボードの相互作用

The feed pattern is not based on a desktop GUI widget so the feed role is not associated with any well-established keyboard conventions. Supporting the following, or a similar, interface is recommended.
フィードのパターンはデスクトップ GUI ウィジェットに基づいていないため、フィードロールは確立されたキーボード規則に関連付けられていません。 次のようなインターフェイスをサポートすることをお勧めします。

When focus is inside the feed:
フォーカスがフィード内にある場合：

    Page Down: Move focus to next article.
     Page Down：フォーカスを次の記事に移動します。

    Page Up: Move focus to previous article.
     Page Up：フォーカスを前の記事に移動します。

    Control + End: Move focus to the first focusable element after the feed.
     Control + End：フォーカスをフィードの後の最初のフォーカス可能な要素に移動します。

    Control + Home: Move focus to the first focusable element before the feed.
     Control + Home：フォーカスをフィードの前の最初のフォーカス可能な要素に移動します。

Note
注

    Due to the lack of convention, providing easily discoverable keyboard interface documentation is especially important.
    1. 慣例がないため、簡単に見つけられるキーボードインターフェイスの文書を提供することが特に重要です。

    In some cases, a feed may contain a nested feed. For example, an article in a social media feed may contain a feed of comments on that article. To navigate the nested feed, users first move focus inside the nested feed. Options for supporting nested feed navigation include:
    2. 場合によっては、フィードにネストされたフィードが含まれることがあります。 例えば、ソーシャルメディアフィードの記事には、その記事に対するコメントのフィードが含まれている場合があります。 ネストされたフィードをナビゲートするには、ユーザーは最初にネストされたフィード内にフォーカスを移動します。 ネストされたフィードのナビゲーションをサポートするためのオプションは次のとおりです。

        Users move focus into the nested feed from the content of the containing article with Tab. This may be slow if the article contains a significant number of links, buttons, or other widgets.
        ユーザーは、Tab キーを使用して、含まれている記事のコンテンツからネストされたフィードにフォーカスを移動します。 記事に多数のリンク、ボタン、またはその他のウィジェットが含まれている場合、これは遅くなる可能性があります。

        Provide a key for moving focus from the elements in the containing article to the first item in the nested feed, e.g., Alt + Page Down.
        含まれている記事の要素からネストされたフィードの最初の項目にフォーカスを移動するためのキーを提供します（例：Alt + Page Down）。

        To continue reading the outer feed, Control + End moves focus to the next article in the outer feed.
        外側のフィードを読み続けるには、Control + End でフォーカスを外側のフィードの次の記事に移動します。

    In the rare circumstance that a feed article contains a widget that uses the above suggested keys, the feed navigation key will operate the contained widget, and the user needs to move focus to an element that does not utilize the feed navigation keys in order to navigate the feed.
    3. フィード記事に上記の提案されたキーを使用するウィジェットが含まれているというまれな状況では、フィードナビゲーションキーは含まれているウィジェットを操作するので、ユーザーはフィードをナビゲートするためにフィードナビゲーションキーを使用しない要素にフォーカスを移動する必要があります。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that contains the set of feed articles has role feed.
    フィード記事のセットを含む要素には、フィード（feed）ロールがあります。

    If the feed has a visible label, the feed element has aria-labelledby referring to the element containing the title. Otherwise, the feed element has a label specified with aria-label.
    フィードに可視ラベルがある場合、フィード要素には、タイトルを含む要素を参照することによって aria-labelled が付けられます。 それ以外の場合、フィード要素には aria-label で指定されたラベルがあります。

    Each unit of content in a feed is contained in an element with role article. All content inside the feed is contained in an article element.
    フィード内の各コンテンツ単位は、記事（article）ロールを持つ要素に含まれています。 フィード内のすべてのコンテンツは、記事（article）要素に含まれています。

    Each article element has aria-labelledby referring to elements inside the article that can serve as a distinguishing label.
    各記事要素には、識別ラベルとして機能できる記事内の要素を参照する、aria-labelledby があります。

    It is optional but strongly recommended for each article element to have aria-describedby referring to one or more elements inside the article that serve as the primary content of the article.
    任意ですが、記事の主要コンテンツとして機能する記事内の1つ以上の要素を参照して、各記事要素に aria-describedby を付けることを強くお勧めします。

    Each article element has aria-posinset set to a value that represents its position in the feed.
    各記事要素には、フィード内での位置を表す値に設定された aria-posinset があります。

    Each article element has aria-setsize set to a value that represents either the total number of articles that have been loaded or the total number in the feed, depending on which value is deemed more helpful to users. If the total number in the feed is undetermined, it can be represented by a aria-setsize value of -1.
    各記事要素の aria-setsize は、ユーザーにとってより役立つと思われる値に応じて、読み込まれた記事の総数またはフィード内の総数のいずれかを表す値に設定されています。 フィード内の総数が不明な場合は、aria-setsize 値の -1 で表すことができます。

    When article elements are being added to or removed from the feed container, and if the operation requires multiple DOM operations, the feed element has aria-busy set to true during the update operation. Note that it is extremely important that aria-busy is set to false when the operation is complete or the changes may not become visible to some assistive technology users.
    記事要素がフィードコンテナーに追加またはフィードコンテナーから削除され、操作で複数の DOM 操作が必要な場合、更新操作中にフィード要素の aria-busy が true に設定されます。 操作が完了したときに aria-busy を false に設定することは非常に重要であることに注意してください。 そうしないと、一部の支援技術ユーザーには変更が可視にならない場合があります。





3.12 Grids : Interactive Tabular Data and Layout Containers
3.12 グリッド：インタラクティブな表形式データとレイアウトコンテナー

A grid widget is a container that enables users to navigate the information or interactive elements it contains using directional navigation keys, such as arrow keys, Home, and End. As a generic container widget that offers flexible keyboard navigation, it can serve a wide variety of needs. It can be used for purposes as simple as grouping a collection of checkboxes or navigation links or as complex as creating a full-featured spreadsheet application. While the words "row" and "column" are used in the names of WAI-ARIA attributes and by assistive technologies when describing and presenting the logical structure of elements with the grid role, using the grid role on an element does not necessarily imply that its visual presentation is tabular.
グリッド（grid）ウィジェットは、ユーザーが矢印キー、Home、End などの方向ナビゲーションキーを使用して、そこに含まれる情報要素またはインタラクティブ要素をナビゲートできるようにするコンテナーです。 柔軟なキーボードナビゲーションを提供する汎用コンテナーウィジェットとして、さまざまなニーズに対応できます。 チェックボックスやナビゲーションリンクのコレクションをグループ化するような単純な目的にも、フル機能のスプレッドシートアプリケーションを作成するような複雑な目的にも使用できます。 "row" （行）と "column"（列）という言葉は、WAI-ARIA 属性の名前で使用され、グリッドロールを持つ要素の論理構造を記述および提示する際に支援技術によって使用されますが、要素でグリッドロールを使用することはその視覚的表現が表形式であることを必ずしも意味するわけではありません。

When presenting content that is tabular, consider the following factors when choosing between implementing this grid pattern or the table pattern.
表形式のコンテンツを提示する場合は、このグリッドのパターンとテーブルのパターンのどちらを実装するかを選択する際に、次の要因を考慮してください。

    A grid is a composite widget so it:
    グリッドは複合ウィジェットであるため、次のようになります。

        Always contains multiple focusable elements.
        常に複数のフォーカス可能な要素が含まれています。

        Only one of the focusable elements contained by the grid is included in the page tab sequence.
        グリッドに含まれるフォーカス可能な要素のうち1つだけが、ページのタブシーケンスに含まれます。

        Requires the author to provide code that manages focus movement inside it.
        作成者は、その中のフォーカスの動きを管理するコードを提供する必要があります。

    All focusable elements contained in a table are included in the page tab sequence.
    テーブルに含まれるすべてのフォーカス可能な要素は、ページのタブシーケンスに含まれます。

Uses of the grid pattern broadly fall into two categories: presenting tabular information (data grids) and grouping other widgets (layout grids). Even though both data grids and layout grids employ the same ARIA roles, states, and properties, differences in their content and purpose surface factors that are important to consider in keyboard interaction design. To address these factors, the following two sections describe separate keyboard interaction patterns for data and layout grids.
グリッドのパターンの使用は、大きく2つのカテゴリに分類されます。 表形式の情報の提示（データグリッド）と他のウィジェットのグループ化（レイアウトグリッド）です。 データグリッドとレイアウトグリッドの両方が同じ ARIA のロール、状態、およびプロパティを採用している場合でも、その内容と目的の違いは、キーボードの相互作用のデザインで考慮すべき重要な要因です。 これらの要因に対処するために、次の2つのセクションでは、データグリッドとレイアウトグリッドの個別のキーボードの相互作用のパターンについて説明します。




Examples
例

    Layout Grid Examples: Three example implementations of grids that are used to lay out widgets, including a collection of navigation links, a message recipients list, and a set of search results.
     レイアウトグリッドの例：ナビゲーションリンクのコレクション、メッセージ受信者リスト、検索結果のセットなど、ウィジェットのレイアウトに使用されるグリッドの3つの実装例。

    Data Grid Examples: Three example implementations of grid that include features relevant to presenting tabular information, such as content editing, sort, and column hiding.
     データグリッドの例：コンテンツの編集、並べ替え、列の非表示など、表形式の情報の提示に関連する機能を含むグリッドの3つの実装例。

    Advanced Data Grid Example: Example of a grid with behaviors and features similar to a typical spreadsheet, including cell and row selection.
     高度なデータグリッドの例：セルと行の選択など、一般的なスプレッドシートと同様の振る舞いと機能を備えたグリッドの例。





Data Grids For Presenting Tabular Information
表形式の情報を提示するためのデータグリッド

A grid can be used to present tabular information that has column titles, row titles, or both. The grid pattern is particularly useful if the tabular information is editable or interactive. For example, when data elements are links to more information, rather than presenting them in a static table and including the links in the tab sequence, implementing the grid pattern provides users with intuitive and efficient keyboard navigation of the grid contents as well as a shorter tab sequence for the page. A grid may also offer functions, such as cell content editing, selection, cut, copy, and paste.
グリッドを使用して、列タイトル、行タイトル、またはその両方を含む表形式の情報を提示できます。 グリッドのパターンは、表形式の情報が編集可能またはインタラクティブである場合に特に役立ちます。 例えば、データ要素が静的テーブルに提示されてタブシーケンスにリンクを含めるのではなく、より多くの情報へのリンクである場合、グリッドのパターンを実装すると、グリッドコンテンツの直感的で効率的なキーボードナビゲーションと、より短いページのタブシーケンスがユーザーに提供されます。 グリッドは、セルコンテンツの編集、選択、切り取り、コピー、貼り付けなどの機能も提供する場合があります。

In a grid, every cell contains a focusable element or is itself focusable, regardless of whether the cell content is editable or interactive. There is one exception: if column or row header cells do not provide functions, such as sort or filter, they do not need to be focusable. One reason it is important for all cells to be able to receive or contain keyboard focus is that screen readers will typically be in their application reading mode, rather than their document reading mode, when users are interacting with the grid. While in application mode, a screen reader user hears only focusable elements and content that labels focusable elements. So, screen reader users may unknowingly overlook elements contained in a grid that are either not focusable or not used to label a column or row.
グリッドでは、セルのコンテンツが編集可能であるかインタラクティブであるかに関係なく、すべてのセルにフォーカス可能な要素が含まれるか、それ自体がフォーカス可能です。 例外が1つあります。 列または行のヘッダーセルが並べ替えやフィルターなどの機能を提供しない場合、フォーカス可能である必要はありません。 すべてのセルがキーボードフォーカスを受け取ったり含むことが重要である理由の1つは、ユーザーがグリッドを操作しているとき、スクリーンリーダーは通常、文書読み取りモードではなく、アプリケーション読み取りモードになるためです。 アプリケーションモードでは、スクリーンリーダーのユーザーには、フォーカス可能な要素と、フォーカス可能な要素にラベルを付けるコンテンツのみが聞こえます。 そのため、スクリーンリーダーのユーザーは、フォーカスできないか、列または行のラベル付けに使用されないグリッドに含まれる要素を知らないうちに見落とす可能性があります。




Keyboard Interaction For Data Grids
データグリッドのキーボードの相互作用

The following keys provide grid navigation by moving focus among cells of the grid. Implementations of grid make these key commands available when an element in the grid has received focus, e.g., after a user has moved focus to the grid with Tab.
次のキーは、グリッドのセル間でフォーカスを移動することにより、グリッドのナビゲーションを提供します。 グリッドの実装により、グリッド内の要素がフォーカスを受け取ったとき、例えば、ユーザーが Tab キーを使用してグリッドにフォーカスを移動した後などに、これらのキーコマンドを使用できるようになります。

    Right Arrow: Moves focus one cell to the right. If focus is on the right-most cell in the row, focus does not move.
    右矢印：フォーカスを1セル右に移動します。 行の右端のセルにフォーカスがある場合、フォーカスは移動しません。

    Left Arrow: Moves focus one cell to the left. If focus is on the left-most cell in the row, focus does not move.
    左矢印：フォーカスを1セル左に移動します。 行の左端のセルにフォーカスがある場合、フォーカスは移動しません。

    Down Arrow: Moves focus one cell down. If focus is on the bottom cell in the column, focus does not move.
    下矢印：フォーカスを1セル下に移動します。 列の一番下のセルにフォーカスがある場合、フォーカスは移動しません。

    Up Arrow: Moves focus one cell Up. If focus is on the top cell in the column, focus does not move.
    上矢印：フォーカスを1セル上に移動します。 フォーカスが列の一番上のセルにある場合、フォーカスは移動しません。

    Page Down: Moves focus down an author-determined number of rows, typically scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows. If focus is in the last row of the grid, focus does not move.
    Page Down：フォーカスを作成者が決定した行数だけ下に移動します。 通常はスクロールして、現在可視の行のセットの一番下の行が最初の可視行の1つになります。 フォーカスがグリッドの最後の行にある場合、フォーカスは移動しません。

    Page Up: Moves focus up an author-determined number of rows, typically scrolling so the top row in the currently visible set of rows becomes one of the last visible rows. If focus is in the first row of the grid, focus does not move.
    Page Up：フォーカスを作成者が決定した行数だけ上に移動します。 通常はスクロールして、現在可視の行のセットの一番上の行が最後の可視行の1つになります。 フォーカスがグリッドの最初の行にある場合、フォーカスは移動しません。

    Home: moves focus to the first cell in the row that contains focus.
    Home：フォーカスをフォーカスを含む行の最初のセルに移動します。

    End: moves focus to the last cell in the row that contains focus.
    End：フォーカスをフォーカスを含む行の最後のセルに移動します。

    Control + Home: moves focus to the first cell in the first row.
    Control + Home：フォーカスを最初の行の最初のセルに移動します。

    Control + End: moves focus to the last cell in the last row.
    Control + End：フォーカスを最後の行の最後のセルに移動します。

Note
注

    When the above grid navigation keys move focus, whether the focus is set on an element inside the cell or the grid cell depends on cell content. See Whether to Focus on a Cell or an Element Inside It.
    上記のグリッドナビゲーションキーがフォーカスを移動する場合、フォーカスがセル内の要素に設定されているか、グリッドセルに設定されているかは、セルコンテンツによって異なります。 セルまたはその中の要素のどちらにフォーカスを当てるかを参照してください。

    While navigation keys, such as arrow keys, are moving focus from cell to cell, they are not available to do something like operate a combobox or move an editing caret inside of a cell. If this functionality is needed, see Editing and Navigating Inside a Cell.
    矢印キーなどのナビゲーションキーがセル間でフォーカスを移動している間は、コンボボックスの操作やセル内の編集キャレットの移動などを行うことはできません。 この機能が必要な場合は、セル内の編集とナビゲートを参照してください。

    If navigation functions can dynamically add more rows or columns to the DOM, key events that move focus to the beginning or end of the grid, such as control + End, may move focus to the last row in the DOM rather than the last available row in the back-end data.
    ナビゲーション機能が動的に行または列を DOM に追加できる場合、Control + End など、フォーカスをグリッドの最初または最後に移動するキーイベントは、バックエンドデータ（サーバー側）で使用可能な最後の行ではなく、DOM の最後の行にフォーカスを移動する場合があります。

If a grid supports selection of cells, rows, or columns, the following keys are commonly used for these functions.
グリッドがセル、行、または列の選択をサポートしている場合、これらの機能には通常、次のキーが使用されます。

    Control + Space: selects the column that contains the focus.
    Control + スペース：フォーカスを含む列を選択します。

    Shift + Space: Selects the row that contains the focus. If the grid includes a column with checkboxes for selecting rows, this key can serve as a shortcut for checking the box when focus is not on the checkbox.
    Shift + スペース：フォーカスを含む行を選択します。 グリッドに行を選択するためのチェックボックスのある列が含まれている場合、このキーは、フォーカスがチェックボックスにないときにチェックボックスをオンにするためのショートカットとして機能します。

    Control + A: Selects all cells.
    Control + A：すべてのセルを選択します。

    Shift + Right Arrow: Extends selection one cell to the right.
    Shift + 右矢印：選択範囲を1セル右に拡張します。

    Shift + Left Arrow: Extends selection one cell to the left.
    Shift + 左矢印：選択範囲を1セル左に拡張します。

    Shift + Down Arrow: Extends selection one cell down.
    Shift + 下矢印：選択範囲を1セル下に拡張します。

    Shift + Up Arrow: Extends selection one cell Up.
    Shift + 上矢印：選択範囲を1セル上に拡張します。

Note
注

See § 6.8 Key Assignment Conventions for Common Functions for cut, copy, and paste key assignments.
切り取り、コピー、貼り付けのキー割り当てについては、§6.8 共通機能のキー割り当て規則を参照してください。




Layout Grids for Grouping Widgets
ウィジェットをグループ化するためのレイアウトグリッド

The grid pattern can be used to group a set of interactive elements, such as links, buttons, or checkboxes. Since only one element in the entire grid is included in the tab sequence, grouping with a grid can dramatically reduce the number of tab stops on a page. This is especially valuable if scrolling through a list of elements dynamically loads more of those elements from a large data set, such as in a continuous list of suggested products on a shopping site. If elements in a list like this were in the tab sequence, keyboard users are effectively trapped in the list. If any elements in the group also have associated elements that appear on hover, the grid pattern is also useful for providing keyboard access to those contextual elements of the user interface.
グリッドのパターンを使用して、リンク、ボタン、チェックボックスなどのインタラクティブな要素のセットをグループ化できます。 グリッド全体で1つの要素のみがタブシーケンスに含まれるため、グリッドでグループ化すると、ページ上のタブストップの数を大幅に減らすことができます。 これは、要素のリストをスクロールしていくことで、ショッピングサイトで提案された製品の連続リストなど、大きなデータセットからそれらの要素を動的に読み込む場合に特に役立ちます。 このようなリストの要素がタブシーケンスに含まれている場合、キーボードユーザーは事実上リストに閉じ込められます。 グループ内のいずれかの要素に、ホバーに表示される関連要素もある場合、グリッドのパターンは、ユーザーインターフェイスのそれらのコンテキスト要素へのキーボードアクセスを提供するのにも役立ちます。

Unlike grids used to present data, A grid used for layout does not necessarily have header cells for labelling rows or columns and might contain only a single row or a single column. Even if it has multiple rows and columns, it may present a single, logically homogenous set of elements. For example, a list of recipients for a message may be a grid where each cell contains a link that represents a recipient. The grid may initially have a single row but then wrap into multiple rows as recipients are added. In such circumstances, grid navigation keys may also wrap so the user can read the list from beginning to end by pressing either Right Arrow or Down Arrow. While This type of focus movement wrapping can be very helpful in a layout grid, it would be disorienting if used in a data grid, especially for users of assistive technologies.
データの提示に使用されるグリッドとは異なり、レイアウトに使用されるグリッドには、必ずしも行または列にラベルを付けるためのヘッダーセルがなく、単一行または単一列のみが含まれる場合があります。 複数の行と列がある場合でも、論理的に同種の単一の要素セットが提示される場合があります。 例えば、メッセージの受信者のリストは、各セルに受信者を表すリンクが含まれているグリッドである場合があります。 グリッドには最初は1つの行がありますが、受信者が追加されると複数の行に折り返されます。 このような状況では、グリッドナビゲーションキーも折り返される可能性があるため、ユーザーは右矢印または下矢印を押してリストを最初から最後まで読むことができます。 このタイプのフォーカス移動の折り返しは、レイアウトグリッドでは非常に役立ちますが、データグリッドで使用すると、特に支援技術のユーザーにとっては混乱を招くことになります。

Because arrow keys are used to move focus inside of a grid, a grid is both easier to build and use if the components it contains do not require the arrow keys to operate. If a cell contains an element like a listbox, then an extra key command to focus and activate the listbox is needed as well as a command for restoring the grid navigation functionality. Approaches to supporting this need are described in the section on Editing and Navigating Inside a Cell.
矢印キーはグリッド内でフォーカスを移動するために使用されるため、グリッドに含まれるコンポーネントが操作するために矢印キーを必要としない場合、グリッドの構築と使用の両方が簡単になります。 セルにリストボックスなどの要素が含まれている場合は、リストボックスにフォーカスしてアクティブ化するための追加のキーコマンドと、グリッドナビゲーション機能を復元するためのコマンドが必要です。 このニーズをサポートするためのアプローチは、セル内の編集とナビゲートのセクションで説明されています。




Keyboard Interaction For Layout Grids
レイアウトグリッドのキーボードの相互作用

The following keys provide grid navigation by moving focus among cells of the grid. Implementations of grid make these key commands available when an element in the grid has received focus, e.g., after a user has moved focus to the grid with Tab.
次のキーは、グリッドのセル間でフォーカスを移動することにより、グリッドのナビゲーションを提供します。 グリッドの実装により、グリッド内の要素がフォーカスを受け取ったとき、例えば、ユーザーがタブを使用してグリッドにフォーカスを移動した後などに、これらのキーコマンドを使用できるようになります。

    Right Arrow: Moves focus one cell to the right. Optionally, if focus is on the right-most cell in the row, focus may move to the first cell in the following row. If focus is on the last cell in the grid, focus does not move.
    右矢印：フォーカスを1セル右に移動します。 任意で、フォーカスが行の右端のセルにある場合、フォーカスは次の行の最初のセルに移動する場合があります。 フォーカスがグリッドの最後のセルにある場合、フォーカスは移動しません。

    Left Arrow: Moves focus one cell to the left. Optionally, if focus is on the left-most cell in the row, focus may move to the last cell in the previous row. If focus is on the first cell in the grid, focus does not move.
    左矢印：フォーカスを1セル左に移動します。 任意で、フォーカスが行の左端のセルにある場合、フォーカスは前の行の最後のセルに移動する場合があります。 フォーカスがグリッドの最初のセルにある場合、フォーカスは移動しません。

    Down Arrow: Moves focus one cell down. Optionally, if focus is on the bottom cell in the column, focus may move to the top cell in the following column. If focus is on the last cell in the grid, focus does not move.
    下矢印：フォーカスを1セル下に移動します。 任意で、フォーカスが列の一番下のセルにある場合、フォーカスは次の列の一番上のセルに移動する場合があります。 フォーカスがグリッドの最後のセルにある場合、フォーカスは移動しません。

    Up Arrow: Moves focus one cell up. Optionally, if focus is on the top cell in the column, focus may move to the bottom cell in the previous column. If focus is on the first cell in the grid, focus does not move.
    上矢印：フォーカスを1セル上に移動します。 任意で、フォーカスが列の一番上のセルにある場合、フォーカスは前の列の一番下のセルに移動する場合があります。 フォーカスがグリッドの最初のセルにある場合、フォーカスは移動しません。

    Page Down (Optional): Moves focus down an author-determined number of rows, typically scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows. If focus is in the last row of the grid, focus does not move.
    Page Down（任意）：フォーカスを作成者が決定した行数だけ下に移動します。 通常はスクロールして、現在可視の行のセットの一番下の行が最初の可視行の1つになります。 フォーカスがグリッドの最後の行にある場合、フォーカスは移動しません。

    Page Up (Optional): Moves focus up an author-determined number of rows, typically scrolling so the top row in the currently visible set of rows becomes one of the last visible rows. If focus is in the first row of the grid, focus does not move.
    Page Up（任意）：フォーカスを作成者が決定した行数だけ上に移動します。 通常はスクロールして、現在可視の行のセットの一番上の行が最後の可視行の1つになります。 フォーカスがグリッドの最初の行にある場合、フォーカスは移動しません。

    Home: moves focus to the first cell in the row that contains focus. Optionally, if the grid has a single column or fewer than three cells per row, focus may instead move to the first cell in the grid.
    Home：フォーカスをフォーカスを含む行の最初のセルに移動します。 任意で、グリッドの列が1つであるか、行ごとにセルが3つ未満の場合、代わりにフォーカスがグリッドの最初のセルに移動することがあります。

    End: moves focus to the last cell in the row that contains focus. Optionally, if the grid has a single column or fewer than three cells per row, focus may instead move to the last cell in the grid.
    End：フォーカスをフォーカスを含む行の最後のセルに移動します。 任意で、グリッドの列が1つであるか、行ごとにセルが3つ未満の場合、代わりにフォーカスがグリッドの最後のセルに移動することがあります。

    Control + Home (optional): moves focus to the first cell in the first row.
    Control + Home（任意）：フォーカスを最初の行の最初のセルに移動します。

    Control + End (Optional): moves focus to the last cell in the last row.
    Control + End（任意）：フォーカスを最後の行の最後のセルに移動します。

Note
注

    When the above grid navigation keys move focus, whether the focus is set on an element inside the cell or the grid cell depends on cell content. See Whether to Focus on a Cell or an Element Inside It.
     上記のグリッドナビゲーションキーがフォーカスを移動する場合、フォーカスがセル内の要素に設定されているか、グリッドセルに設定されているかは、セルコンテンツによって異なります。 セルまたはその中の要素のどちらにフォーカスを当てるかを参照してください。

    While navigation keys, such as arrow keys, are moving focus from cell to cell, they are not available to do something like operate a combobox or move an editing caret inside of a cell. If this functionality is needed, see Editing and Navigating Inside a Cell.
     矢印キーなどのナビゲーションキーがセル間でフォーカスを移動している間は、コンボボックスの操作やセル内の編集キャレットの移動などを行うことはできません。 この機能が必要な場合は、セル内の編集とナビゲートを参照してください。

    If navigation functions can dynamically add more rows or columns to the DOM, key events that move focus to the beginning or end of the grid, such as control + End, may move focus to the last row in the DOM rather than the last available row in the back-end data.
     ナビゲーション機能が動的に行または列を DOM に追加できる場合、Control + End など、フォーカスをグリッドの最初または最後に移動するキーイベントは、バックエンドデータ（サーバー側）で使用可能な最後の行ではなく、DOM の最後の行にフォーカスを移動する場合があります。

It would be unusual for a layout grid to provide functions that require cell selection. If it did, though, the following keys are commonly used for these functions.
レイアウトグリッドがセルの選択を必要とする機能を提供することは珍しいでしょう。 ただし、そうしたければ、これらの機能には次のキーが一般的に使用されます。

    Control + Space: selects the column that contains the focus.
    Control + スペース：フォーカスを含む列を選択します。

    Shift + Space: Selects the row that contains the focus. If the grid includes a column with checkboxes for selecting rows, this key can serve as a shortcut for checking the box when focus is not on the checkbox.
    Shift + Space：フォーカスを含む行を選択します。 グリッドに行を選択するためのチェックボックスのある列が含まれている場合、このキーは、フォーカスがチェックボックスにないときにチェックボックスをオンにするためのショートカットとして機能します。

    Control + A: Selects all cells.
    Control + A：すべてのセルを選択します。

    Shift + Right Arrow: Extends selection one cell to the right.
    Shift + 右矢印：選択範囲を1セル右に拡張します。

    Shift + Left Arrow: Extends selection one cell to the left.
    Shift + 左矢印：選択範囲を1セル左に拡張します。

    Shift + Down Arrow: Extends selection one cell down.
    Shift + 下矢印：選択範囲を1セル下に拡張します。

    Shift + Up Arrow: Extends selection one cell Up.
    Shift + 上矢印：選択範囲を1セル上に拡張します。

Note
注

See § 6.8 Key Assignment Conventions for Common Functions for cut, copy, and paste key assignments.
切り取り、コピー、貼り付けのキー割り当てについては、§6.8 共通機能のキー割り当て規則を参照してください。




Keyboard Interaction - Setting Focus and Navigating Inside Cells
キーボードの相互作用 - フォーカスの設定とセル内のナビゲート

This section describes two important aspects of keyboard interaction design shared by both data and layout grid patterns:
このセクションでは、次のようなデータグリッドとレイアウトグリッドの両方のパターンで共有されるキーボードの相互作用のデザインの2つの重要な側面について説明します。

    Choosing whether a cell or an element inside a cell receives focus in response to grid navigation key events.
    1. グリッドナビゲーションキーのイベントに応答して、セルまたはセル内の要素がフォーカスを受け取るかどうかを選択します。

    Enabling grid navigation keys to be used to interact with elements inside of a cell.
    2. グリッドナビゲーションキーを使用して、セル内の要素を操作できるようにします。




Whether to Focus on a Cell Or an Element Inside It
セルまたはその中の要素のどちらにフォーカスを当てるか

For assistive technology users, the quality of experience when navigating a grid heavily depends on both what a cell contains and on where keyboard focus is set. For example, if a cell contains a button and a grid navigation key places focus on the cell instead of the button, screen readers announce the button label but do not tell users a button is present.
支援技術のユーザーにとって、グリッドをナビゲートするときのエクスペリエンスの品質は、セルに含まれるものとキーボードフォーカスが設定されている場所の両方に大きく依存します。 例えば、セルにボタンが含まれていて、グリッドナビゲーションキーがボタンではなくセルにフォーカスを置く場合、スクリーンリーダーはボタンのラベルをアナウンスしますが、ボタンが存在することをユーザーには知らせません。

There are two optimal cell design and focus behavior combinations:
次のような2つの最適なセルのデザインとフォーカスの振る舞いの組み合わせがあります。

    A cell contains one widget whose operation does not require arrow keys and grid navigation keys set focus on that widget. Examples of such widgets include link, button, menubutton, toggle button, radio button (not radio group), switch, and checkbox.
    1. セルには、操作に矢印キーを必要としないウィジェットが1つ含まれており、グリッドナビゲーションキーはそのウィジェットにフォーカスを設定します。 このようなウィジェットの例には、リンク、ボタン、メニューボタン、トグルボタン、ラジオボタン（ラジオグループではない）、スイッチ、およびチェックボックスが含まれます。

    A cell contains text or a single graphic and grid navigation keys set focus on the cell.
    2. セルにはテキストまたは単一のグラフィックが含まれており、グリッドナビゲーションキーはセルにフォーカスを設定します。

While any combination of widgets, text, and graphics may be included in a single cell, grids that do not follow one of these two cell design and focus movement patterns add complexity for authors or users or both. The reference implementations included in the example section below demonstrate some strategies for making other cell designs as accessible as possible, but the most widely accessible experiences are likely to come by applying the above two patterns.
ウィジェット、テキスト、グラフィックの任意の組み合わせを1つのセルに含めることができますが、これら2つのセルのデザインとフォーカスの移動パターンのいずれにも従わないグリッドは、作成者またはユーザー、あるいはその両方にとって複雑さを増すことになります。 以下の例のセクションに含まれるリファレンス実装は、他のセルのデザインを可能な限りアクセス可能にするためのいくつかの戦略を示していますが、最も広くアクセス可能なエクスペリエンスは、上記の2つのパターンを適用することによってもたらされる可能性があります。




Editing and Navigating Inside a Cell
セル内の編集とナビゲート

While navigation keys, such as arrow keys, are moving focus from cell to cell, they are not available to perform actions like operate a combobox or move an editing caret inside of a cell. The user may need keys that are used for grid navigation to operate elements inside a cell if a cell contains:
矢印キーなどのナビゲーションキーはセル間でフォーカスを移動させますが、コンボボックスの操作やセル内の編集キャレットの移動などのアクションを実行することはできません。 セルに次のものが含まれている場合、セル内の要素を操作するためにグリッドナビゲーションに使用されるキーが必要になる場合があります。

    Editable content.
    1. 編集可能なコンテンツ。

    Multiple widgets.
    2. 複数のウィジェット。

    A widget that utilizes arrow keys in its interaction model, such as a radio group or slider.
    3. ラジオグループやスライダーなど、相互作用モデルで矢印キーを利用するウィジェット。

Following are common keyboard conventions for disabling and restoring grid navigation functions.
以下は、グリッドナビゲーション機能を無効にしてから復元するための一般的なキーボード規則です。

    Enter: Disables grid navigation and:
    Enter：グリッドナビゲーションを無効にし、さらに：

        If the cell contains editable content, places focus in an input field, such as a textbox. If the input is a single-line text field, a subsequent press of Enter may either restore grid navigation functions or move focus to an input field in a neighboring cell.
        セルに編集可能なコンテンツが含まれている場合は、フォーカスをテキストボックスなどの入力フィールドに置きます。 入力が単一行テキストフィールドの場合、続いて Enter キーを押すと、グリッドナビゲーション機能が復元されるか、隣接するセルの入力フィールドにフォーカスが移動します。

        If the cell contains one or more widgets, places focus on the first widget.
        セルに1つ以上のウィジェットが含まれている場合、フォーカスを最初のウィジェットに置きます。

    F2:+++ Disables grid navigation and:+++
    F2：グリッドナビゲーションを無効にし、さらに：

        If the cell contains editable content, places focus in an input field, such as a textbox. A subsequent press of F2 restores grid navigation functions.
        セルに編集可能なコンテンツが含まれている場合は、フォーカスをテキストボックスなどの入力フィールドに置きます。 続いて F2 を押すと、グリッドナビゲーション機能が復元されます。

        If the cell contains one or more widgets, places focus on the first widget. A subsequent press of F2 restores grid navigation functions.
        セルに1つ以上のウィジェットが含まれている場合、フォーカスを最初のウィジェットに置きます。 続いて F2 を押すと、グリッドナビゲーション機能が復元されます。

    Alphanumeric keys: If the cell contains editable content, places focus in an input field, such as a textbox.
    英数字キー：セルに編集可能なコンテンツが含まれている場合、フォーカスをテキストボックスなどの入力フィールドに置きます。

When grid navigation is disabled, conventional changes to navigation behaviors include:
グリッドナビゲーションが無効にされている場合、従来のナビゲーションの振る舞いへの変更には次のものがあります。

    Escape: restores grid navigation. If content was being edited, it may also undo edits.
    Escape：グリッドナビゲーションを復元します。 コンテンツが編集されていた場合は、編集を元に戻すこともできます。

    Right Arrow or Down Arrow: If the cell contains multiple widgets, moves focus to the next widget inside the cell, optionally wrapping to the first widget if focus is on the last widget. Otherwise, passes the key event to the focused widget.
    右矢印または下矢印：セルに複数のウィジェットが含まれている場合、フォーカスをセル内の次のウィジェットに移動します。 フォーカスが最後のウィジェットにある場合は、任意で最初のウィジェットに折り返します。 それ以外の場合、キーイベントをフォーカスされたウィジェットに渡します。

    Left Arrow or Up Arrow: If the cell contains multiple widgets, moves focus to the previous widget inside the cell, optionally wrapping to the ---first---+++last+++ widget if focus is on the ---last---+++first+++ widget. Otherwise, passes the key event to the focused widget.
    左矢印または上矢印：セルに複数のウィジェットが含まれている場合、フォーカスをセル内の前のウィジェットに移動します。 フォーカスが最初のウィジェットにある場合は、任意で最後のウィジェットに折り返します。 それ以外の場合、キーイベントをフォーカスされたウィジェットに渡します。

    Tab: moves focus to the next widget in the grid. Optionally, the focus movement may wrap inside a single cell or within the grid itself.
    Tab：フォーカスをグリッド内の次のウィジェットに移動します。 任意で、フォーカスの動きは単一セル内またはグリッド自体内で折り返すことができます。

    Shift + Tab: moves focus to the previous widget in the grid. Optionally, the focus movement may wrap inside a single cell or within the grid itself.
    Shift + Tab：フォーカスをグリッド内の前のウィジェットに移動します。 任意で、フォーカスの動きは単一セル内またはグリッド自体内で折り返すことができます。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The grid container has role grid.
    グリッドコンテナーには、グリッド（grid）ロールがあります。

    Each row container has role row and is either a DOM descendant of or owned by the grid element or an element with role rowgroup.
    各行コンテナーには、行（row）ロールがあり、グリッド要素または、行グループ（rowgroup）ロールを持つ要素の DOM の子孫であるか、所有されています。

    Each cell is either a DOM descendant of or owned by a row element and has one of the following roles:
    各セルは、行要素の DOM の子孫であるか、行要素によって所有されており、次のいずれかのロールを持ちます。

        columnheader if the cell contains a title or header information for the column.
        セルに列のタイトルまたはヘッダー情報が含まれている場合は、列ヘッダー（columnheader）。

        rowheader if the cell contains title or header information for the row.
        セルに行のタイトルまたはヘッダー情報が含まれている場合は、行ヘッダー（rowheader）。

        gridcell if the cell does not contain column or row header information.
        セルに列または行のヘッダー情報が含まれていない場合は、グリッドセル（gridcell）。

    If there is an element in the user interface that serves as a label for the grid, aria-labelledby is set on the grid element with a value that refers to the labelling element. Otherwise, a label is specified for the grid element using aria-label.
    グリッドのラベルとして機能する要素がユーザーインターフェイスにある場合、aria-labelledby は、ラベル付け要素を参照する値でグリッド要素に設定されます。 それ以外の場合、aria-label を使用してグリッド要素にラベルが指定されます。

    If the grid has a caption or description, aria-describedby is set on the grid element with a value referring to the element containing the description.
    グリッドにキャプションまたは説明がある場合、aria-describedby は、説明を含む要素を参照する値でグリッド要素に設定されます。

    If the grid provides sort functions, aria-sort is set to an appropriate value on the header cell element for the sorted column or row as described in the section on grid and table properties.
    グリッドが並べ替え機能を提供する場合、グリッドとテーブルのプロパティのセクションで説明されているように、並べ替えられた列または行のヘッダーセル要素で aria-sort が適切な値に設定されます。

    If the grid supports selection, when a cell or row is selected, the selected element has aria-selected set true. If the grid supports column selection and a column is selected, all cells in the column have aria-selected set to true.
    グリッドが選択をサポートしている場合、セルまたは行が選択されると、選択された要素は aria-selected が true になります。 グリッドが列の選択をサポートし、列が選択されている場合、列内のすべてのセルで aria-selected が true に設定されます。

    If the grid provides content editing functionality and contains cells that may have edit capabilities disabled in certain conditions, aria-readonly may be set true on cells where editing is disabled. If edit functions are disabled for all cells, aria-readonly may be set true on the grid element. Grids that do not provide editing functions do not include the aria-readonly attribute on any of their elements.
    グリッドがコンテンツ編集機能を提供し、特定の条件で編集機能が無効化されている可能性のあるセルが含まれている場合、編集が無効化されているセルで aria-readonly が true に設定される場合があります。 すべてのセルで編集機能が無効化されている場合、グリッド要素で aria-readonly が true に設定される場合があります。 編集機能を提供しないグリッドには、その要素のいずれにも aria-readonly 属性が含まれていません。

    If there are conditions where some rows or columns are hidden or not present in the DOM, e.g., data is dynamically loaded when scrolling or the grid provides functions for hiding rows or columns, the following properties are applied as described in the section on grid and table properties.
    一部の行または列が非表示または DOM に存在しないという条件がある場合、例えば、スクロール時にデータが動的に読み込まれる場合、またはグリッドが行または列を非表示にする機能を提供する場合、グリッドとテーブルのプロパティのセクションで説明されているように、次のプロパティが適用されます。

        aria-colcount or aria-rowcount is set to the total number of columns or rows, respectively.
        aria-colcount または aria-rowcount は、それぞれ列または行の総数に設定されます。

        aria-colindex or aria-rowindex is set to the position of a cell within a row or column, respectively.
        aria-colindex または aria-rowindex は、それぞれ行内または列内のセルの位置に設定されます。

    If the grid includes cells that span multiple rows or multiple columns, and if the grid role is NOT applied to an HTML table element, then aria-rowspan or aria-colspan is applied as described in grid and table properties.
    グリッドに複数の行または複数の列にまたがるセルが含まれ、グリッドロールが HTML テーブル要素に適用されていない場合、グリッドとテーブルのプロパティで説明されているように、aria-rowspan または aria-colspan が適用されます。

Note
注

    If the element with the grid role is an HTML table element, then it is not necessary to use ARIA roles for rows and cells because the HTML elements have implied ARIA semantics. For example, an HTML <TR> has an implied ARIA role of row. A grid built from an HTML table that includes cells that span multiple rows or columns must use HTML rowspan and colspan and must not use aria-rowspan or aria-colspan.
    グリッドロールを持つ要素が HTML テーブル要素である場合、HTML 要素は ARIA の意味論を暗示しているため、行とセルに ARIA ロールを使用する必要はありません。 例えば、HTML <TR> には、暗黙の ARIA 行ロールがあります。 複数の行または列にまたがるセルを含む HTML テーブルから構築されたグリッドは、HTML の rowspan と colspan を使用する必要があり、aria-rowspan または aria-colspan を使用してはなりません。

    If rows or cells are included in a grid via aria-owns, they will be presented to assistive technologies after the DOM descendants of the grid element unless the DOM descendants are also included in the aria-owns attribute.
    行またはセルが aria-owns を介してグリッドに含まれている場合、グリッド要素の DOM の子孫が aria-owns 属性に含まれている場合を除き、それらはグリッド要素の DOM の子孫の後に支援技術に提示されます。





3.13 Link
3.13 リンク

A link widget provides an interactive reference to a resource. The target resource can be either external or local, i.e., either outside or within the current page or application.
リンク（link）ウィジェットは、リソースへのインタラクティブな参照を提供します。 ターゲットリソースは、外部またはローカルのいずれか、つまり、現在のページまたはアプリケーションの外部または内部のどちらかにあります。

Note
注

Authors are strongly encouraged to use a native host language link element, such as an HTML <A> element with an href attribute. As with other WAI-ARIA widget roles, applying the link role to an element will not cause browsers to enhance the element with standard link behaviors, such as navigation to the link target or context menu actions. When using the link role, providing these features of the element is the author's responsibility.
作成者は、href 属性を持つ HTML <A> 要素など、ネイティブのホスト言語のリンク要素を使用することを強くお勧めします。 他の WAI-ARIA ウィジェットロールと同様に、要素にリンクロールを適用しても、ブラウザーは、リンクターゲットへのナビゲーションやコンテキストメニューアクションなどの標準のリンクの振る舞いで要素を拡張しません。 リンクロールを使用する場合、要素のこれらの機能を提供することは作成者の責任です。




Examples
例

Link Examples: Link widgets constructed from HTML span and img elements.
リンクの例：HTML のスパン（span）要素と画像（img）要素から構築されたリンクウィジェット。




Keyboard Interaction
キーボードの相互作用

    Enter: Executes the link and moves focus to the link target.
    Enter：リンクを実行し、フォーカスをリンクターゲットに移動します。

    Shift + F10 (Optional): Opens a context menu for the link.
    Shift + F10（任意）：リンクのコンテキストメニューを開きます。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

The element containing the link text or graphic has role of link.
リンクテキストまたはリンクグラフィックを含む要素には、リンク（link）ロールがあります。




3.14 Listbox
3.14 リストボックス

A listbox widget presents a list of options and allows a user to select one or more of them. A listbox that allows a single option to be chosen is a single-select listbox; one that allows multiple options to be selected is a multi-select listbox.
リストボックス（listbox）ウィジェットはオプションのリストを提示し、ユーザーがそれらの1つ以上を選択できるようにします。 単一のオプションを選択できるリストボックスは、単一選択リストボックスです。 複数のオプションを選択できるのは、複数選択リストボックスです。

When screen readers present a listbox, they may render the name, state, and position of each option in the list. The name of an option is a string calculated by the browser, typically from the content of the option element. As a flat string, the name does not contain any semantic information. Thus, if an option contains a semantic element, such as a heading, screen reader users will not have access to the semantics. In addition, the interaction model conveyed by the listbox role to assistive technologies does not support interacting with elements inside of an option. Because of these traits of the listbox widget, it does not provide an accessible way to present a list of interactive elements, such as links, buttons, or checkboxes. To present a list of interactive elements, see the grid pattern.
スクリーンリーダーがリストボックスを提示すると、リスト内の各オプションの名前、状態、および位置がレンダリングされる場合があります。 オプションの名前は、通常はオプション要素のコンテンツからブラウザーによって計算される文字列です。 フラット文字列として、名前には意味論的情報は含まれていません。 したがって、オプションに見出しなどの意味論的要素が含まれている場合、スクリーンリーダーのユーザーはその意味論にアクセスできません。 さらに、リストボックスロールによって支援技術に伝えられる相互作用モデルは、オプション内の要素との相互作用をサポートしていません。 リストボックスウィジェットにはこれらの特性があるため、リンク、ボタン、チェックボックスなどのインタラクティブな要素のリストを表示するためのアクセス可能な方法は提供されていません。 インタラクティブな要素のリストを提示するには、グリッドのパターンを参照してください。

Avoiding very long option names facilitates understandability and perceivability for screen reader users. The entire name of an option is spoken as a single unit of speech when the option is read. When too much information is spoken as the result of a single key press, it is difficult to understand. Long names inhibit perception by increasing the impact of interrupted speech because users typically have to re-read the entire option. And, if the user does not understand what is spoken, reading the name by character, word, or phrase may be a difficult operation for many screen reader users in the context of a listbox widget.
非常に長いオプション名を避けることで、スクリーンリーダーユーザーの理解と認識が容易になります。 オプションの名前全体は、オプションが読み取られるときに単一の音声単位として話されます。 キーを1回押すだけで多くの情報が話されると、理解しにくくなります。 長い名前は、ユーザーが通常オプション全体を読み直す必要があるため、中断された音声の影響を増大させることによって知覚を阻害します。 また、ユーザーが何を話しているのか理解できない場合、リストボックスウィジェットのコンテキストでは、多くのスクリーンリーダーユーザーにとって、文字、単語、またはフレーズで名前を読み取るのは難しい操作になる可能性があります。

Sets of options where each option name starts with the same word or phrase can also significantly degrade usability for keyboard and screen reader users. Scrolling through the list to find a specific option becomes inordinately time consuming for a screen reader user who must listen to that word or phrase repeated before hearing what is unique about each option. For example, if a listbox for choosing a city were to contain options where each city name were preceded by a country name, and if many cities were listed for each country, a screen reader user would have to listen to the country name before hearing each city name. In such a scenario, it would be better to have 2 list boxes, one for country and one for city.
各オプション名が同じ単語またはフレーズで始まるオプションのセットも、キーボードおよびスクリーンリーダーのユーザーの使いやすさを大幅に低下させる可能性があります。 リストをスクロールしていくことで特定のオプションを見つけることは、各オプションの独自部分を聞く前にその単語やフレーズを繰り返し聞く必要があるスクリーンリーダーユーザーにとっては非常に時間がかかります。 例えば、都市を選択するためのリストボックスに、各都市名の前に国名が付いたオプションが含まれている場合、および国ごとに多くの都市がリストされている場合、スクリーンリーダーのユーザーは各都市名を聞く前に国名を聞く必要があります。 このようなシナリオでは、国用と都市用の2つのリストボックスを用意することをお勧めします。




Examples
例

    Scrollable Listbox Example: Single-select listbox that scrolls to reveal more options, similar to HTML select with size attribute greater than one.
    スクロール可能なリストボックスの例：size 属性が 1 より大きい HTML 選択（select）要素と同様に、スクロールしてより多くのオプションを表示する単一選択リストボックス。

    Collapsible Dropdown Listbox Example: Single-select collapsible listbox that expands when activated, similar to HTML select with the attribute size="1".
    折りたたみ可能なドロップダウンリストボックスの例：size 属性が 1 の HTML 選択要素と同様に、アクティブ化されたときに展開される折りたたみ可能な単一選択リストボックス。

    Example Listboxes with Rearrangeable Options: Examples of both single-select and multi-select listboxes with accompanying toolbars where options can be added, moved, and removed.
    再配置可能なオプションを備えたリストボックスの例：オプションを追加、移動、および削除できるツールバーを備えた単一選択リストボックスと複数選択リストボックスの両方の例。





Keyboard Interaction
キーボードの相互作用

For a vertically oriented listbox:
垂直方向のリストボックスの場合：

    When a single-select listbox receives focus:
    単一選択リストボックスがフォーカスを受け取ったとき：

        If none of the options are selected before the listbox receives focus, the first option receives focus. Optionally, the first option may be automatically selected.
        リストボックスがフォーカスを受け取る前にどのオプションも選択されていない場合、フォーカスを最初のオプションが受け取ります。 任意で、最初のオプションを自動的に選択できます。

        If an option is selected before the listbox receives focus, focus is set on the selected option.
        リストボックスがフォーカスを受け取る前にオプションが選択されていた場合、フォーカスは選択されたオプションに設定されます。

    When a multi-select listbox receives focus:
    複数選択リストボックスがフォーカスを受け取ったとき：

        If none of the options are selected before the listbox receives focus, focus is set on the first option and there is no automatic change in the selection state.
        リストボックスがフォーカスを受け取る前にどのオプションも選択されていない場合、フォーカスは最初のオプションに設定され、選択状態は自動的に変更されません。

        If one or more options are selected before the listbox receives focus, focus is set on the first option in the list that is selected.
        リストボックスがフォーカスを受け取る前に1つ以上のオプションが選択されていた場合、フォーカスは選択されたリストの最初のオプションに設定されます。

    Down Arrow: Moves focus to the next option. Optionally, in a single-select listbox, selection may also move with focus.
    下矢印：フォーカスを次のオプションに移動します。 任意で、単一選択リストボックスでは、選択もフォーカスとともに移動する場合があります。

    Up Arrow: Moves focus to the previous option. Optionally, in a single-select listbox, selection may also move with focus.
    上矢印：フォーカスを前のオプションに移動します。 任意で、単一選択リストボックスでは、選択もフォーカスとともに移動する場合があります。

    Home (Optional): Moves focus to first option. Optionally, in a single-select listbox, selection may also move with focus. Supporting this key is strongly recommended for lists with more than five options.
    Home（任意）：フォーカスを最初のオプションに移動します。 任意で、単一選択リストボックスでは、選択もフォーカスとともに移動する場合があります。 このキーをサポートすることは、5つ以上のオプションがあるリストに強くお勧めします。

    End (Optional): Moves focus to last option. Optionally, in a single-select listbox, selection may also move with focus. Supporting this key is strongly recommended for lists with more than five options.
    End（任意）：フォーカスを最後のオプションに移動します。 任意で、単一選択リストボックスでは、選択もフォーカスとともに移動する場合があります。 このキーをサポートすることは、5つ以上のオプションがあるリストに強くお勧めします。

    Type-ahead is recommended for all listboxes, especially those with more than seven options:
    すべてのリストボックス、特に7つ以上のオプションがあるリストボックスには、先行タイプ入力をお勧めします。

        Type a character: focus moves to the next item with a name that starts with the typed character.
        文字をタイプ入力：フォーカスは、タイプ入力した文字で始まる名前の次の項目に移動します。

        Type multiple characters in rapid succession: focus moves to the next item with a name that starts with the string of characters typed.
        複数の文字をすばやく連続してタイプ入力：フォーカスは、タイプ入力した文字列で始まる名前の次の項目に移動します。

    Multiple Selection: Authors may implement either of two interaction models to support multiple selection: a recommended model that does not require the user to hold a modifier key, such as Shift or Control, while navigating the list or an alternative model that does require modifier keys to be held while navigating in order to avoid losing selection states.
    複数選択：作成者は、複数選択をサポートするために2つの相互作用モデルのいずれかを実装できます。 リストのナビゲート中にユーザーが Shift や Control などの修飾キーを保持する必要のない推奨モデル、または選択状態が失われないようにするために、ナビゲート中に修飾キーの保持を必要とする代替モデル。

        Recommended selection model -- holding modifier keys is not necessary:
        推奨される選択モデル -- 修飾キーを保持する必要はありません：

            Space: changes the selection state of the focused option.
            スペース：フォーカスされたオプションの選択状態を変更します。

            Shift + Down Arrow (Optional): Moves focus to and toggles the selected state of the next option.
            Shift + 下矢印（任意）：フォーカスを次のオプションに移動して選択状態をトグルします。

            Shift + Up Arrow (Optional): Moves focus to and toggles the selected state of the previous option.
            Shift + 上矢印（任意）：フォーカスを前のオプションに移動して選択状態をトグルします。

            Shift + Space (Optional): Selects contiguous items from the most recently selected item to the focused item.
            Shift + スペース（任意）：最後に選択した項目からフォーカスされた項目まで、連続する項目を選択します。

            Control + Shift + Home (Optional): Selects the focused option and all options up to the first option. Optionally, moves focus to the first option.
            Control + Shift + Home（任意）：フォーカスされたオプションと最初のオプションまでのすべてのオプションを選択します。 任意で、フォーカスを最初のオプションに移動します。

            Control + Shift + End (Optional): Selects the focused option and all options down to the last option. Optionally, moves focus to the last option.
            Control + Shift + End（任意）：フォーカスされたオプションと最後のオプションまでのすべてのオプションを選択します。 任意で、フォーカスを最後のオプションに移動します。

            Control + A (Optional): Selects all options in the list. Optionally, if all options are selected, it may also unselect all options.
            Control + A（任意）：リスト内のすべてのオプションを選択します。 任意で、すべてのオプションが選択されている場合は、すべてのオプションの選択を解除することもできます。

        Alternative selection model -- moving focus without holding a Shift or Control modifier unselects all selected nodes except the focused node:
        代替選択モデル -- Shift または Control 修飾キーを保持せずにフォーカスを移動すると、フォーカスされたノードを除くすべての選択されたノードの選択が解除されます。

            Shift + Down Arrow: Moves focus to and toggles the selection state of the next option.
            Shift + 下矢印：フォーカスを次のオプションに移動して選択状態をトグルします。

            Shift + Up Arrow: Moves focus to and toggles the selection state of the previous option.
            Shift + 上矢印：フォーカスを前のオプションに移動して選択状態をトグルします。

            Control + Down Arrow: Moves focus to the next option without changing its selection state.
            Control + 下矢印：選択状態を変更せずに、フォーカスを次のオプションに移動します。

            Control + Up Arrow: Moves focus to the previous option without changing its selection state.
            Control + 上矢印：選択状態を変更せずに、フォーカスを前のオプションに移動します。

            Control + Space+++:+++ Changes the selection state of the focused option.
            Control + スペース：フォーカスされたオプションの選択状態を変更します。

            Shift + Space (Optional): Selects contiguous items from the most recently selected item to the focused item.
            Shift + スペース（任意）：最後に選択した項目からフォーカスされた項目まで、連続する項目を選択します。

            Control + Shift + Home (Optional): Selects the focused option and all options up to the first option. Optionally, moves focus to the first option.
            Control + Shift + Home（任意）：フォーカスされたオプションと最初のオプションまでのすべてのオプションを選択します。 任意で、フォーカスを最初のオプションに移動します。

            Control + Shift + End (Optional): Selects the focused option and all options down to the last option. Optionally, moves focus to the last option.
            Control + Shift + End（任意）：フォーカスされたオプションと最後のオプションまでのすべてのオプションを選択します。 任意で、フォーカスを最後のオプションに移動します。

            Control + A (Optional): Selects all options in the list. Optionally, if all options are selected, it may also unselect all options.
            Control + A（任意）：リスト内のすべてのオプションを選択します。 任意で、すべてのオプションが選択されている場合は、すべてのオプションの選択を解除することもできます。

Note
注

    DOM focus (the active element) is functionally distinct from the selected state. For more details, see this description of differences between focus and selection.
    1. DOM のフォーカス（アクティブな要素）は、選択された状態とは機能的に異なります。 詳細については、フォーカスと選択の違いに関するこの説明を参照してください。

    The listbox role supports the aria-activedescendant property, which provides an alternative to moving DOM focus among option elements when implementing keyboard navigation. For details, see Managing Focus in Composites Using aria-activedescendant.
    2. リストボックスロールは、キーボードナビゲーションを実装するときにオプション要素間で DOM のフォーカスを移動する代わりの方法を提供する aria-activedescendant プロパティをサポートします。 詳細については、aria-activedescendant を使用した複合ウィジェットでのフォーカスの管理を参照してください。

    In a single-select listbox, moving focus may optionally unselect the previously selected option and select the newly focused option. This model of selection is known as "selection follows focus". Having selection follow focus can be very helpful in some circumstances and can severely degrade accessibility in others. For additional guidance, see Deciding When to Make Selection Automatically Follow Focus.
    3. 単一選択リストボックスでは、フォーカスを移動すると、任意で、以前に選択したオプションの選択を解除し、新しくフォーカスしたオプションを選択できます。 この選択モデルは、「選択はフォーカスに従う」として知られています。 選択をフォーカスに従わせることは、状況によっては非常に役立ち、他の状況ではアクセシビリティを大幅に低下させる可能性があります。 追加のガイダンスについては、フォーカスに従って自動的に選択を行うかの決定を参照してください。

    If selecting or unselecting all options is an important function, implementing separate controls for these actions, such as buttons for "Select All" and "Unselect All", significantly improves accessibility.
    4. すべてのオプションの選択または選択解除が重要な機能である場合、「すべて選択」および「すべて選択解除」のボタンなど、これらのアクションに個別のコントロールを実装すると、アクセシビリティが大幅に向上します。

    If the options in a listbox are arranged horizontally:
    5. リストボックスのオプションが水平に配置されている場合：

        Down Arrow performs as Right Arrow is described above, and vice versa.
        1. 下矢印は、上記の右矢印と同様に機能し、その逆も同様です。

        Up Arrow performs as Left Arrow is described above, and vice versa.
        2. 上矢印は、上記の左矢印と同様に機能し、その逆も同様です。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    An element that contains or owns all the listbox options has role listbox.
    すべてのリストボックスオプションを含む、または所有する要素には、リストボックス（listbox）ロールがあります。

    Each option in the listbox has role option and is a DOM descendant of the element with role listbox or is referenced by an aria-owns property on the listbox element.
    リストボックス内の各オプションには、オプション（option）ロールがあり、リストボックスロールを持つ要素の DOM 子孫であるか、リストボックス要素の aria-owns プロパティによって参照されます。

    If the listbox is not part of another widget, then it has a visible label referenced by aria-labelledby on the element with role listbox.
    リストボックスが別のウィジェットの一部でない場合は、リストボックスロールを持つ要素で aria-labelledby によって参照される可視ラベルがあります。

    In a single-select listbox, the selected option has aria-selected set to true.
    単一選択リストボックスでは、選択されたオプションの aria-selected が true に設定されています。

    if the listbox supports multiple selection:
    リストボックスが複数選択をサポートしている場合：

        The element with role listbox has aria-multiselectable set to true.
        リストボックスロールを持つ要素では、aria-multiselectable が true に設定されています。

        All selected options have aria-selected set to true.
        選択されたすべてのオプションで、aria-selected が true に設定されています。

        All options that are not selected have aria-selected set to false.
        選択されていないすべてのオプションでは、aria-selected が false に設定されています。

    If the complete set of available options is not present in the DOM due to dynamic loading as the user scrolls, their aria-setsize and aria-posinset attributes are set appropriately.
    ユーザーがスクロールするときに動的に読み込まれるために、使用可能なオプションの完全なセットが DOM に存在しない場合、それらの aria-setsize 属性と aria-posinset 属性が適切に設定されます。

    If options are arranged horizontally, the element with role listbox has aria-orientation set to horizontal. The default value of aria-orientation for listbox is vertical.
    オプションが水平方向に配置されている場合、リストボックスロールを持つ要素の aria-orientation は水平（horizontal）に設定されます。 リストボックスの aria-orientation のデフォルト値は垂直（vertical）です。





3.15 Menu or Menu bar
3.15 メニューやメニューバー

A menu is a widget that offers a list of choices to the user, such as a set of actions or functions. A menu is usually opened, or made visible, by activating a menu button, choosing an item in a menu that opens a sub menu, or by invoking a command, such as Shift + F10 in Windows, that opens a context specific menu. When a user activates a choice in a menu, the menu usually closes unless the choice opened a submenu.
メニュー（menu）は、一連のアクションや機能など、選択肢のリストをユーザーに提供するウィジェットです。 メニューは通常、メニューボタンをアクティブ化するか、サブメニュー（submenu）を開くメニューの項目を選択するか、Windows の Shift + F10 などのコマンドを呼び出してコンテキスト固有のメニューを開くことにより、開かれるか、可視になります。 ユーザーがメニューの選択肢をアクティブ化すると、選択肢がサブメニューを開かない限り、メニューは通常閉じます。

A menu that is visually persistent is a menubar. A menubar is typically horizontal and is often used to create a menu bar similar to those found near the top of the window in many desktop applications, offering the user quick access to a consistent set of commands.
視覚的に永続的なメニューはメニューバー（menubar）です。 メニューバーは通常水平であり、多くのデスクトップアプリケーションでウィンドウの上部にあるものと同様のメニューバーを作成するためによく使用され、ユーザーが一貫したコマンドセットにすばやくアクセスできるようにします。

A common convention for indicating that a menu item launches a dialog box is to append "…" (ellipsis) to the menu item label, e.g., "Save as …".
メニュー項目（menuitem）がダイアログボックスを起動することを示すための一般的な規則は、メニュー項目のラベルに「…」（省略記号）を追加することです（例：「名前を付けて保存…」）。




Examples
例

    Navigation Menubar Example: Demonstrates a menubar that provides site navigation.
     ナビゲーションメニューバーの例：サイトナビゲーションを提供するメニューバーを示します。

    Editor Menubar Example: Demonstrates menu radios and menu checkboxes in submenus of a menubar that provides text formatting commands for a text field.
     エディターのメニューバーの例：テキストフィールドのテキストフォーマットコマンドを提供するメニューバーのサブメニューにあるメニューラジオボタンとメニューチェックボックスを示します。





Keyboard Interaction
キーボードの相互作用

The following description of keyboard behaviors assumes:
キーボードの振る舞いに関する以下の説明は、次のことを前提としています。

    A horizontal menubar containing several menuitem elements.
    1. いくつかのメニュー項目要素を含む水平メニューバー。

    All items in the menubar have child submenus that contain multiple vertically arranged items.
    2. メニューバーのすべての項目には、垂直方向に配置された複数の項目を含む子サブメニューがあります。

    Some of the menuitem elements in the submenus have child submenus with items that are also vertically arranged.
    3. サブメニューの一部のメニュー項目要素には、垂直方向に配置された項目を持つ子サブメニューがあります。

When reading the following descriptions, also keep in mind that:
以下の説明を読むときは、次の点にも注意してください。

    Focusable elements, which may have role menuitem, menuitemradio, or menuitemcheckbox, are referred to as items.
    1. フォーカス可能な要素は、メニュー項目（menuitem）、メニュー項目ラジオボタン（menuitemradio）、またはメニュー項目チェックボックス（menuitemcheckbox）のロールを持つ場合があり、項目と呼ばれます。

    If a behavior applies to only certain types of items, e.g., menuitem elements, the specific role name is used.
    2. 振る舞いが特定のタイプの項目（メニュー項目要素など）にのみ適用される場合、特定のロール名が使用されます。

    Submenus, also known as pop-up menus, are elements with role menu.
    3. ポップアップメニューとも呼ばれるサブメニューは、メニュー（menu）ロールを持つ要素です。

    Except where noted, menus opened from a menubutton behave the same as menus opened from a menubar.
    4. 特に記載のない限り、メニューボタンから開いたメニューは、メニューバーから開いたメニューと同じように振る舞います。

    When a menu opens, or when a menubar receives focus, keyboard focus is placed on the first item. All items are focusable as described in § 6.6 Keyboard Navigation Inside Components.
    メニューが開くとき、またはメニューバーがフォーカスを受け取るとき、キーボードフォーカスは最初の項目に置かれます。 §6.6 コンポーネント内のキーボードナビゲーションで説明されているように、すべての項目はフォーカス可能です。

    Enter:

        When focus is on a menuitem that has a submenu, opens the submenu and places focus on its first item.
        サブメニューのあるメニュー項目にフォーカスがある場合、サブメニューを開き、フォーカスを最初の項目に置きます。

        Otherwise, activates the item and closes the menu.
        それ以外の場合、項目をアクティブ化してメニューを閉じます。

    Space:
    スペース：

        (Optional): When focus is on a menuitemcheckbox, changes the state without closing the menu.
        （任意）：メニュー項目チェックボックスにフォーカスがある場合、メニューを閉じずに状態を変更します。

        (Optional): When focus is on a menuitemradio that is not checked, without closing the menu, checks the focused menuitemradio and unchecks any other checked menuitemradio element in the same group.
        （任意）：チェックされていないメニュー項目ラジオボタンにフォーカスがある場合、メニューを閉じずに、フォーカスされたメニュー項目ラジオボタンをチェックし、同じグループ内の他のチェックされたメニュー項目ラジオボタン要素のチェックを外します。

        (Optional): When focus is on a menuitem that has a submenu, opens the submenu and places focus on its first item.
        （任意）：サブメニューのあるメニュー項目にフォーカスがある場合、サブメニューを開き、フォーカスを最初の項目に置きます。

        (Optional): When focus is on a menuitem that does not have a submenu, activates the menuitem and closes the menu.
        （任意）：サブメニューのないメニュー項目にフォーカスがある場合、メニュー項目をアクティブ化してメニューを閉じます。

    Down Arrow:
    下矢印：

        When focus is on a menuitem in a menubar, opens its submenu and places focus on the first item in the submenu.
        メニューバーのメニュー項目にフォーカスがある場合、そのサブメニューを開き、フォーカスをサブメニューの最初の項目に置きます。

        When focus is in a menu, moves focus to the next item, optionally wrapping from the last to the first.
        メニューにフォーカスがある場合、フォーカスを次の項目に移動し、任意で最後から最初に折り返します。

    Up Arrow:
    上矢印：

        When focus is in a menu, moves focus to the previous item, optionally wrapping from the first to the last.
        メニューにフォーカスがある場合、フォーカスを前の項目に移動し、任意で最初から最後に折り返します。

        (Optional): When focus is on a menuitem in a menubar, opens its submenu and places focus on the last item in the submenu.
        （任意）：メニューバーのメニュー項目にフォーカスがある場合、そのサブメニューを開き、フォーカスをサブメニューの最後の項目に置きます。

    Right Arrow:
    右矢印：

        When focus is in a menubar, moves focus to the next item, optionally wrapping from the last to the first.
        メニューバーにフォーカスがある場合、フォーカスを次の項目に移動し、任意で最後から最初に折り返します。

        When focus is in a menu and on a menuitem that has a submenu, opens the submenu and places focus on its first item.
        メニュー内で、サブメニューのあるメニュー項目にフォーカスがある場合、サブメニューを開き、フォーカスを最初の項目に置きます。

        When focus is in a menu and on an item that does not have a submenu, performs the following 3 actions:
        メニュー内で、サブメニューのない項目にフォーカスがある場合、次の3つのアクションを実行します。

            Closes the submenu and any parent menus.
            1. サブメニューとすべての親メニューを閉じます。

            Moves focus to the next menuitem in the menubar.
            2. フォーカスをメニューバーの次のメニュー項目に移動します。

            Either: (Recommended) opens the submenu of that menuitem without moving focus into the submenu, or opens the submenu of that menuitem and places focus on the first item in the submenu.
            3. いずれか：（推奨）フォーカスをサブメニューに移動せずにそのメニュー項目のサブメニューを開くか、そのメニュー項目のサブメニューを開いてフォーカスをサブメニューの最初の項目に置きます。

        Note that if the menubar were not present, e.g., the menus were opened from a menubutton, Right Arrow would not do anything when focus is on an item that does not have a submenu.
        メニューバーが存在しない場合、例えばメニューがメニューボタンから開かれた場合、サブメニューのない項目にフォーカスがあると、右矢印は何もしないことに注意してください。

    Left Arrow:
    左矢印：

        When focus is in a menubar, moves focus to the previous item, optionally wrapping from the first to the last.
        フォーカスがメニューバーにある場合、フォーカスを前の項目に移動し、任意で最初から最後に折り返します。

        When focus is in a submenu of an item in a menu, closes the submenu and returns focus to the parent menuitem.
        フォーカスがメニュー内の項目のサブメニューにある場合、サブメニューを閉じて、フォーカスを親メニュー項目に戻します。

        When focus is in a submenu of an item in a menubar, performs the following 3 actions:
        フォーカスがメニューバーの項目のサブメニューにある場合、次の3つのアクションを実行します。

            Closes the submenu.
            1. サブメニューを閉じます。

            Moves focus to the previous menuitem in the menubar.
            2. フォーカスをメニューバーの前のメニュー項目に移動します。

            Either: (Recommended) opens the submenu of that menuitem without moving focus into the submenu, or opens the submenu of that menuitem and places focus on the first item in the submenu.
            3. いずれか：（推奨）フォーカスをサブメニューに移動せずにそのメニュー項目のサブメニューを開くか、そのメニュー項目のサブメニューを開いてフォーカスをサブメニューの最初の項目に置きます。

    Home: If arrow key wrapping is not supported, moves focus to the first item in the current menu or menubar.
    Home：矢印キーの折り返しがサポートされていない場合、フォーカスを現在のメニューまたはメニューバーの最初の項目に移動します。

    End: If arrow key wrapping is not supported, moves focus to the last item in the current menu or menubar.
    End：矢印キーの折り返しがサポートされていない場合、フォーカスを現在のメニューまたはメニューバーの最後の項目に移動します。

    Any key that corresponds to a printable character (Optional): Move focus to the next menu item in the current menu whose label begins with that printable character.
    印刷可能な文字に対応する任意のキー（任意）：フォーカスをラベルがその印刷可能な文字で始まる現在のメニューの次のメニュー項目に移動します。

    Escape: Close the menu that contains focus and return focus to the element or context, e.g., menu button or parent menuitem, from which the menu was opened.
    Escape：フォーカスを含むメニューを閉じ、フォーカスをメニューを開いた要素またはコンテキスト（メニューボタンや親メニュー項目など）に戻します。

    Tab: Moves focus to the next element in the tab sequence, and if the item that had focus is not in a menubar, closes its menu and all open parent menu containers.
    Tab：フォーカスをタブシーケンスの次の要素に移動し、フォーカスがあった項目がメニューバーにない場合は、そのメニューと開いているすべての親メニューコンテナーを閉じます。

    Shift + Tab: Moves focus to the previous element in the tab sequence, and if the item that had focus is not in a menubar, closes its menu and all open parent menu containers.
    Shift + Tab：フォーカスをタブシーケンスの前の要素に移動し、フォーカスがあった項目がメニューバーにない場合は、そのメニューと開いているすべての親メニューコンテナーを閉じます。

Note
注

    Disabled menu items are focusable but cannot be activated.
    1. 無効化されているメニュー項目はフォーカス可能ですが、アクティブ化することはできません。

    A separator in a menu is not focusable or interactive.
    2. メニューの区切り（separator、セパレーター）は、フォーカス可能またはインタラクティブではありません。

    If a menu is opened or a menubar receives focus as a result of a context action, Escape or Enter may return focus to the invoking context. For example, a rich text editor may have a menubar that receives focus when a shortcut key, e.g., alt + F10, is pressed while editing. In this case, pressing Escape or activating a command from the menu may return focus to the editor.
    3. コンテキストアクションの結果としてメニューが開かれるか、メニューバーがフォーカスを受け取ると、Escape または Enter は呼び出し元のコンテキストにフォーカスを戻す場合があります。 例えば、リッチテキストエディターには、編集中に Alt + F10 などのショートカットキーが押されたときにフォーカスを受け取るメニューバーがあるかもしれません。 この場合、Esc キーを押すか、メニューからコマンドをアクティブ化すると、フォーカスがエディターに戻ることがあります。

    Although it is recommended that authors avoid doing so, some implementations of navigation menubars may have menuitem elements that both perform a function and open a submenu. In such implementations, enter and Space perform a navigation function, e.g., load new content, while Down Arrow, in a horizontal menubar, opens the submenu associated with that same menuitem.
    4. 作成者はそうしないことをお勧めしますが、ナビゲーションメニューバーの一部の実装には、機能を実行すると同時にサブメニューを開くメニュー項目要素が含まれている場合があります。 このような実装では、Enter と Space は新しいコンテンツの読み込みなどのナビゲーション機能を実行しながら、下矢印は、水平メニューバーで、同じメニュー項目に関連付けられたサブメニューを開きます。

    When items in a menubar are arranged vertically and items in menu containers are arranged horizontally:
    5. メニューバーの項目が垂直に配置され、メニューコンテナーの項目が水平に配置されている場合：

        Down Arrow performs as Right Arrow is described above, and vice versa.
        1. 下矢印は、上記の右矢印と同様に機能し、その逆も同様です。

        Up Arrow performs as Left Arrow is described above, and vice versa.
        2. 上矢印は、上記の左矢印と同様に機能し、その逆も同様です。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    A menu is a container of items that represent choices. The element serving as the menu has a role of either menu or menubar.
    メニューは、選択肢を表す項目のコンテナーです。 メニューとして機能する要素には、menu（メニュー）または menubar（メニューバー）のいずれかのロールがあります。

    The items contained in a menu are child elements of the containing menu or menubar and have any of the following roles:
    メニューに含まれる項目は、含まれるメニューまたはメニューバーの子要素であり、次のいずれかのロールを果たします。

        menuitem
        メニュー項目（menuitem）

        menuitemcheckbox
        メニュー項目チェックボックス（menuitemcheckbox）

        menuitemradio
        メニュー項目ラジオボタン（menuitemradio）

    If activating a menuitem opens a submenu, the menuitem is known as a parent menuitem. A submenu's menu element is:
    メニュー項目をアクティブ化するとサブメニューが開く場合、そのメニュー項目は親メニュー項目と呼ばれます。 サブメニューのメニュー要素は次のとおりです。

        Contained inside the same menu element as its parent menuitem.
        親メニュー項目と同じメニュー要素内に含まれています。

        Is the sibling element immediately following its parent menuitem.
        親メニュー項目の直後の兄弟要素です。

    A parent menuitem has aria-haspopup set to either menu or true.
    親メニュー項目では、aria-haspopup が menu または true のいずれかに設定されています。

    A parent menuitem has aria-expanded set to false when its child menu is not visible and set to true when the child menu is visible.
    親メニュー項目では、子メニューが可視でない場合は aria-expanded が false に設定され、子メニューが可視の場合は true に設定されています。

    One of the following approaches is used to enable scripts to move focus among items in a menu as described in § 6.6 Keyboard Navigation Inside Components:
    次のアプローチのいずれかを使用して、§6.6 コンポーネント内のキーボードナビゲーションで説明されているように、スクリプトがメニュー内の項目間でフォーカスを移動できるようにします。

        The menu container has tabindex set to -1 or 0 and aria-activedescendant set to the ID of the focused item.
        メニューコンテナーのタブインデックスは -1 または 0 に設定され、aria-activedescendant はフォーカスされた項目の ID に設定されています。

        Each item in the menu has tabindex set to -1, except in a menubar, where the first item has tabindex set to 0.
        メニューの各項目のタブインデックスは -1 に設定されています。 ただし、最初の項目のタブインデックスが 0 に設定されているメニューバーは除きます。

    When a menuitemcheckbox or menuitemradio is checked, aria-checked is set to true.
    メニュー項目チェックボックスまたはメニュー項目ラジオボタンがチェックされている場合、aria-checked は true に設定されます。

    When a menu item is disabled, aria-disabled is set to true.
    メニュー項目が無効化されている場合、aria-disabled は true に設定されます。

    Items in a menu may be divided into groups by placing an element with a role of separator between groups. For example, this technique should be used when a menu contains a set of menuitemradio items.
    メニュー内の項目は、グループ間に区切り（separator、セパレーター）ロールを持つ要素を配置することにより、グループに分割できます。 例えば、この手法は、メニューにメニュー項目ラジオボタンの項目のセットが含まれている場合に使用する必要があります。

    All separators should have aria-orientation consistent with the separator's orientation.
    すべての区切りは、区切りの方向と一致する aria-orientation を持っている必要があります。

    If a menubar has a visible label, the element with role menubar has aria-labelledby set to a value that refers to the labelling element. Otherwise, the menubar element has a label provided by aria-label.
    メニューバーに可視ラベルがある場合、メニューバーロールの要素には、ラベル付け要素を参照する値に設定された aria-labelledby があります。 それ以外の場合、メニューバー要素には aria-label によって提供されるラベルがあります。

    If a menubar is vertically oriented, it has aria-orientation set to vertical. The default value of aria-orientation for a menubar is horizontal.
    メニューバーが垂直方向の場合、aria-orientation は垂直（vertical）に設定されます。 メニューバーの aria-orientation のデフォルト値は水平（horizontal）です。

    An element with role menu either has:
    メニューロールのある要素には、次のいずれかがあります。

        aria-labelledby set to a value that refers to the menuitem or button that controls its display.
        aria-labelledby は、表示を制御するメニュー項目またはボタンを参照する値に設定されます。

        A label provided by aria-label.
        aria-label によって提供されるラベル。

    If a menu is horizontally oriented, it has aria-orientation set to horizontal. The default value of aria-orientation for a menu is vertical.
    メニューが水平方向の場合、aria-orientation は水平（horizontal）に設定されます。 メニューの aria-orientation のデフォルト値は垂直（vertical）です。

Note
注


If aria-owns is set on the menu container to include elements that are not DOM children of the container, those elements will appear in the reading order in the sequence they are referenced and after any items that are DOM children. Scripts that manage focus need to ensure the visual focus order matches this assistive technology reading order.
メニューコンテナーで aria-owns が設定され、コンテナーの DOM の子ではない要素が含まれている場合、それらの要素は、参照されている順序で、DOM の子である項目の後に読み順で現れます。 フォーカスを管理するスクリプトは、視覚的なフォーカスの順序がこの支援技術の読み順と一致することを確認する必要があります。




3.16 Menu Button
3.16 メニューボタン


A menu button is a button that opens a menu. It is often styled as a typical push button with a downward pointing arrow or triangle to hint that activating the button will display a menu.
メニューボタン（menu button）は、メニューを開くボタンです。 多くの場合、ボタンをアクティブ化するとメニューが表示されることを示唆する、下向きの矢印または三角形が付いた一般的なプッシュボタンのスタイルになっています。




Examples
例

    Navigation Menu Button: A menu button made from an HTML a element that opens a menu of items that behave as links.
     ナビゲーションメニューボタン：リンクとして振る舞う項目のメニューを開く要素である HTML から作成されたメニューボタン。

    Action Menu Button Example Using element.focus(): A menu button made from an HTML button element that opens a menu of actions or commands where focus in the menu is managed using element.focus().
     element.focus() を使用したアクションメニューボタンの例：メニュー内のフォーカスが element.focus() を使用して管理される、アクションまたはコマンドのメニューを開く HTML ボタン要素から作成されたメニューボタン。

    Action Menu Button Example Using aria-activedescendant: A button that opens a menu of actions or commands where focus in the menu is managed using aria-activedescendant.
     aria-activedescendant を使用したアクションメニューボタンの例：メニューのフォーカスが aria-activedescendant を使用して管理されているアクションまたはコマンドのメニューを開くボタン。





Keyboard Interaction
キーボードの相互作用

    With focus on the button:
    ボタンにフォーカスを当てて：

        Enter: opens the menu and places focus on the first menu item.
        Enter：メニューを開き、フォーカスを最初のメニュー項目に置きます。

        Space: Opens the menu and places focus on the first menu item.
        スペース：メニューを開き、フォーカスを最初のメニュー項目に置きます。

        (Optional) Down Arrow: opens the menu and moves focus to the first menu item.
        （任意）下矢印：メニューを開き、フォーカスを最初のメニュー項目に移動します。

        (Optional) Up Arrow: opens the menu and moves focus to the last menu item.
        （任意）上矢印：メニューを開き、フォーカスを最後のメニュー項目に移動します。

    The keyboard behaviors needed after the menu is open are described in § 3.15 Menu or Menu bar.
    メニューを開いた後に必要なキーボードの振る舞いについては、§3.15 メニューやメニューバーで説明しています。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that opens the menu has role button.
    メニューを開く要素には、ボタン（button）ロールがあります。

    The element with role button has aria-haspopup set to either menu or true.
    ボタンロールのある要素では、aria-haspopup が menu または true に設定されています。

    When the menu is displayed, the element with role button has aria-expanded set to true. When the menu is hidden, it is recommended that aria-expanded is not present. If aria-expanded is specified when the menu is hidden, it is set to false.
    メニューが表示されているとき、ボタンロールのある要素は aria-expanded が true に設定されています。 メニューが非表示の場合は、aria-expanded は存在しないことをお勧めします。 メニューが非表示のときに aria-expanded が指定されている場合、false に設定されます。

    The element that contains the menu items displayed by activating the button has role menu.
    ボタンをアクティブ化することによって表示されるメニュー項目を含む要素には、メニュー（menu）ロールがあります。

    Optionally, the element with role button has a value specified for aria-controls that refers to the element with role menu.
    任意で、ボタンロールのある要素には、メニューロールのある要素を参照する aria-controls に指定された値があります。

    Additional roles, states, and properties needed for the menu element are described in § 3.15 Menu or Menu bar.
    メニュー要素に必要な追加のロール、状態、およびプロパティは、§3.15 メニューやメニューバーで説明されています。





3.17 Radio Group
3.17 ラジオグループ

A radio group is a set of checkable buttons, known as radio buttons, where no more than one of the buttons can be checked at a time. Some implementations may initialize the set with all buttons in the unchecked state in order to force the user to check one of the buttons before moving past a certain point in the workflow.
ラジオグループ（radio group）は、ラジオボタン（radio buttons）と呼ばれるチェック可能なボタンのセットであり、一度にチェックできるボタンは1つだけです。 一部の実装では、ワークフローの特定のポイントを通過する前にユーザーにボタンの1つをチェックさせるために、すべてのボタンがチェックされていない状態でセットを初期化する場合があります。




Examples
例

    Radio Group Example Using Roving tabindex
     動き回るタブインデックスを使用したラジオグループの例

    Radio Group Example Using aria-activedescendant
     aria-activedescendant を使用したラジオグループの例





Keyboard Interaction
キーボードの相互作用




For Radio Groups Not Contained in a Toolbar
ツールバーに含まれていないラジオグループの場合

This section describes the keyboard interaction implemented for most radio groups. For the special case of a radio group nested inside a toolbar, use the keyboard interaction described in the following section.
このセクションでは、ほとんどのラジオグループに実装されているキーボードの相互作用について説明します。 ツールバー内にネストされたラジオグループの特殊なケースでは、次のセクションで説明するキーボードの相互作用を使用します。

    Tab and Shift + Tab: Move focus into and out of the radio group. When focus moves into a radio group :
    Tab と Shift + Tab：フォーカスをラジオグループに出し入れします。 フォーカスがラジオグループに移動したとき：

        If a radio button is checked, focus is set on the checked button.
        ラジオボタンがチェックされている場合、フォーカスはチェックされたボタンに設定されます。

        If none of the radio buttons are checked, focus is set on the first radio button in the group.
        どのラジオボタンもチェックされていない場合、フォーカスはグループの最初のラジオボタンに設定されます。

    Space: checks the focused radio button if it is not already checked.
    スペース：フォーカスされたラジオボタンがまだチェックされていない場合はチェックします。

    Right Arrow and Down Arrow: move focus to the next radio button in the group, uncheck the previously focused button, and check the newly focused button. If focus is on the last button, focus moves to the first button.
    右矢印と下矢印：フォーカスをグループ内の次のラジオボタンに移動し、以前にフォーカスされたボタンのチェックを外し、新しくフォーカスされたボタンをチェックします。 最後のボタンにフォーカスがある場合、フォーカスは最初のボタンに移動します。

    Left Arrow and Up Arrow: move focus to the previous radio button in the group, uncheck the previously focused button, and check the newly focused button. If focus is on the first button, focus moves to the last button.
    左矢印と上矢印：フォーカスをグループ内の前のラジオボタンに移動し、前にフォーカスされたボタンのチェックを外し、新しくフォーカスされたボタンをチェックします。 フォーカスが最初のボタンにある場合、フォーカスは最後のボタンに移動します。

Note
注

The initial focus behavior described above differs slightly from the behavior provided by some browsers for native HTML radio groups. In some browsers, if none of the radio buttons are selected, moving focus into the radio group with Shift+Tab will place focus on the last radio button instead of the first radio button.
上記の最初のフォーカスの振る舞いは、ネイティブ HTML ラジオグループ用に一部のブラウザーで提供される振る舞いとは少し異なります。 一部のブラウザーでは、ラジオボタンが選択されていない場合、Shift + Tab キーを使用してフォーカスをラジオグループに移動すると、最初のラジオボタンではなく最後のラジオボタンにフォーカスが置かれます。




For Radio Group Contained in a Toolbar
ツールバーに含まれているラジオグループの場合

Because arrow keys are used to navigate among elements of a toolbar and the Tab key moves focus in and out of a toolbar, when a radio group is nested inside a toolbar, the keyboard interaction of the radio group is slightly different from that of a radio group that is not inside of a toolbar. For instance, users need to be able to navigate among all toolbar elements, including the radio buttons, without changing which radio button is checked. So, when navigating through a radio group in a toolbar with arrow keys, the button that is checked does not change. The keyboard interaction of a radio group nested in a toolbar is as follows.
矢印キーはツールバーの要素間をナビゲートするために使用され、Tab キーはフォーカスをツールバーの内外に移動するため、ラジオグループがツールバー内にネストされている場合、ラジオグループのキーボードの相互作用はツールバー内にないラジオグループのキーボードの相互作用とわずかに異なります。 例えば、ユーザーは、チェックされたラジオボタンを変更せずに、ラジオボタンを含むすべてのツールバー要素間をナビゲートできる必要があります。 そのため、矢印キーを使用してツールバーのラジオグループをナビゲートしていく場合、チェックされているボタンは変更されません。 ツールバーにネストされたラジオグループのキーボードの相互作用は次のとおりです。

    Space: If the focused radio button is not checked, unchecks the currently checked radio button and checks the focused radio button. Otherwise, does nothing.
    スペース：フォーカスされたラジオボタンがチェックされていない場合、現在チェックされているラジオボタンのチェックを外し、フォーカスされたラジオボタンをチェックします。 それ以外の場合、何もしません。

    Enter (optional): If the focused radio button is not checked, unchecks the currently checked radio button and checks the focused radio button. Otherwise, does nothing.
    Enter（任意）：フォーカスされたラジオボタンがチェックされていない場合、現在チェックされているラジオボタンのチェックを外し、フォーカスされたラジオボタンをチェックします。 それ以外の場合、何もしません。

    Right Arrow:
    右矢印：

        When focus is on a radio button and that radio button is not the last radio button in the radio group, moves focus to the next radio button.
        フォーカスがラジオボタンにあり、そのラジオボタンがラジオグループの最後のラジオボタンではない場合、フォーカスを次のラジオボタンに移動します。

        When focus is on the last radio button in the radio group and that radio button is not the last element in the toolbar, moves focus to the next element in the toolbar.
        フォーカスがラジオグループの最後のラジオボタンにあり、そのラジオボタンがツールバーの最後の要素ではない場合、フォーカスをツールバーの次の要素に移動します。

        When focus is on the last radio button in the radio group and that radio button is also the last element in the toolbar, moves focus to the first element in the toolbar.
        フォーカスがラジオグループの最後のラジオボタンにあり、そのラジオボタンがツールバーの最後の要素でもある場合、フォーカスをツールバーの最初の要素に移動します。

    Left Arrow:
    左矢印：

        When focus is on a radio button and that radio button is not the first radio button in the radio group, moves focus to the previous radio button.
        フォーカスがラジオボタンにあり、そのラジオボタンがラジオグループの最初のラジオボタンではない場合、フォーカスを前のラジオボタンに移動します。

        When focus is on the first radio button in the radio group and that radio button is not the first element in the toolbar, moves focus to the previous element in the toolbar.
        フォーカスがラジオグループの最初のラジオボタンにあり、そのラジオボタンがツールバーの最初の要素ではない場合、フォーカスをツールバーの前の要素に移動します。

        When focus is on the first radio button in the radio group and that radio button is also the first element in the toolbar, moves focus to the last element in the toolbar.
        フォーカスがラジオグループの最初のラジオボタンにあり、そのラジオボタンがツールバーの最初の要素でもある場合、フォーカスをツールバーの最後の要素に移動します。

    Down Arrow (optional): Moves focus to the next radio button in the radio group. If focus is on the last radio button in the radio group, moves focus to the first radio button in the group.
    下矢印（任意）：フォーカスをラジオグループの次のラジオボタンに移動します。 フォーカスがラジオグループの最後のラジオボタンにある場合、フォーカスをグループの最初のラジオボタンに移動します。

    Up Arrow (optional): Moves focus to the previous radio button in the radio group. If focus is on the first radio button in the radio group, moves focus to the last radio button in the group.
    上矢印（任意）：フォーカスをラジオグループの前のラジオボタンに移動します。 フォーカスがラジオグループの最初のラジオボタンにある場合、フォーカスをグループの最後のラジオボタンに移動します。

Note
注

Radio buttons in a toolbar are frequently styled in a manner that appears more like toggle buttons. For an example, See the Simple Editor Toolbar Example
ツールバーのラジオボタンは、トグルボタンのように見える方法でスタイルされることがよくあります。 例については、シンプルなエディターのツールバーの例を参照してください。




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The radio buttons are contained in or owned by an element with role radiogroup.
     ラジオボタンは、ラジオグループ（radiogroup）ロールを持つ要素に含まれているか、その要素によって所有されています。

    Each radio button element has role radio.
     各ラジオボタン要素には、ラジオ（radio）ロールがあります。

    If a radio button is checked, the radio element has aria-checked set to true. If it is not checked, it has aria-checked set to false.
     ラジオボタンがチェックされている場合、ラジオボタン要素の aria-checked は true に設定されています。 チェックされていない場合は、aria-checked が false に設定されています。

    Each radio element is labelled by its content, has a visible label referenced by aria-labelledby, or has a label specified with aria-label.
     各ラジオボタン要素は、そのコンテンツによってラベル付けされているか、aria-labelledby によって参照される可視ラベルを持っているか、または aria-label で指定されたラベルを持っています。

    The radiogroup element has a visible label referenced by aria-labelledby or has a label specified with aria-label.
     ラジオグループ要素には、aria-labelledby によって参照される可視ラベルがあるか、aria-label で指定されたラベルがあります。

    If elements providing additional information about either the radio group or each radio button are present, those elements are referenced by the radiogroup element or radio elements with the aria-describedby property.
     ラジオグループまたは各ラジオボタンのいずれかに関する追加情報を提供する要素が存在する場合、それらの要素は、aria-describedby プロパティを持つラジオグループ要素またはラジオボタン要素によって参照されます。





3.18 Slider
3.18 スライダー


A slider is an input where the user selects a value from within a given range. Sliders typically have a slider thumb that can be moved along a bar or track to change the value of the slider.
スライダー（slider）は、ユーザーが指定された範囲内から値を選択する入力です。 スライダーには通常、スライダーの値を変更するためにバーやトラックに沿って移動できるスライダーつまみ（slider thumb）があります。

Examples
例

    Horizontal Slider Examples: Demonstrates using three horizontally aligned sliders to make a color picker.
    水平スライダーの例：3つの水平に配置されたスライダーを使用してカラーピッカーを作成する方法を示します。

    Slider Examples with aria-orientation and aria-valuetext: Three thermostat control sliders that demonstrate using aria-orientation and aria-valuetext.
    aria-orientation と aria-valuetext を使用したスライダーの例：aria-orientation と aria-valuetext の使用を示す3つのサーモスタット制御スライダー。





Keyboard Interaction
キーボードの相互作用

    Right Arrow: Increase the value of the slider by one step.
    右矢印：スライダーの値を1ステップ増やします。

    Up Arrow: Increase the value of the slider by one step.
    上矢印：スライダーの値を1ステップ増やします。

    Left Arrow: Decrease the value of the slider by one step.
    左矢印：スライダーの値を1ステップ減らします。

    Down Arrow: Decrease the value of the slider by one step.
    下矢印：スライダーの値を1ステップ減らします。

    Home: Set the slider to the first allowed value in its range.
    Home：スライダーをその範囲内で最初に許可された値に設定します。

    End: Set the slider to the last allowed value in its range.
    End：スライダーをその範囲内で最後に許可された値に設定します。

    Page Up (Optional): Increment the slider by an amount larger than the step change made by Up Arrow.
    Page Up（任意）：上矢印によるステップ変更よりも大きい量だけスライダーを増やします。

    Page Down (Optional): Decrement the slider by an amount larger than the step change made by Down Arrow.
    Page Down（任意）：下矢印によるステップ変更よりも大きい量だけスライダーを減らします。

Note
注

    Focus is placed on the slider (the visual object that the mouse user would move, also known as the thumb.
    1. フォーカスはスライダー（マウスユーザーが移動する視覚オブジェクトで、つまみとも呼ばれます）に置かれます。

    In some circumstances, reversing the direction of the value change for the keys specified above, e.g., having Up Arrow decrease the value, could create a more intuitive experience.
    2. 状況によっては、上矢印で値を減らすなど、上記で指定したキーの値の変更の方向を逆にすると、より直感的なエクスペリエンスを作成できます。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element serving as the focusable slider control has role slider.
    フォーカス可能なスライダーコントロールとして機能する要素には、スライダー（slider）ロールがあります。

    The slider element has the aria-valuenow property set to a decimal value representing the current value of the slider.
    スライダー要素の aria-valuenow プロパティは、スライダーの現在の値を表す10進値に設定されています。

    The slider element has the aria-valuemin property set to a decimal value representing the minimum allowed value of the slider.
    スライダー要素の aria-valuemin プロパティは、スライダーの最小許容値を表す10進値に設定されています。

    The slider element has the aria-valuemax property set to a decimal value representing the maximum allowed value of the slider.
    スライダー要素の aria-valuemax プロパティは、スライダーの最大許容値を表す10進値に設定されています。

    If the value of aria-valuenow is not user-friendly, e.g., the day of the week is represented by a number, the aria-valuetext property is set to a string that makes the slider value understandable, e.g., "Monday".
    aria-valuenow の値がユーザーフレンドリーでない場合、例えば曜日を数字で表す場合、aria-valuetext プロパティは、スライダーの値を理解できるようにする文字列に設定されます（例：「月曜」）。

    If the slider has a visible label, it is referenced by aria-labelledby on the slider element. Otherwise, the slider element has a label provided by aria-label.
    スライダーに可視ラベルがある場合、スライダー要素の aria-labelledby によって参照されます。 それ以外の場合、スライダー要素には aria-label によって提供されるラベルがあります。

    If the slider is vertically oriented, it has aria-orientation set to vertical. The default value of aria-orientation for a slider is horizontal.
    スライダーが垂直方向の場合、aria-orientation は垂直（vertical）に設定されます。 スライダーの aria-orientation のデフォルト値は水平（horizontal）です。





3.19 Slider (Multi-Thumb)
3.19 スライダー（複数つまみ）


A multi-thumb slider is a slider with two or more thumbs that each set a value in a group of related values. For example, in a product search, a two-thumb slider could be used to enable users to set the minimum and maximum price limits for the search. In many two-thumb sliders, the thumbs are not allowed to pass one another, such as when the slider sets the minimum and maximum values for a range. For example, in a price range selector, the maximum value of the thumb that sets the lower end of the range is limited by the current value of the thumb that sets the upper end of the range. Conversely, the minimum value of the upper end thumb is limited by the current value of the lower end thumb. However, in some multi-thumb sliders, each thumb sets a value that does not depend on the other thumb values.
複数つまみスライダー（multi-thumb slider）は、2つ以上のつまみがあり、それぞれが関連する値のグループに値を設定するスライダーです。 例えば、商品検索では、2つのつまみスライダーを使用して、ユーザーが検索の最小価格制限と最大価格制限を設定できるようにすることができます。 多くの2つつまみスライダーでは、スライダーが範囲の最小値と最大値を設定する場合など、つまみが互いにすれ違うことは許可されていません。 例えば、価格範囲セレクターでは、範囲の下限を設定するつまみの最大値は、範囲の上限を設定するつまみの現在の値によって制限されます。 逆に、上限のつまみの最小値は、下限のつまみの現在の値によって制限されます。 ただし、一部の複数つまみスライダーでは、各つまみが他のつまみ値に依存しない値を設定します。




Example
例

Multi-Thumb Slider Examples: Demonstrates two-thumb sliders for picking price ranges for an airline flight and hotel reservation.
複数つまみスライダーの例：航空会社のフライトとホテルの予約の価格帯を選択するための2つつまみスライダーを示します。




Keyboard Interaction
キーボードの相互作用

    Each thumb is in the page tab sequence and has the same keyboard interaction as a single-thumb slider.
    各つまみはページのタブシーケンスにあり、単一つまみスライダー（single-thumb slider）と同じキーボードの相互作用を行います。

    The tab order remains constant regardless of thumb value and visual position within the slider. For example, if the value of a thumb changes such that it moves past one of the other thumbs, the tab order does not change.
    タブの順序は、つまみの値やスライダー内の視覚的な位置に関係なく一定のままです。 例えば、つまみの値が他のつまみの1つを超えて移動するように変更された場合、タブの順序は変更されません。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    Each element serving as a focusable slider thumb has role slider.
    フォーカス可能なスライダーつまみとして機能する各要素には、スライダー（slider）ロールがあります。

    Each slider element has the aria-valuenow property set to a decimal value representing the current value of the slider.
    各スライダー要素には、スライダーの現在の値を表す10進値に設定された aria-valuenow プロパティがあります。

    Each slider element has the aria-valuemin property set to a decimal value representing the minimum allowed value of the slider.
    各スライダー要素には、スライダーの最小許容値を表す10進値に設定された aria-valuemin プロパティがあります。

    Each slider element has the aria-valuemax property set to a decimal value representing the maximum allowed value of the slider.
    各スライダー要素には、スライダーの最大許容値を表す10進値に設定された aria-valuemax プロパティがあります。

    When the range (e.g. minimum and/or maximum value) of another slider is dependent on the current value of a slider, the values of aria-valuemin or aria-valuemax of the dependent sliders are updated when the value changes.
    別のスライダーの範囲（最小値や最大値など）がスライダーの現在の値に依存している場合、依存するスライダーの aria-valuemin または aria-valuemax の値は、値が変更されると更新されます。

    If a value of aria-valuenow is not user-friendly, e.g., the day of the week is represented by a number, the aria-valuetext property is set to a string that makes the slider value understandable, e.g., "Monday".
    aria-valuenow の値がユーザーフレンドリーでない場合、例えば曜日が数字で表される場合、aria-valuetext プロパティは、スライダーの値を理解できるようにする文字列に設定されます（例：「月曜」）。

    If a slider has a visible label, it is referenced by aria-labelledby on the slider element. Otherwise, the slider element has a label provided by aria-label.
    スライダーに可視ラベルがある場合、スライダー要素の aria-labelledby によって参照されます。 それ以外の場合、スライダー要素には aria-label によって提供されるラベルがあります。

    If a slider is vertically oriented, it has aria-orientation set to vertical. The default value of aria-orientation for a slider is horizontal.
    スライダーが垂直方向の場合、aria-orientation は垂直（vertical）に設定されます。 スライダーの aria-orientation のデフォルト値は水平（horizontal）です。





3.20 Spinbutton
3.20 スピンボタン

A spinbutton is an input widget that restricts its value to a set or range of discrete values. For example, in a widget that enables users to set an alarm, a spinbutton could allow users to select a number from 0 to 59 for the minute of an hour.
スピンボタン（spinbutton）は、その値を離散値のセットまたは範囲に制限する入力ウィジェットです。 例えば、ユーザーがアラームを設定できるウィジェットでは、スピンボタンを使用して、ユーザーが1時間の分に0から59までの数値を選択できるようにすることができます。

Spinbuttons often have three components, including a text field that displays the current value, an increment button, and a decrement button. The text field is usually the only focusable component because the increment and decrement functions are keyboard accessible via arrow keys. Typically, the text field also allows users to directly edit the value.
スピンボタンには、現在の値を表示するテキストフィールド、増分ボタン（increment button）、減分ボタン（decrement button）など、3つのコンポーネントが含まれていることがよくあります。 増分および減分の機能は矢印キーを介してキーボードからアクセスできるため、通常、テキストフィールドが唯一のフォーカス可能なコンポーネントです。 通常、テキストフィールドでは、ユーザーが値を直接編集することもできます。

If the range is large, a spinbutton may support changing the value in both small and large steps. For instance, in the alarm example, the user may be able to move by 1 minute with Up Arrow and Down Arrow and by 10 minutes with Page Up and Page Down.
範囲が大きい場合、スピンボタンは小さいステップと大きいステップの両方で値を変更することをサポートする場合があります。 例えば、アラームの例では、ユーザーは上矢印と下矢印で1分、Page Up と Page Down で10分移動できる場合があります。




Example
例

Date Picker Spin Button Example: Illustrates a date picker made from thre spin buttons for day, month, and year.
日付ピッカーのスピンボタンの例：日、月、年のスピンボタンから作成された日付ピッカーを示しています。




Keyboard Interaction
キーボードの相互作用

    Up Arrow: Increases the value.
    上矢印：値を増やします。

    Down Arrow: Decreases the value.
    下矢印：値を減らします。

    Home: If the spinbutton has a minimum value, sets the value to its minimum.
    Home：スピンボタンに最小値がある場合は、値を最小値に設定します。

    End: If the spinbutton has a maximum value, sets the value to its maximum.
    End：スピンボタンに最大値がある場合、その値を最大値に設定します。

    Page Up (Optional): Increases the value by a larger step than Up Arrow.
    Page Up（任意）：上矢印よりも大きなステップで値を増やします。

    Page Down (Optional): Decreases the value by a larger step than Down Arrow.
    Page Down（任意）：下矢印よりも大きなステップで値を減らします。

    If the spinbutton text field allows directly editing the value, the following keys are supported:
    スピンボタンのテキストフィールドで値を直接編集できる場合は、次のキーがサポートされています。

        Standard single line text editing keys appropriate for the device platform (see note below).
        デバイスプラットフォームに適した標準の単一行テキスト編集キー（下記の注を参照）。

        Printable Characters: Type characters in the textbox. Note that many implementations allow only certain characters as 
part of the value and prevent input of any other characters. For example, an hour-and-minute spinner would allow only integer values from 0 to 59, the colon ':', and the letters 'AM' and 'PM'. Any other character input does not change the contents of the text field nor the value of the spinbutton.
        印刷可能な文字：テキストボックスに文字をタイプ入力します。 多くの実装では、値の一部として特定の文字のみが許可され、他の文字の入力が禁止されていることに注意してください。 例えば、時間と分のスピナー（hour-and-minute spinner）では、0〜59の整数値、コロン「：」、および文字「AM」と「PM」のみが許可されます。 その他の文字入力は、テキストフィールドの内容やスピンボタンの値を変更しません。

Note
注

    Focus remains on the text field during operation.
    1. 操作中はテキストフィールドにフォーカスが残ります。

    Standard single line text editing keys appropriate for the device platform:
    2. デバイスプラットフォームに適した標準の単一行テキスト編集キー：

        include keys for input, cursor movement, selection, and text manipulation.
        1. 入力、カーソル移動、選択、およびテキスト操作用のキーが含まれています。

        Standard key assignments for editing functions depend on the device operating system.
        2. 編集機能の標準的なキー割り当ては、デバイスのオペレーティングシステムによって異なります。

        The most robust approach for providing text editing functions is to rely on browsers, which supply them for HTML inputs with type text and for elements with the contenteditable HTML attribute.
        3. テキスト編集機能を提供するための最も堅牢なアプローチは、ブラウザーに依存することです。 ブラウザーは、テキストタイプの HTML 入力と、contenteditable  HTML 属性の要素にそれらを提供します。

        IMPORTANT: Be sure that JavaScript does not interfere with browser-provided text editing functions by capturing key events for the keys used to perform them.
        4. 重要：JavaScript は、ブラウザーが提供するテキスト編集機能の実行に使用されるキーのキーイベントをキャプチャすることにより、ブラウザーが提供するテキスト編集機能に干渉しないようにしてください。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The focusable element serving as the spinbutton has role spinbutton. This is typically an element that supports text input.
    スピンボタンとして機能するフォーカス可能な要素には、スピンボタン（spinbutton）ロールがあります。 これは通常、テキスト入力をサポートする要素です。

    The spinbutton element has the aria-valuenow property set to a decimal value representing the current value of the spinbutton.
    スピンボタン要素の aria-valuenow プロパティは、スピンボタンの現在の値を表す10進値に設定されています。

    The spinbutton element has the aria-valuemin property set to a decimal value representing the minimum allowed value of the spinbutton if it has a known minimum value.
    スピンボタン要素には、既知の最小値がある場合、スピンボタンの最小許容値を表す10進値に設定された aria-valuemin プロパティがあります。

    The spinbutton element has the aria-valuemax property set to a decimal value representing the maximum allowed value of the spinbutton if it has a known maximum value.
    スピンボタン要素には、既知の最大値がある場合、スピンボタンの最大許容値を表す10進値に設定された aria-valuemax プロパティがあります。

    If the value of aria-valuenow is not user-friendly, e.g., the day of the week is represented by a number, the aria-valuetext property is set on the spinbutton element to a string that makes the spinbutton value understandable, e.g., "Monday".
    aria-valuenow の値がユーザーフレンドリーでない場合、例えば曜日が数字で表される場合、aria-valuetext プロパティは、スピンボタン要素のスピンボタン値を理解できるようにする文字列に設定されます（例：「月曜」）。

    If the spinbutton has a visible label, it is referenced by aria-labelledby on the spinbutton element. Otherwise, the spinbutton element has a label provided by aria-label.
    スピンボタンに可視ラベルがある場合、スピンボタン要素の aria-labelledby によって参照されます。 それ以外の場合、スピンボタン要素には aria-label によって提供されるラベルがあります。

    The spinbutton element has aria-invalid set to true if the value is outside the allowed range. Note that most implementations prevent input of invalid values, but in some scenarios, blocking all invalid input may not be practical.
    値が許容範囲外の場合、スピンボタン要素の aria-invalid が true に設定されます。 ほとんどの実装は無効な値の入力を防止しますが、シナリオによっては、すべての無効な入力をブロックすることが実用的でない場合があることに注意してください。





3.21 Table
3.21 テーブル

Like an HTML table element, a WAI-ARIA table is a static tabular structure containing one or more rows that each contain one or more cells; it is not an interactive widget. Thus, its cells are not focusable or selectable. The grid pattern is used to make an interactive widget that has a tabular structure.
WAI-ARIA テーブル（table）は、HTML テーブル要素と同様に、それぞれが1つ以上のセルを含む1つ以上の行を含む静的な表形式の構造であり、インタラクティブなウィジェットではありません。 したがって、そのセルはフォーカス可能または選択可能ではありません。 グリッドのパターンは、表形式の構造を持つインタラクティブなウィジェットを作成するために使用されます。

However, tables are often used to present a combination of information and interactive widgets. Since a table is not a widget, each widget contained in a table is a separate stop in the page tab sequence. If the number of widgets is large, replacing the table with a grid can dramatically reduce the length of the page tab sequence because a grid is a composite widget that can contain other widgets.
ただし、テーブルは、情報とインタラクティブなウィジェットの組み合わせを表すためによく使用されます。 テーブルはウィジェットではないため、テーブルに含まれる各ウィジェットは、ページのタブシーケンスの個別のタブストップです。 ウィジェットの数が多い場合、グリッドは他のウィジェットを含めることができる複合ウィジェットであるため、テーブルをグリッドに置き換えると、ページのタブシーケンスの長さを大幅に短縮できます。

Note
注

As with other WAI-ARIA roles that have a native host language equivalent, authors are strongly encouraged to use a native HTML table element whenever possible. This is especially important with role table because it is a new feature of WAI-ARIA 1.1. It is thus advisable to test implementations thoroughly with each browser and assistive technology combination that could be used by the target audience.
同等のネイティブホスト言語を持つ他の WAI-ARIA ロールと同様に、作成者は可能な限りネイティブ HTML テーブル要素を使用することを強くお勧めします。 これは WAI-ARIA 1.1 の新機能であるため、テーブルロールでは特に重要です。 したがって、対象者が使用できる各ブラウザーと支援技術の組み合わせを使用して、実装を徹底的にテストすることをお勧めします。




Examples
例

Table Example: ARIA table made using HTML div and span elements.
テーブルの例：HTML の div 要素と span 要素を使用して作成された ARIA テーブル。




Keyboard Interaction
キーボードの相互作用

Not applicable.
適用できません。




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The table container has role table.
    テーブルコンテナーには、テーブル（table）ロールがあります。

    Each row container has role row and is either a DOM descendant of or owned by the table element or an element with role rowgroup.
    各行コンテナーには行（row）ロールがあり、テーブル要素または行グループ（rowgroup）ロールを持つ要素の DOM の子孫であるか、所有されています。

    Each cell is either a DOM descendant of or owned by a row element and has one of the following roles:
    各セルは、行要素の DOM 子孫であるか、行要素によって所有されており、次のいずれかのロールがあります。

        columnheader if the cell contains a title or header information for the column.
        セルに列のタイトルまたはヘッダー情報が含まれている場合は、列ヘッダー（columnheader）。

        rowheader if the cell contains title or header information for the row.
        セルに行のタイトルまたはヘッダー情報が含まれている場合は、行ヘッダー（rowheader）。

        cell if the cell does not contain column or row header information.
        セルに列または行のヘッダー情報が含まれていない場合は、セル（cell）。

    If there is an element in the user interface that serves as a label for the table, aria-labelledby is set on the table element with a value that refers to the labelling element. Otherwise, a label is specified for the table element using aria-label.
    テーブルのラベルとして機能する要素がユーザーインターフェイスにある場合、aria-labelledby は、ラベル付け要素を参照する値でテーブル要素に設定されます。 それ以外の場合、aria-label を使用してテーブル要素にラベルが指定されます。

    If the table has a caption or description, aria-describedby is set on the table element with a value referring to the element containing the description.
    テーブルにキャプションまたは説明がある場合、aria-describeby は、説明を含む要素を参照する値でテーブル要素に設定されます。

    If the table contains sortable columns or rows, aria-sort is set to an appropriate value on the header cell element for the sorted column or row as described in the section on grid and table properties.
    テーブルに並べ替え可能な列または行が含まれている場合、グリッドとテーブルのプロパティのセクションで説明されているように、並べ替えられた列または行のヘッダーセル要素で aria-sort が適切な値に設定されます。

    If there are conditions where some rows or columns are hidden or not present in the DOM, e.g., there are widgets on the page for hiding rows or columns, the following properties are applied as described in the section on grid and table properties.
    一部の行または列が非表示または DOM に存在しない条件がある場合、例えば、行または列を非表示にするウィジェットがページにある場合、グリッドおよびテーブルのプロパティのセクションで説明されているように、次のプロパティが適用されます。

        aria-colcount or aria-rowcount is set to the total number of columns or rows, respectively.
        aria-colcount または aria-rowcount は、それぞれ列または行の総数に設定されます。

        aria-colindex or aria-rowindex is set to the position of a cell within a row or column, respectively.
        aria-colindex または aria-rowindex は、それぞれ行または列内のセルの位置に設定されます。

    If the table includes cells that span multiple rows or multiple columns, then aria-rowspan or aria-colspan is applied as described in grid and table properties.
    テーブルに複数の行または複数の列にまたがるセルが含まれている場合、グリッドおよびテーブルのプロパティで説明されているように、aria-rowspan または aria-colspan が適用されます。

Note
注

If rows or cells are included in a table via aria-owns, they will be presented to assistive technologies after the DOM descendants of the table element unless the DOM descendants are also included in the aria-owns attribute.
行またはセルが aria-owns を介してテーブルに含まれている場合、テーブル要素の DOM の子孫が aria-owns 属性に含まれている場合を除き、それらはテーブル要素の DOM の子孫の後に支援技術に提示されます。




3.22 Tabs
3.22 タブ

Tabs are a set of layered sections of content, known as tab panels, that display one panel of content at a time. Each tab panel has an associated tab element, that when activated, displays the panel. The list of tab elements is arranged along one edge of the currently displayed panel, most commonly the top edge.
タブ（tabs）は、タブパネル（tab panels）と呼ばれるコンテンツの階層化されたセクションのセットであり、一度に1つのコンテンツのパネルを表示します。 各タブパネルには関連するタブ要素があり、アクティブ化するとパネルが表示されます。 タブ要素のリストは、現在表示されているパネルの1つの端、最も一般的には上端に沿って配置されます。

Terms used to describe this design pattern include:
このデザインパターンを説明するために使用される用語は次のとおりです。

Tabs or Tabbed Interface
タブ（Tabs）またはタブ付きインターフェイス（Tabbed Interface）

    A set of tab elements and their associated tab panels.
    タブ要素のセットとそれに関連するタブパネル。

Tab List
タブリスト（Tab List）

    A set of tab elements contained in a tablist element.
    タブリスト要素に含まれるタブ要素のセット。

tab
タブ（tab）

    An element in the tab list that serves as a label for one of the tab panels and can be activated to display that panel. 
    タブパネルの1つのラベルとして機能し、そのパネルを表示するためにアクティブ化できるタブリスト内の要素。

tabpanel
タブパネル（tabpanel）

    The element that contains the content associated with a tab.
    タブに関連付けられたコンテンツを含む要素。

When a tabbed interface is initialized, one tab panel is displayed and its associated tab is styled to indicate that it is active. When the user activates one of the other tab elements, the previously displayed tab panel is hidden, the tab panel associated with the activated tab becomes visible, and the tab is considered "active".
タブ付きインターフェイスが初期化されると、1つのタブパネルが表示され、関連するタブのスタイルが設定されて、アクティブであることを示します。 ユーザーが他のタブ要素の1つをアクティブ化すると、以前に表示されたタブパネルが非表示になり、アクティブ化されたタブに関連付けられたタブパネルが可視になり、タブは「アクティブ」と見なされます。




Examples
例

    Tabs With Automatic Activation: A tabs widget where tabs are automatically activated and their panel is displayed when they receive focus.
    自動アクティブ化のあるタブ：タブが自動的にアクティブ化され、フォーカスを受け取るとパネルが表示されるタブウィジェット。

    Tabs With Manual Activation: A tabs widget where users activate a tab and display its panel by pressing Space or Enter.
    手動アクティブ化のあるタブ：ユーザーがスペースまたは Enter を押してタブをアクティブ化し、そのパネルを表示するタブウィジェット。





Keyboard Interaction
キーボードの相互作用

For the tab list:
タブリストの場合：

    Tab: When focus moves into the tab list, places focus on the active tab element. When the tab list contains the focus, moves focus to the next element in the page tab sequence outside the tablist, which is typically either the first focusable element inside the tab panel or the tab panel itself.
    Tab：フォーカスがタブリストに移動すると、アクティブなタブ要素にフォーカスが置かれます。 タブリストにフォーカスが含まれている場合、フォーカスをタブリスト外のページのタブシーケンスで次の要素に移動します。 これは通常、タブパネル内の最初のフォーカス可能な要素またはタブパネル自体のいずれかです。

    When focus is on a tab element in a horizontal tab list:
    水平タブリストのタブ要素にフォーカスがある場合：

        Left Arrow: moves focus to the previous tab. If focus is on the first tab, moves focus to the last tab. Optionally, activates the newly focused tab (See note below).
        左矢印：フォーカスを前のタブに移動します。 フォーカスが最初のタブにある場合、フォーカスを最後のタブに移動します。 任意で、新しくフォーカスされたタブをアクティブ化します（以下の注を参照）。

        Right Arrow: Moves focus to the next tab. If focus is on the last tab element, moves focus to the first tab. Optionally, activates the newly focused tab (See note below).
        右矢印：フォーカスを次のタブに移動します。 フォーカスが最後のタブ要素にある場合、フォーカスを最初のタブに移動します。 任意で、新しくフォーカスされたタブをアクティブ化します（以下の注を参照）。

    When focus is on a tab in a tablist with either horizontal or vertical orientation:
    水平方向または垂直方向のタブリスト内のタブにフォーカスがある場合：

        Space or Enter: Activates the tab if it was not activated automatically on focus.
        スペースまたは Enter：フォーカス時にタブが自動的にアクティブ化されなかった場合、タブをアクティブ化します。

        Home (Optional): Moves focus to the first tab. Optionally, activates the newly focused tab (See note below).
        Home（任意）：フォーカスを最初のタブに移動します。 任意で、新しくフォーカスされたタブをアクティブ化します（以下の注を参照）。

        End (Optional): Moves focus to the last tab. Optionally, activates the newly focused tab (See note below).
        End（任意）：フォーカスを最後のタブに移動します。 任意で、新しくフォーカスされたタブをアクティブ化します（以下の注を参照）。

        Shift + F10: If the tab has an associated pop-up menu, opens the menu.
        Shift + F10：タブに関連するポップアップメニューがある場合は、メニューを開きます。

        Delete (Optional): If deletion is allowed, deletes (closes) the current tab element and its associated tab panel, sets focus on the tab following the tab that was closed, and optionally activates the newly focused tab. If there is not a tab that followed the tab that was deleted, e.g., the deleted tab was the right-most tab in a left-to-right horizontal tab list, sets focus on and optionally activates the tab that preceded the deleted tab. If the application allows all tabs to be deleted, and the user deletes the last remaining tab in the tab list, the application moves focus to another element that provides a logical work flow. As an alternative to Delete, or in addition to supporting Delete, the delete function is available in a context menu.
        Delete（任意）：削除が許可されている場合、現在のタブ要素とそれに関連するタブパネルを削除（閉じ）、フォーカスを閉じられたタブに続くタブに設定し、任意で新しくフォーカスされたタブをアクティブ化します。 削除されたタブの後に続くタブがない場合（例えば、削除されたタブが左から右の水平タブリストの右端のタブであった場合）、削除されたタブの前のタブにフォーカスを設定し、任意でそのタブをアクティブ化します。 アプリケーションがすべてのタブの削除を許可し、ユーザーがタブリストの最後に残っているタブを削除した場合、アプリケーションは論理ワークフローを提供する別の要素にフォーカスを移動します。 Delete の代わりに、または Delete のサポートに加えて、削除機能をコンテキストメニューで使用できます。

Note
注

    It is recommended that tabs activate automatically when they receive focus as long as their associated tab panels are displayed without noticeable latency. This typically requires tab panel content to be preloaded. Otherwise, automatic activation slows focus movement, which significantly hampers users' ability to navigate efficiently across the tab list. For additional guidance, see § 6.4 Deciding When to Make Selection Automatically Follow Focus.
    1. 関連するタブパネルが目立った待ち時間なしで表示されている限り、タブがフォーカスを受け取ると自動的にアクティブ化することをお勧めします。 これには通常、タブパネルのコンテンツを先読みする必要があります。 そうしないと、自動アクティブ化によってフォーカスの移動が遅くなり、タブリスト間を効率的にナビゲートするユーザーの能力が大幅に妨げられます。 追加のガイダンスについては、§6.4 フォーカスに従って自動的に選択を行うかの決定を参照してください。

    If the tabs in a tab list are arranged vertically:
    2. タブリストのタブが垂直に配置されている場合：

        Down Arrow performs as Right Arrow is described above.
        1. 下矢印は、上記の右矢印と同様に機能します。

        Up Arrow performs as Left Arrow is described above.
        2. 上矢印は、上記の左矢印と同様に機能します。

    If the tab list is horizontal, it does not listen for Down Arrow or Up Arrow so those keys can provide their normal browser scrolling functions even when focus is inside the tab list.
    3. タブリストが水平の場合、下矢印または上矢印をリッスンしないため、フォーカスがタブリスト内にある場合でも、これらのキーは通常のブラウザーのスクロール機能を提供できます。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that serves as the container for the set of tabs has role tablist.
    タブのセットのコンテナーとして機能する要素には、タブリスト（tablist）ロールがあります。

    Each element that serves as a tab has role tab and is contained within the element with role tablist.
    タブとして機能する各要素には、タブ（tab）ロールがあり、タブリストロールを持つ要素内に含まれています。

    Each element that contains the content panel for a tab has role tabpanel.
    タブのコンテンツパネルを含む各要素には、タブパネル（tabpanel）ロールがあります。

    If the tab list has a visible label, the element with role tablist has aria-labelledby set to a value that refers to the labelling element. Otherwise, the tablist element has a label provided by aria-label.
    タブリストに可視ラベルがある場合、タブリストロールを持つ要素には、ラベル付け要素を参照する値に設定された aria-labelledby があります。 それ以外の場合、タブリスト要素には aria-label によって提供されるラベルがあります。

    Each element with role tab has the property aria-controls referring to its associated tabpanel element.
    タブロールを持つ各要素には、関連するタブパネル要素を参照する aria-controls プロパティがあります。

    The active tab element has the state aria-selected set to true and all other tab elements have  it set to false.
    アクティブなタブ要素では、aria-selected 状態が true に設定され、他のすべてのタブ要素では false に設定されています。

    Each element with role tabpanel has the property aria-labelledby referring to its associated tab element.
    タブパネルロールを持つ各要素には、関連付けられたタブ要素を参照する aria-labelledby プロパティがあります。

    If a tab element has a pop-up menu, it has the property aria-haspopup set to either menu or true.
    タブ要素にポップアップメニューがある場合、aria-haspopup プロパティが menu または true に設定されています。

    If the tablist element is vertically oriented, it has the property aria-orientation set to vertical. The default value of aria-orientation for a tablist element is horizontal.
    タブリスト要素が垂直方向の場合、aria-orientation プロパティが垂直（vertical）に設定されます。 タブリスト要素の aria-orientation のデフォルト値は水平（horizo​​ntal）です。





3.23 Toolbar
3.23 ツールバー

A toolbar is a container for grouping a set of controls, such as buttons, menubuttons, or checkboxes.
ツールバー（toolbar）は、ボタン、メニューボタン、チェックボックスなどの一連のコントロールをグループ化するためのコンテナーです。

When a set of controls is visually presented as a group, the toolbar role can be used to communicate the presence and purpose of the grouping to screen reader users. Grouping controls into toolbars can also be an effective way of reducing the number of tab stops in the keyboard interface.
コントロールのセットがグループとして視覚的に提示される場合、ツールバーロールを使用して、グループ化の存在と目的をスクリーンリーダーのユーザーに伝えることができます。 コントロールをツールバーにグループ化することも、キーボードインターフェイスのタブストップの数を減らす効果的な方法です。

To optimize the benefit of toolbar widgets:
ツールバーウィジェットの利点を最適化するには：

    Implement focus management so the keyboard tab sequence includes one stop for the toolbar and arrow keys move focus among the controls in the toolbar.
    フォーカス管理を実装して、キーボードのタブシーケンスにツールバーのためのタブストップが1つ含まれ、矢印キーがツールバー内のコントロール間でフォーカスを移動するようにします。

        In horizontal toolbars, Left Arrow and Right Arrow navigate among controls. Up Arrow and Down Arrow can duplicate Left Arrow and Right Arrow, respectively, or can be reserved for operating controls, such as spin buttons that require vertical arrow keys to operate.
        水平ツールバーでは、左矢印と右矢印がコントロール間をナビゲートします。 上矢印と下矢印は、それぞれ左矢印と右矢印を複製することも、操作に上下矢印キーを必要とするスピンボタンなどの操作コントロール用に予約することもできます。

        In vertical toolbars, Up Arrow and Down Arrow navigate among controls. Left Arrow and Right Arrow can duplicate Up Arrow and Down Arrow, respectively, or can be reserved for operating controls, such as horizontal sliders that require horizontal arrow keys to operate.
        垂直ツールバーでは、上矢印と下矢印がコントロール間をナビゲートします。 左矢印と右矢印は、それぞれ上矢印と下矢印を複製することも、操作に左右矢印キーを必要とする水平スライダーなどの操作コントロール用に予約することもできます。

        In toolbars with multiple rows of controls, Left Arrow and Right Arrow can provide navigation that wraps from row to row, leaving the option of reserving vertical arrow keys for operating controls.
        コントロールの複数の行があるツールバーでは、左矢印と右矢印は行から行に折り返されるナビゲーションを提供でき、コントロールを操作するために上下矢印キーを予約するオプションを残します。

    Avoid including controls whose operation requires the pair of arrow keys used for toolbar navigation. If unavoidable, include only one such control and make it the last element in the toolbar. For example, in a horizontal toolbar, a textbox could be included as the last element.
    操作にツールバーのナビゲーションに使用される矢印キーのペアが必要なコントロールを含めないでください。 やむを得ない場合は、そのようなコントロールを1つだけ含めて、ツールバーの最後の要素にします。 例えば、水平ツールバーでは、テキストボックスを最後の要素として含めることができます。

    Use toolbar as a grouping element only if the group contains 3 or more controls.
    グループに3つ以上のコントロールが含まれている場合にのみ、ツールバーをグループ化要素として使用します。





Example
例

Toolbar Example: A toolbar that uses roving tabindex to manage focus and contains several types of controls, including toggle buttons, radio buttons, a menu button, a spin button, a checkbox, and a link.
ツールバーの例：動き回るタブインデックスを使用してフォーカスを管理し、トグルボタン、ラジオボタン、メニューボタン、スピンボタン、チェックボックス、リンクなど、いくつかの種類のコントロールを含むツールバー。




Keyboard Interaction
キーボードの相互作用

    Tab and Shift + Tab: Move focus into and out of the toolbar. When focus moves into a toolbar:
    Tab と Shift + Tab：フォーカスをツールバーの内外に移動します。 フォーカスがツールバーに移動したとき：

        If focus is moving into the toolbar for the first time, focus is set on the first control that is not disabled.
        フォーカスが初めてツールバーに移動する場合、フォーカスは無効化されていない最初のコントロールに設定されます。

        If the toolbar has previously contained focus, focus is optionally set on the control that last had focus. Otherwise, it is set on the first control that is not disabled.
        ツールバーに以前にフォーカスが含まれていた場合、フォーカスは任意で最後にフォーカスがあったコントロールに設定されます。 それ以外の場合、無効化されていない最初のコントロールに設定されます。

    For a horizontal toolbar (the default):
    水平ツールバーの場合（デフォルト）：

        Left Arrow: Moves focus to the previous control. Optionally, focus movement may wrap from the first element to the last element.
        左矢印：フォーカスを前のコントロールに移動します。 任意で、フォーカスの移動は最初の要素から最後の要素に折り返される場合があります。

        Right Arrow: Moves focus to the next control. Optionally, focus movement may wrap from the last element to the first element.
        右矢印：フォーカスを次のコントロールに移動します。 任意で、フォーカスの移動は最後の要素から最初の要素に折り返される場合があります。

    Home (Optional): Moves focus to first element.
    Home（任意）：フォーカスを最初の要素に移動します。

    End (Optional): Moves focus to last element.
    End（任意）：フォーカスを最後の要素に移動します。

Note
注

    If the items in a toolbar are arranged vertically:
    1. ツールバーの項目が垂直に配置されている場合：

        Down Arrow performs as Right Arrow is described above.
        1. 下矢印は、上記の右矢印と同様に機能します。

        Up Arrow performs as Left Arrow is described above.
        2. 上矢印は、上記の左矢印と同様に機能します。

    Typically, disabled elements are not focusable when navigating with a keyboard. However, in circumstances where discoverability of a function is crucial, it may be helpful if disabled controls are focusable so screen reader users are more likely to be aware of their presence. For additional guidance, see § 6.7 Focusability of disabled controls.
    2. 通常、無効化されている要素は、キーボードでナビゲートするときにフォーカスできません。 ただし、機能の発見可能性が重要な状況では、無効化されているコントロールにフォーカスを設定して、スクリーンリーダーのユーザーがその存在に気付く可能性が高くなると役立つ場合があります。 追加のガイダンスについては、§6.7 無効化されたコントロールのフォーカス可能性を参照してください。

    In applications where quick access to a toolbar is important, such as accessing an editor's toolbar from its text area, a documented shortcut key for moving focus from the relevant context to its corresponding toolbar is recommended.
    3. テキスト領域からエディターのツールバーにアクセスするなど、ツールバーへの迅速なアクセスが重要なアプリケーションでは、関連するコンテキストから対応するツールバーにフォーカスを移動するための文書化されたショートカットキーをお勧めします。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that serves as the toolbar container has role toolbar.
    ツールバーコンテナーとして機能する要素には、ツールバー（toolbar）ロールがあります。

    If the toolbar has a visible label, it is referenced by aria-labelledby on the toolbar element. Otherwise, the toolbar element has a label provided by aria-label.
    ツールバーに可視ラベルがある場合、ツールバー要素の aria-labelledby によって参照されます。 それ以外の場合、ツールバー要素には aria-label によって提供されるラベルがあります。

    If the controls are arranged vertically, the toolbar element has aria-orientation set to vertical. The default orientation is horizontal.
    コントロールが垂直に配置されている場合、ツールバー要素の aria-orientation は垂直（vertical）に設定されています。 デフォルトの向きは水平（horizontal）です。





3.24 Tooltip Widget
3.24 ツールチップウィジェット

NOTE: This design pattern is work in progress; it does not yet have task force consensus. Progress and discussions are captured in issue 128.
注：このデザインパターンは進行中のものであり、タスクフォースのコンセンサスはまだありません。 進捗状況と議論は issue 128 に記載されています。

A tooltip is a popup that displays information related to an element when the element receives keyboard focus or the mouse hovers over it. It typically appears after a small delay and disappears when Escape is pressed or on mouse out.
ツールチップ（tooltip）は、要素がキーボードフォーカスを受け取るか、マウスがその上にホバーしたときに、要素に関連する情報を表示するポップアップです。 通常、少し遅れて表示され、Escape を押すかマウスが離れると消えます。

Tooltip widgets do not receive focus. A hover that contains focusable elements can be made using a non-modal dialog.
ツールチップウィジェットはフォーカスを受け取りません。 フォーカス可能な要素を含むホバーは、非モーダルダイアログを使用して作成できます。




Example
例

Work to develop a tooltip example is tracked by issue 127.
ツールチップの例を開発する作業は、issue 127 によって追跡されます。




Keyboard Interaction
キーボードの相互作用

Escape: Dismisses the Tooltip.
Escape：ツールチップを閉じます。

Note
注

    Focus stays on the triggering element while the tooltip is displayed.
    1. ツールチップが表示されている間、フォーカスはトリガー要素に留まります。

    If the tooltip is invoked when the trigger element receives focus, then it is dismissed when it no longer has focus (onBlur). If the tooltip is invoked with mouseIn, then it is dismissed with on mouseOut.
    2. トリガー要素がフォーカスを受け取ったときにツールチップが呼び出された場合、フォーカスがなくなったときにツールチップは閉じられます（onBlur）。 ツールチップが mouseIn で呼び出された場合、それは mouseOut で閉じられます。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that serves as the tooltip container has role tooltip.
    ツールチップコンテナーとして機能する要素には、ツールチップ（tooltip）ロールがあります。

    The element that triggers the tooltip references the tooltip element with aria-describedby.
    ツールチップをトリガーする要素は、aria-describedby を使用してツールチップ要素を参照します。





3.25 Tree View
3.25 ツリービュー

A tree view widget presents a hierarchical list. Any item in the hierarchy may have child items, and items that have children may be expanded or collapsed to show or hide the children. For example, in a file system navigator that uses a tree view to display folders and files, an item representing a folder can be expanded to reveal the contents of the folder, which may be files, folders, or both.
ツリービュー（tree view）ウィジェットは、階層リストを提示します。 階層内のすべての項目に子項目を含めることができ、子を持つ項目を展開または折りたたんで、子を表示または非表示にすることができます。 例えば、ツリービューを使用してフォルダーとファイルを表示するファイルシステムナビゲーターでは、フォルダーを表す項目を展開して、フォルダーの内容（ファイル、フォルダー、またはその両方）を表示できます。

Terms for understanding tree views include:
ツリービューを理解するための用語は次のとおりです。

Node
ノード（Node）

    An item in a tree. 
    ツリー内の項目。

Root Node
ルートノード（Root Node）

    Node at the base of the tree; it may have one or more child nodes but does not have a parent node.
    ツリーの根本にあるノード。 1つ以上の子ノードがある場合がありますが、親ノードはありません。

Child Node
子ノード（Child Node）

    Node that has a parent; any node that is not a root node is a child node.
    親を持つノード。 ルートノードではないノードはすべて子ノードです。

End Node
末端ノード（End Node）

    Node that does not have any child nodes; an end node may be either a root node or a child node.
    子ノードを持たないノード。 末端ノードは、ルートノードまたは子ノードのいずれかです。

Parent Node
親ノード（Parent Node）

    Node with one or more child nodes. It can be open (expanded) or closed (collapsed).
    1つ以上の子ノードを持つノード。 開く（展開する）または閉じる（折りたたむ）ことができます。

Open Node
開いているノード（Open Node）

    Parent node that is expanded so its child nodes are visible.
    子ノードが可視になるように展開された親ノード。

Closed Node
閉じているノード（Closed Node）

    Parent node that is collapsed so the child nodes are not visible.
    子ノードが可視にならないように折りたたまれている親ノード。

When using a keyboard to navigate a tree, a visual keyboard indicator informs the user which node is focused. If the tree allows the user to choose just one item for an action, then it is known as a single-select tree. In some implementations of single-select tree, the focused item also has a selected state; this is known as selection follows focus. However, in multi-select trees, which enable the user to select more than one item for an action, the selected state is always independent of the focus. For example, in a typical file system navigator, the user can move focus to select any number of files for an action, such as copy or move. It is important that the visual design distinguish between items that are selected and the item that has focus. For more details, see this description of differences between focus and selection and Deciding When to Make Selection Automatically Follow Focus.
キーボードを使用してツリーをナビゲートする場合、視覚的なキーボードインジケーターが、どのノードにフォーカスされているかをユーザーに通知します。 ツリーでユーザーがアクションに対して項目を1つだけ選択できる場合、それは単一選択ツリー（single-select tree）と呼ばれます。 単一選択ツリーの一部の実装では、フォーカスされた項目は選択された状態にもなります。 これは、選択はフォーカスに従うとして知られています。 ただし、ユーザーがアクションに対して複数の項目を選択できる複数選択ツリー（multi-select trees）では、選択された状態は常にフォーカスから独立しています。 例えば、一般的なファイルシステムナビゲーターでは、ユーザーはフォーカスを移動して、コピーや移動などのアクションに対してファイルをいくつでも選択できます。 ビジュアルデザインは、選択された項目とフォーカスのある項目を区別することが重要です。 詳細については、フォーカスと選択の違いに関するこの説明と、フォーカスに従って自動的に選択を行うかの決定を参照してください。




Examples
例

    File Directory Treeview Example Using Computed Properties: A file selector tree that demonstrates browser support for automatically computing aria-level, aria-posinset and aria-setsize based on DOM structure.
     計算されたプロパティを使用したファイルディレクトリーツリービューの例：DOM 構造に基づいて aria-level、aria-posinset、および aria-setsize を自動的に計算するためのブラウザーサポートを示すファイルセレクターツリー。

    File Directory Treeview Example Using Declared Properties: A file selector tree that demonstrates how to explicitly define values for aria-level, aria-posinset and aria-setsize.
     宣言されたプロパティを使用したファイルディレクトリーツリービューの例：aria-level、aria-posinset、および aria-setsize の値を明示的に定義する方法を示すファイルセレクターツリー。

    Navigation Treeview Example Using Computed Properties: A tree that provides navigation to a set of web pages and demonstrates browser support for automatically computing aria-level, aria-posinset and aria-setsize based on DOM structure.
     計算されたプロパティを使用したナビゲーションツリービューの例：一連のウェブページへのナビゲーションを提供し、DOM 構造に基づいて aria-level、aria-posinset、および aria-setsize を自動的に計算するためのブラウザーサポートを示すツリー。

    Navigation Treeview Example Using Declared Properties: A tree that provides navigation to a set of web pages and demonstrates how to explicitly define values for aria-level, aria-posinset and aria-setsize.
     宣言されたプロパティを使用したナビゲーションツリービューの例：一連のウェブページへのナビゲーションを提供し、aria-level、aria-posinset、および aria-setsize の値を明示的に定義する方法を示すツリー。





Keyboard Interaction
キーボードの相互作用

For a vertically oriented tree:
垂直方向のツリーの場合：

    When a single-select tree receives focus:
    単一選択ツリーがフォーカスを受け取ると：

        If none of the nodes are selected before the tree receives focus, focus is set on the first node.
        ツリーがフォーカスを受け取る前にノードが選択されていない場合、フォーカスは最初のノードに設定されます。

        If a node is selected before the tree receives focus, focus is set on the selected node.
        ツリーがフォーカスを受け取る前にノードが選択された場合、フォーカスは選択されたノードに設定されます。

    When a multi-select tree receives focus:
    複数選択ツリーがフォーカスを受け取ると：

        If none of the nodes are selected before the tree receives focus, focus is set on the first node.
        ツリーがフォーカスを受け取る前にノードが選択されていない場合、フォーカスは最初のノードに設定されます。

        If one or more nodes are selected before the tree receives focus, focus is set on the first selected node.
        ツリーがフォーカスを受け取る前に1つ以上のノードが選択された場合、フォーカスは最初に選択されたノードに設定されます。

    Right arrow:
    右矢印：

        When focus is on a closed node, opens the node; focus does not move.
        閉じているノードにフォーカスがある場合、ノードを開きます。 フォーカスは移動しません。

        When focus is on a open node, moves focus to the first child node.
        フォーカスが開いているノードにある場合、フォーカスを最初の子ノードに移動します。

        When focus is on an end node, does nothing.
        フォーカスが末端ノードにある場合、何もしません。

    Left arrow:
    左矢印：

        When focus is on an open node, closes the node.
        開いているノードにフォーカスがある場合、ノードを閉じます。

        When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.
        フォーカスが末端ノードまたは閉じているノードでもある子ノードにある場合、フォーカスをその親ノードに移動します。

        When focus is on a root node that is also either an end node or a closed node, does nothing.
        末端ノードまたは閉じているノードでもあるルートノードにフォーカスがある場合、何もしません。

    Down Arrow: Moves focus to the next node that is focusable without opening or closing a node.
    下矢印：ノードを開いたり閉じたりせずにフォーカスをフォーカス可能な次のノードに移動します。

    Up Arrow: Moves focus to the previous node that is focusable without opening or closing a node.
    上矢印：ノードを開いたり閉じたりせずにフォーカスをフォーカス可能な前のノードに移動します。

    Home: Moves focus to the first node in the tree without opening or closing a node.
    Home：ノードを開いたり閉じたりせずに、フォーカスをツリーの最初のノードに移動します。

    End: Moves focus to the last node in the tree that is focusable without opening a node.
    End：ノードを開かずに、フォーカスをフォーカス可能なツリーの最後のノードに移動します。

    Enter: activates a node, i.e., performs its default action. For parent nodes, one possible default action is to open or close the node. In single-select trees where selection does not follow focus (see note below), the default action is typically to select the focused node.
    Enter：ノードをアクティブ化します。 つまり、デフォルトのアクションを実行します。 親ノードの場合、考えられるデフォルトのアクションの1つは、ノードを開くか閉じることです。 選択がフォーカスに従わない単一選択ツリー（以下の注を参照）では、デフォルトのアクションは通常、フォーカスされたノードを選択することです。

    Type-ahead is recommended for all trees, especially for trees with more than 7 root nodes:
    すべてのツリー、特に7つを超えるルートノードを持つツリーには、先行タイプ入力をお勧めします。

        Type a character: focus moves to the next node with a name that starts with the typed character.
        文字をタイプ入力：フォーカスは、タイプ入力した文字で始まる名前の次のノードに移動します。

        Type multiple characters in rapid succession: focus moves to the next node with a name that starts with the string of characters typed.
        複数の文字をすばやく連続してタイプ入力：フォーカスは、タイプ入力した文字列で始まる名前の次のノードに移動します。

    * (Optional): Expands all siblings that are at the same level as the current node.
    *（任意）：現在のノードと同じレベルにあるすべての兄弟を展開します。

    Selection in multi-select trees: Authors may implement either of two interaction models to support multiple selection: a recommended model that does not require the user to hold a modifier key, such as Shift or Control, while navigating the list or an alternative model that does require modifier keys to be held while navigating in order to avoid losing selection states.
    複数選択ツリーでの選択：作成者は、複数選択をサポートするために2つの相互作用モデルのいずれかを実装できます。 リストをナビゲートしている間、ユーザーが Shift や Control などの修飾キーを保持する必要がない推奨モデルと選択状態が失われないようにするために、ナビゲート中に修飾キーを保持する必要がある代替モデルがあります。

        Recommended selection model -- holding a modifier key while moving focus is not necessary:
        推奨される選択モデル -- フォーカスを移動するときに修飾キーを保持する必要はありません。

            Space: Toggles the selection state of the focused node.
            スペース：フォーカスされたノードの選択状態を切り替えます。

            Shift + Down Arrow (Optional): Moves focus to and toggles the selection state of the next node.
            Shift + 下矢印（任意）：フォーカスを次のノードに移動し、選択状態を切り替えます。

            Shift + Up Arrow (Optional): Moves focus to and toggles the selection state of the previous node.
            Shift + 上矢印（任意）：フォーカスを前のノードに移動し、選択状態を切り替えます。

            Shift + Space (Optional): Selects contiguous nodes from the most recently selected node to the current node.
            Shift + スペース（任意）：最後に選択したノードから現在のノードまでの連続するノードを選択します。

            Control + Shift + Home (Optional): Selects the node with focus and all nodes up to the first node. Optionally, moves focus to the first node.
            Control + Shift + Home（任意）：フォーカスのあるノードと最初のノードまでのすべてのノードを選択します。 任意で、フォーカスを最初のノードに移動します。

            Control + Shift + End (Optional): Selects the node with focus and all nodes down to the last node. Optionally, moves focus to the last node.
            Control + Shift + End（任意）：フォーカスのあるノードと最後のノードまでのすべてのノードを選択します。 任意で、フォーカスを最後のノードに移動します。

            Control + A (Optional): Selects all nodes in the tree. Optionally, if all nodes are selected, it can also unselect all nodes.
            Control + A（任意）：ツリー内のすべてのノードを選択します。 任意で、すべてのノードが選択されている場合は、すべてのノードの選択を解除することもできます。

        Alternative selection model -- Moving focus without holding the Shift or Control modifier unselects all selected nodes except for the focused node:
        代替選択モデル -- Shift または Control の修飾キーを押さずにフォーカスを移動すると、フォーカスされたノードを除くすべての選択されたノードの選択が解除されます。

            Shift + Down Arrow: Moves focus to and toggles the selection state of the next node.
            Shift + 下矢印：フォーカスを次のノードに移動し、次のノードの選択状態を切り替えます。

            Shift + Up Arrow: Moves focus to and toggles the selection state of the previous node.
            Shift + 上矢印：フォーカスを前のノードに移動し、前のノードの選択状態を切り替えます。

            Control + Down Arrow: Without changing the selection state, moves focus to the next node.
            Control +下矢印：選択状態を変更せずに、フォーカスを次のノードに移動します。

            Control + Up Arrow: Without changing the selection state, moves focus to the previous node.
            Control +上矢印：選択状態を変更せずに、フォーカスを前のノードに移動します。

            Control + Space: Toggles the selection state of the focused node.
            Control + スペース：フォーカスされたノードの選択状態を切り替えます。

            Shift + Space (Optional): Selects contiguous nodes from the most recently selected node to the current node.
            Shift + スペース（任意）：最後に選択したノードから現在のノードまでの連続するノードを選択します。

            Control + Shift + Home (Optional): Selects the node with focus and all nodes up to the first node. Optionally, moves focus to the first node.
            Control + Shift + Home（任意）：フォーカスのあるノードと最初のノードまでのすべてのノードを選択します。 任意で、フォーカスを最初のノードに移動します。

            Control + Shift + End (Optional): Selects the node with focus and all nodes down to the last node. Optionally, moves focus to the last node.
            Control + Shift + End（任意）：フォーカスのあるノードと最後のノードまでのすべてのノードを選択します。 任意で、フォーカスを最後のノードに移動します。

            Control + A (Optional): Selects all nodes in the tree. Optionally, if all nodes are selected, it can also unselect all nodes.
            Control + A（任意）：ツリー内のすべてのノードを選択します。 任意で、すべてのノードが選択されている場合は、すべてのノードの選択を解除することもできます。

Note
注

    DOM focus (the active element) is functionally distinct from the selected state. For more details, see this description of differences between focus and selection.
    1. DOM のフォーカス（アクティブな要素）は、選択された状態とは機能的に異なります。 詳細については、フォーカスと選択の違いに関するこの説明を参照してください。

    The tree role supports the aria-activedescendant property, which provides an alternative to moving DOM focus among treeitem elements when implementing keyboard navigation. For details, see Managing Focus in Composites Using aria-activedescendant.
    2. ツリーロールは、キーボードナビゲーションを実装するときにツリー項目要素間で DOM フォーカスを移動する代わりの方法を提供する aria-activedescendant プロパティをサポートします。 詳細については、aria-activedescendant を使用した複合ウィジェットでのフォーカスの管理を参照してください。

    In a single-select tree, moving focus may optionally unselect the previously selected node and select the newly focused node. This model of selection is known as "selection follows focus". Having selection follow focus can be very helpful in some circumstances and can severely degrade accessibility in others. For additional guidance, see Deciding When to Make Selection Automatically Follow Focus.
    3. 単一選択ツリーでは、フォーカスを移動すると、任意で、以前に選択したノードの選択を解除し、新しくフォーカスしたノードを選択できます。 この選択モデルは、「選択はフォーカスに従う」として知られています。 選択をフォーカスに従わせることは、状況によっては非常に役立ち、他の状況ではアクセシビリティを大幅に低下させる可能性があります。 追加のガイダンスについては、フォーカスに従って自動的に選択を行うかの決定を参照してください。

    If selecting or unselecting all nodes is an important function, implementing separate controls for these actions, such as buttons for "Select All" and "Unselect All", significantly improves accessibility.
    4.すべてのノードの選択または選択解除が重要な機能である場合、「すべて選択」および「すべて選択解除」のボタンなど、これらのアクションに個別のコントロールを実装すると、アクセシビリティが大幅に向上します。

    If the nodes in a tree are arranged horizontally:
    5. ツリー内のノードが水平に配置されている場合：

        Down Arrow performs as Right Arrow is described above, and vice versa.
        1. 下矢印は、上記の右矢印と同様に機能し、その逆も同様です。

        Up Arrow performs as Left Arrow is described above, and vice versa.
        2. 上矢印は、上記の左矢印と同様に機能し、その逆も同様です。





WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    All tree nodes are contained in or owned by an element with role tree.
    すべてのツリーノードは、ツリー（tree）ロールを持つ要素に含まれるか、その要素によって所有されます。

    Each element serving as a tree node has role treeitem.
    ツリーノードとして機能する各要素には、ツリー項目（treeitem）ロールがあります。

    Each root node is contained in the element with role tree or referenced by an aria-owns property set on the tree element.
    各ルートノードは、ツリーロールを持つ要素に含まれるか、ツリー要素に設定された aria-owns プロパティによって参照されます。

    Each parent node contains or owns an element with role group.
    各親ノードは、グループ（group）ロールを持つ要素が含まれるか、所有されます。

    Each child node is contained in or owned by an element with role group that is contained in or owned by the node that serves as the parent of that child.
    各子ノードは、その子の親として機能するノードに含まれているか、所有されているグループロールを持つ要素に含まれているか、所有されています。

    Each element with role treeitem that serves as a parent node has aria-expanded set to false when the node is in a closed state and set to true when the node is in an open state. End nodes do not have the aria-expanded attribute because, if they were to have it, they would be incorrectly described to assistive technologies as parent nodes.
    親ノードとして機能するツリー項目ロールを持つ各要素では、ノードが閉じた状態の場合は aria-expanded が false に設定され、ノードが開いた状態の場合は true に設定されます。 末端ノードには aria-expanded 属性がありません。 これは、末端ノードに aria-expanded 属性がある場合、親ノードとして支援技術に誤って説明されるためです。

    If the tree supports selection of more than one node, the element with role tree has aria-multiselectable set to true. Otherwise, aria-multiselectable is either set to false or the default value of false is implied.
    ツリーが複数のノードの選択をサポートしている場合、ツリーロールを持つ要素の aria-multiselectable が true に設定されます。 それ以外の場合、aria-multiselectable は false に設定されるか、デフォルト値の false が暗黙指定されます。

    If the tree does not support multiple selection, aria-selected is set to true for the selected node and it is not present on any other node in the tree.
    ツリーが複数選択をサポートしていない場合、選択されたノードに対して aria-selected が true に設定され、ツリー内の他のノードに aria-selected は存在しません。

    if the tree supports multiple selection:
    ツリーが複数選択をサポートしている場合：

        All selected nodes have aria-selected set to true.
        選択されたすべてのノードでは、aria-selected が true に設定されています。

        All nodes that are selectable but not selected have aria-selected set to false.
        選択可能であるが選択されていないすべてのノードでは、aria-selected が false に設定されています。

        If the tree contains nodes that are not selectable, those nodes do not have the aria-selected state.
        ツリーに選択できないノードが含まれている場合、それらのノードには aria-selected 状態がありません。

    The element with role tree has either a visible label referenced by aria-labelledby or a value specified for aria-label.
    ツリーロールを持つ要素には、aria-labelledby によって参照される可視ラベル、または aria-label に指定された値があります。

    If the complete set of available nodes is not present in the DOM due to dynamic loading as the user moves focus in or scrolls the tree, each node has aria-level, aria-setsize, and aria-posinset specified.
    ユーザーがフォーカスを移動したりツリーをスクロールしたりするときに動的な読み込みが原因で、使用可能なノードの完全なセットが DOM に存在しない場合、各ノードには aria-level、aria-setsize、および aria-posinset が指定されています。

    If the tree element is horizontally oriented, it has aria-orientation set to horizontal. The default value of aria-orientation for a tree is vertical.
    ツリー要素が水平方向の場合、aria-orientation は水平（horizontal）に設定されています。 ツリーの aria-orientation のデフォルト値は垂直（vertical）です。

Note
注

If aria-owns is set on the tree container to include elements that are not DOM children of the container, those elements will appear in the reading order in the sequence they are referenced and after any items that are DOM children. Scripts that manage focus need to ensure the visual focus order matches this assistive technology reading order.
コンテナーの DOM の子ではない要素を含めるように、ツリーコンテナーで aria-owns が設定されている場合、それらの要素は、参照される順序で、DOM の子である項目の後に読み順で現れます。 フォーカスを管理するスクリプトは、視覚的なフォーカスの順序がこの支援技術の読み順と一致することを確認する必要があります。




3.26 Treegrid
3.26 ツリーグリッド

A treegrid widget presents a hierarchical data grid consisting of tabular information that is editable or interactive. Any row in the hierarchy may have child rows, and rows with children may be expanded or collapsed to show or hide the children. For example, in a treegrid used to display messages and message responses for a e-mail discussion list, messages with responses would be in rows that can be expanded to reveal the response messages.
ツリーグリッド（treegrid）ウィジェットは、編集可能またはインタラクティブな表形式の情報で構成される階層データグリッドを提示します。 階層内のどの行も子行を持つことができ、子のある行は、子を表示または非表示にするために展開または折りたたむことができます。 例えば、電子メールディスカッションリストのメッセージとメッセージの応答を表示するために使用されるツリーグリッドでは、応答のあるメッセージは、応答メッセージを表示するために展開できる行になります。

In a treegrid both rows and cells are focusable. Every row and cell contains a focusable element or is itself focusable, regardless of whether individual cell content is editable or interactive. There is one exception: if column header cells do not provide functions, such as sort or filter, they do not need to be focusable. One reason it is important for all cells to be able to receive or contain keyboard focus is that screen readers will typically be in their application reading mode, rather than their document reading mode, when users are interacting with the grid. While in application mode, a screen reader user hears only focusable elements and content that labels focusable elements. So, screen reader users may unknowingly overlook elements contained in a treegrid that are either not focusable or not used to label a column or row.
ツリーグリッドでは、行とセルの両方にフォーカス可能です。 すべての行とセルには、個々のセルコンテンツが編集可能かインタラクティブかに関係なく、フォーカス可能な要素が含まれているか、それ自体がフォーカス可能です。 例外が1つあります。 列ヘッダーセルが並べ替えやフィルターなどの機能を提供しない場合、フォーカス可能である必要はありません。 すべてのセルがキーボードフォーカスを受け取ったり、含んだりできることが重要である理由の1つは、ユーザーがグリッドを操作しているとき、スクリーンリーダーは通常、文書読み取りモードではなく、アプリケーション読み取りモードになるためです。 アプリケーションモードでは、スクリーンリーダーのユーザーには、フォーカス可能な要素と、フォーカス可能な要素にラベルを付けるコンテンツのみが聞こえます。 そのため、スクリーンリーダーのユーザーは、フォーカスできないか、列または行のラベル付けに使用されないツリーグリッドに含まれる要素を知らないうちに見落とす可能性があります。

When using a keyboard to navigate a treegrid, a visual keyboard indicator informs the user which row or cell is focused. If the treegrid allows the user to choose just one item for an action, then it is known as a single-select treegrid, and the item with focus also has a selected state. However, in multi-select treegrids, which enable the user to select more than one row or cell for an action, the selected state is independent of the focus. For example, in a hierarchical e-mail discussion grid, the user can move focus to select any number of rows for an action, such as delete or move. It is important that the visual design distinguish between items that are selected and the item that has focus. For more details, see this description of differences between focus and selection.
キーボードを使用してツリーグリッドをナビゲートする場合、視覚的なキーボードインジケーターが、どの行またはセルにフォーカスされているかをユーザーに通知します。 ツリーグリッドでユーザーがアクションに対して1つの項目のみを選択できる場合、それは単一選択ツリーグリッド（single-select treegrid）と呼ばれ、フォーカスされた項目は選択された状態でもあります。 ただし、ユーザーがアクションに対して複数の行またはセルを選択できる複数選択ツリーグリッド（multi-select treegrid）では、選択された状態はフォーカスに依存しません。 例えば、階層型の電子メールディスカッショングリッドでは、ユーザーはフォーカスを移動して、削除や移動などのアクションの行をいくつでも選択できます。 ビジュアルデザインは、選択された項目とフォーカスのある項目を区別することが重要です。 詳細については、フォーカスと選択の違いに関するこの説明を参照してください。




Examples
例

    E-mail Inbox treegrid Example: A treegrid for navigating an e-mail inbox that demonstrates three keyboard navigation models -- rows first, cells first, and cells only.
     電子メール受信ボックスツリーグリッドの例：電子メール受信ボックスをナビゲートするためのツリーグリッドで、3つのキーボードナビゲーションモデル（行が先、セルが先、セルのみ）を示します。 





Keyboard Interaction
キーボードの相互作用

The following keys provide treegrid navigation by moving focus among rows and cells of the grid. Implementations of treegrid make these key commands available when an element in the grid has received focus, e.g., after a user has moved focus to the grid with Tab. Moving focus into the grid may result in the first cell or the first row being focused. Whether focus goes to a cell or the row depends on author preferences and whether row focus is supported, since some treegrids may not provide focus to rows.
次のキーは、グリッドの行とセルの間でフォーカスを移動することにより、ツリーグリッドナビゲーションを提供します。 ツリーグリッドの実装により、グリッド内の要素がフォーカスを受け取ったとき、例えば、ユーザーが Tab キーを使用してグリッドにフォーカスを移動した後などに、これらのキーコマンドを使用できるようになります。 フォーカスをグリッドに移動すると、最初のセルまたは最初の行がフォーカスされる場合があります。 一部のツリーグリッドは行にフォーカスを提供しない場合があるため、フォーカスがセルに移動するか行に移動するかは、作成者の設定と行フォーカスがサポートされているかどうかによって異なります。

    Enter: If cell-only focus is enabled and focus is on the first cell with the aria-expanded property, opens or closes the child rows.,Otherwise, performs the default action for the cell.
    Enter：セルのみのフォーカスが有効で、フォーカスが aria-expanded プロパティを持つ最初のセルにある場合、子行を開いたり閉じたりします。 それ以外の場合、セルのデフォルトのアクションを実行します。

    Tab: If the row containing focus contains focusable elements (e.g., inputs, buttons, links, etc.), moves focus to the next input in the row. If focus is on the last focusable element in the row, moves focus out of the treegrid widget to the next focusable element.
    Tab：フォーカスを含む行にフォーカス可能な要素（入力、ボタン、リンクなど）が含まれている場合、フォーカスを行の次の入力に移動します。 行の最後のフォーカス可能な要素にフォーカスがある場合は、フォーカスをツリーグリッドウィジェットから次のフォーカス可能な要素に移動します。

    Right Arrow:
    右矢印：

        If focus is on a collapsed row, expands the row.
        折りたたまれた行にフォーカスがある場合は、行を展開します。

        If focus is on an expanded row or is on a row that does not have child rows, moves focus to the first cell in the row.
        フォーカスが展開された行にある場合、または子行が​​ない行にある場合は、フォーカスを行の最初のセルに移動します。

        If focus is on the right-most cell in a row, focus does not move.
        行の右端のセルにフォーカスがある場合、フォーカスは移動しません。

        If focus is on any other cell, moves focus one cell to the right.
        フォーカスが他のセルにある場合は、フォーカスを1セル右に移動します。

    Left Arrow:
    左矢印：

        If focus is on an expanded row, collapses the row.
        展開された行にフォーカスがある場合は、行を折りたたみます。

        If focus is on a collapsed row or on a row that does not have child rows, focus does not move.
        折りたたまれた行または子行が​​ない行にフォーカスがある場合、フォーカスは移動しません。

        If focus is on the first cell in a row and row focus is supported, moves focus to the row.
        フォーカスが行の最初のセルにあり、行フォーカスがサポートされている場合、フォーカスを行に移動します。

        If focus is on the first cell in a row and row focus is not supported, focus does not move.
        フォーカスが行の最初のセルにあり、行のフォーカスがサポートされていない場合、フォーカスは移動しません。

        If focus is on any other cell, moves focus one cell to the left.
        フォーカスが他のセルにある場合は、フォーカスを1セル左に移動します。

    Down Arrow:
    下矢印：

        If focus is on a row, moves focus one row down. If focus is on the last row, focus does not move.
        フォーカスが行にある場合、フォーカスを1行下に移動します。 フォーカスが最後の行にある場合、フォーカスは移動しません。

        If focus is on a cell, moves focus one cell down. If focus is on the bottom cell in the column, focus does not move.
        フォーカスがセルにある場合は、フォーカスを1セル下に移動します。 列の一番下のセルにフォーカスがある場合、フォーカスは移動しません。

    Up Arrow:
    上矢印：

        If focus is on a row, moves focus one row up. If focus is on the first row, focus does not move.
        フォーカスが行にある場合、フォーカスを1行上に移動します。 フォーカスが最初の行にある場合、フォーカスは移動しません。

        If focus is on a cell, moves focus one cell up. If focus is on the top cell in the column, focus does not move.
        フォーカスがセルにある場合、フォーカスを1セル上に移動します。 フォーカスが列の一番上のセルにある場合、フォーカスは移動しません。

    Page Down:
    Page Down：

        If focus is on a row, moves focus down an author-determined number of rows, typically scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows. If focus is in the last row, focus does not move.
        フォーカスが行にある場合、フォーカスを作成者が決定した行数だけ下に移動します。 通常はスクロールして、現在可視の行のセットの一番下の行が最初の可視行の1つになります。 フォーカスが最後の行にある場合、フォーカスは移動しません。

        If focus is on a cell, moves focus down an author-determined number of cells, typically scrolling so the bottom row in the currently visible set of rows becomes one of the first visible rows. If focus is in the last row, focus does not move.
        フォーカスがセルにある場合は、フォーカスを作成者が決定したセル数だけ下に移動します。 通常はスクロールして、現在可視の行のセットの一番下の行が最初の可視行の1つになります。 フォーカスが最後の行にある場合、フォーカスは移動しません。

    Page Up:
    Page Up：

        If focus is on a row, moves focus up an author-determined number of rows, typically scrolling so the top row in the currently visible set of rows becomes one of the last visible rows. If focus is in the first row, focus does not move.
        フォーカスが行にある場合、フォーカスを作成者が決定した行数だけ上に移動します。 通常はスクロールして、現在可視の行のセットの一番上の行が最後の可視行の1つになります。 フォーカスが最初の行にある場合、フォーカスは移動しません。

        If focus is on a cell, moves focus up an author-determined number of cells, typically scrolling so the top row in the currently visible set of rows becomes one of the last visible rows. If focus is in the first row, focus does not move.
        フォーカスがセルにある場合、フォーカスを作成者が決定したセル数だけ上に移動します。 通常はスクロールして、現在可視の行のセットの一番上の行が最後の可視行の1つになります。 フォーカスが最初の行にある場合、フォーカスは移動しません。

    Home:
    Home：

        If focus is on a row, moves focus to the first row. If focus is in the first row, focus does not move.
        フォーカスが行にある場合、フォーカスを最初の行に移動します。 フォーカスが最初の行にある場合、フォーカスは移動しません。

        If focus is on a cell, moves focus to the first cell in the row. If focus is in the first cell of the row, focus does not move.
        フォーカスがセルにある場合、フォーカスを行の最初のセルに移動します。 フォーカスが行の最初のセルにある場合、フォーカスは移動しません。

    End:
    End：

        If focus is on a row, moves focus to the last row. If focus is in the last row, focus does not move.
        フォーカスが行にある場合、フォーカスを最後の行に移動します。 フォーカスが最後の行にある場合、フォーカスは移動しません。

        If focus is on a cell, moves focus to the last cell in the row. If focus is in the last cell of the row, focus does not move.
        フォーカスがセルにある場合、フォーカスを行の最後のセルに移動します。 フォーカスが行の最後のセルにある場合、フォーカスは移動しません。

    Control + Home:
    Control + Home：

        If focus is on a row, moves focus to the first row. If focus is in the first row, focus does not move.
        フォーカスが行にある場合、フォーカスを最初の行に移動します。 フォーカスが最初の行にある場合、フォーカスは移動しません。

        If focus is on a cell, moves focus to the first cell in the column. If focus is in the first row, focus does not move.
        フォーカスがセルにある場合、フォーカスを列の最初のセルに移動します。 フォーカスが最初の行にある場合、フォーカスは移動しません。

    Control + End:
    Control + End：

        If focus is on a row, moves focus to the last row. If focus is in the last row, focus does not move.
        フォーカスが行にある場合、フォーカスを最後の行に移動します。 フォーカスが最後の行にある場合、フォーカスは移動しません。

        If focus is on a cell, moves focus to the last cell in the column. If focus is in the last row, focus does not move.
        フォーカスがセルにある場合、フォーカスを列の最後のセルに移動します。 フォーカスが最後の行にある場合、フォーカスは移動しません。

Note
注

    When the above treegrid navigation keys move focus, whether the focus is set on an element inside the cell or on the cell depends on cell content. See Whether to Focus on a Cell or an Element Inside It.
     上記のツリーグリッドナビゲーションキーがフォーカスを移動する場合、フォーカスがセル内の要素に設定されるかセルに設定されるかは、セルコンテンツによって異なります。 セルまたはその中の要素のどちらにフォーカスを当てるかを参照してください。

    While navigation keys, such as arrow keys, are moving focus from cell to cell, they are not available to do something like operate a combobox or move an editing caret inside of a cell. If this functionality is needed, see Editing and Navigating Inside a Cell.
     矢印キーなどのナビゲーションキーがセル間でフォーカスを移動している間は、コンボボックスの操作やセル内の編集キャレットの移動などを行うことはできません。 この機能が必要な場合は、セル内の編集とナビゲートを参照してください。

    If navigation functions can dynamically add more rows or columns to the DOM, key events that move focus to the beginning or end of the grid, such as control + End, may move focus to the last row in the DOM rather than the last available row in the back-end data.
     ナビゲーション機能が動的に行または列を DOM に追加できる場合、Control + End など、フォーカスをグリッドの最初または最後に移動するキーイベントは、バックエンドデータで使用可能な最後の行ではなく、DOM の最後の行にフォーカスを移動する場合があります。

If a treegrid supports selection of cells, rows, or columns, the following keys are commonly used for these functions.
ツリーグリッドがセル、行、または列の選択をサポートしている場合、これらの機能には通常、次のキーが使用されます。

    Control + Space:
    Control + スペース：

        If focus is on a row, selects all cells.
        行にフォーカスがある場合は、すべてのセルを選択します。

        If focus is on a cell, selects the column that contains the focus.
        フォーカスがセルにある場合は、フォーカスを含む列を選択します。

    Shift + Space:
    Shift + スペース：

        If focus is on a row, selects the row.
        行にフォーカスがある場合は、行を選択します。

        If focus is on a cell, selects the row that contains the focus. If the treegrid includes a column with checkboxes for selecting rows, this key can serve as a shortcut for checking the box when focus is not on the checkbox.
        フォーカスがセルにある場合は、フォーカスを含む行を選択します。ツリーグリッドに行を選択するためのチェックボックスのある列が含まれている場合、このキーは、フォーカスがチェックボックスにないときにチェックボックスをオンにするためのショートカットとして機能します。

    Control + A: Selects all cells.
    Control + A：すべてのセルを選択します。

    Shift + Right Arrow:
    Shift + 右矢印：

        If focus is on a row, does not change selection.
        フォーカスが行にある場合、選択を変更しません。

        if focus is on a cell, extends selection one cell to the right.
        フォーカスがセルにある場合は、選択範囲を1セル右に拡張します。

    Shift + Left Arrow:
    Shift + 左矢印：

        If focus is on a row, does not change selection.
        フォーカスが行にある場合、選択を変更しません。

        if focus is on a cell, extends selection one cell to the left.
        フォーカスがセルにある場合は、選択範囲を1セル左に拡張します。

    Shift + Down Arrow:
    Shift + 下矢印：

        If focus is on a row, extends selection to all the cells in the next row.
        フォーカスが行にある場合、選択範囲を次の行のすべてのセルに拡張します。

        If focus is on a cell, extends selection one cell down.
        フォーカスがセルにある場合は、選択範囲を1セル下に拡張します。

    Shift + Up Arrow:
    Shift +上矢印：

        If focus is on a row, extends selection to all the cells in the previous row.
        フォーカスが行にある場合、選択範囲を前の行のすべてのセルに拡張します。

        If focus is on a cell, extends selection one cell up.
        フォーカスがセルにある場合は、選択範囲を1セル上に拡張します。

Note
注

See § 6.8 Key Assignment Conventions for Common Functions for cut, copy, and paste key assignments.
切り取り、コピー、貼り付けのキー割り当てについては、§6.8 共通機能のキー割り当て規則を参照してください。 




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The treegrid container has role treegrid.
    ツリーグリッドコンテナーには、ツリーグリッド（treegrid）ロールがあります。

    Each row container has role row and is either a DOM descendant of or owned by the treegrid element or an element with role rowgroup.
    各行コンテナーには、行（row）ロールがあり、ツリーグリッド要素または　行グループ（rowgroup）ロールを持つ要素の DOM の子孫であるか、所有されています。

    Each cell is either a DOM descendant of or owned by a row element and has one of the following roles:
    各セルは、行要素の DOM 子孫であるか、行要素によって所有されており、次のいずれかのロールを持ちます。

        columnheader if the cell contains a title or header information for the column.
        セルに列のタイトルまたはヘッダー情報が含まれている場合は、列ヘッダー（columnheader）。

        rowheader if the cell contains title or header information for the row.
        セルに行のタイトルまたはヘッダー情報が含まれている場合は、行ヘッダー（rowheader）。

        gridcell if the cell does not contain column or row header information.
        セルに列または行のヘッダー情報が含まれていない場合は、グリッドセル（gridcell）。

    A row that can be expanded or collapsed to show or hide a set of child rows is a parent row. Each parent row has the aria-expanded state set on either the row element or on a cell contained in therow. The aria-expanded state is set to false when the child rows are not displayed and set to true when the child rows are displayed. Rows that do not control display of child rows do not have the aria-expanded attribute because, if they were to have it, they would be incorrectly described to assistive technologies as parent rows.
    子行のセットを表示または非表示にするために展開または折りたたむことができる行は、親行です。 各親行には、行要素または行に含まれるセルのいずれかに設定された aria-expanded 状態があります。 aria-expanded 状態は、子行が表示されていない場合は false に設定され、子行が表示されている場合は true に設定されます。 子行の表示を制御しない行には、aria-expanded 属性がありません。 これは、子行がある場合、支援技術に対して親行として誤って説明されるためです。

    If the treegrid supports selection of more than one row or cell, it is a multi-select treegrid and the element with role treegrid has aria-multiselectable set to true. Otherwise, it is a single-select treegrid, and aria-multiselectable is either set to false or the default value of false is implied.
    ツリーグリッドが複数の行またはセルの選択をサポートしている場合、それは複数選択ツリーグリッドであり、ツリーグリッドロールを持つ要素の aria-multiselectable が true に設定されています。 それ以外の場合、単一選択ツリーグリッドであり、aria-multiselectable が false に設定されているか、デフォルト値の false が暗黙指定されています。

    If the treegrid is a single-select treegrid, aria-selected is set to true on the selected row or cell, and it is not present on any other row or cell in the treegrid.
    ツリーグリッドが単一選択ツリーグリッドの場合、aria-selected は選択された行またはセルで true に設定され、ツリーグリッド内の他の行またはセルには存在しません。

    if the treegrid is a multi-select treegrid:
    ツリーグリッドが複数選択ツリーグリッドの場合：

        All selected rows or cells have aria-selected set to true.
        選択されたすべての行またはセルでは、aria-selected が true に設定されています。

        All rows and cells that are not selected have aria-selected set to false.
        選択されていないすべての行とセルでは、aria-selected が false に設定されています。

    If there is an element in the user interface that serves as a label for the treegrid, aria-labelledby is set on the grid element with a value that refers to the labelling element. Otherwise, a label is specified for the grid element using aria-label.
    ツリーグリッドのラベルとして機能する要素がユーザーインターフェイスにある場合、aria-labelledby は、ラベル付け要素を参照する値でグリッド要素に設定されます。 それ以外の場合、aria-label を使用してグリッド要素にラベルが指定されます。

    If the treegrid has a caption or description, aria-describedby is set on the grid element with a value referring to the element containing the description.
    ツリーグリッドにキャプションまたは説明がある場合、aria-describedby は、説明を含む要素を参照する値を使用してグリッド要素に設定されます。

    If the treegrid provides sort functions, aria-sort is set to an appropriate value on the header cell element for the sorted column or row as described in the section on grid and table properties.
    ツリーグリッドが並べ替え機能を提供する場合、グリッドとテーブルのプロパティのセクションで説明されているように、並べ替えられた列または行のヘッダーセル要素で aria-sort が適切な値に設定されます。

    If the treegrid provides content editing functionality and contains cells that may have edit capabilities disabled in certain conditions, aria-readonly is set to true on cells where editing is disabled. If edit functions are disabled for all cells, instead of setting aria-readonly to true on every cell, aria-readonly may be set to true on the treegrid element. Treegrids that do not provide cell content editing functions do not include the aria-readonly attribute on any of their elements.
    ツリーグリッドがコンテンツ編集機能を提供し、特定の条件で編集機能が無効化されている可能性のあるセルが含まれている場合、編集が無効化されているセルでは aria-readonly が true に設定されます。 すべてのセルで編集機能が無効化されている場合、すべてのセルで aria-readonly を true に設定する代わりに、ツリーグリッド要素で aria-readonly を true に設定できます。 セルコンテンツ編集機能を提供しないツリーグリッドは、その要素のいずれにも aria-readonly 属性を含みません。

    If there are conditions where some rows or columns are hidden or not present in the DOM, e.g., data is dynamically loaded when scrolling or the grid provides functions for hiding rows or columns, the following properties are applied as described in the section on grid and table properties.
    一部の行または列が非表示または DOM に存在しない条件がある場合、例えば、スクロール時にデータが動的に読み込まれる場合、またはグリッドが行または列を非表示にする機能を提供する場合、グリッドとテーブルのプロパティのセクションで説明されているように、次のプロパティが適用されます。

        aria-colcount or aria-rowcount is set to the total number of columns or rows, respectively.
        aria-colcount または aria-rowcount は、それぞれ列または行の総数に設定されます。

        aria-colindex or aria-rowindex is set to the position of a cell within a row or column, respectively.
        aria-colindex または aria-rowindex は、それぞれ行または列内のセルの位置に設定されます。

    If the treegrid includes cells that span multiple rows or multiple columns, and if the treegrid role is NOT applied to an HTML table element, then aria-rowspan or aria-colspan is applied as described in grid and table properties.
    ツリーグリッドに複数の行または複数の列にまたがるセルが含まれていて、ツリーグリッドロールが HTML テーブル要素に適用されていない場合、グリッドとテーブルのプロパティで説明されているように aria-rowspan または aria-colspan が適用されます。

Note
注

    A treegrid built from an HTML table that includes cells that span multiple rows or columns must use HTML rowspan and colspan and must not use aria-rowspan or aria-colspan.
    複数の行または列にまたがるセルを含む HTML テーブルから構築されたツリーグリッドは、HTML の rowspan と colspan を使用する必要があり、aria-rowspan や aria-colspan を使用してはなりません。

    If rows or cells are included in a treegrid via aria-owns, they will be presented to assistive technologies after the DOM descendants of the treegrid element unless the DOM descendants are also included in the aria-owns attribute.
    行またはセルが aria-owns を介してツリーグリッドに含まれている場合、ツリーグリッド要素の DOM の子孫が aria-owns 属性に含まれている場合を除き、それらはツリーグリッド要素の DOM の子孫の後に支援技術に提示されます。





3.27 Window Splitter
3.27 ウィンドウスプリッター

NOTE: ARIA 1.1 introduced changes to the separator role so it behaves as a widget when focusable. While this pattern has been revised to match the ARIA 1.1 specification, the task force will not complete its review until a functional example that matches the ARIA 1.1 specification is complete. Progress on this pattern is tracked by issue 129.
注：ARIA 1.1 では、区切り（separator、セパレーター）ロールに変更が加えられたため、フォーカス可能な場合はウィジェットとして振る舞います。 このパターンは ARIA 1.1 仕様に一致するように改訂されていますが、タスクフォースは ARIA 1.1 仕様に一致する機能例が完了するまでレビューを完了しません。 このパターンの進捗状況は、issue 129 によって追跡されます。

A window splitter is a moveable separator between two sections, or panes, of a window that enables users to change the relative size of the panes. A Window Splitter can be either variable or fixed. A fixed splitter toggles between two positions whereas a variable splitter can be adjusted to any position within an allowed range.
ウィンドウスプリッター（window splitter）は、ウィンドウの2つのセクション、つまりペイン（panes）間で移動可能な区切りであり、ユーザーがペインの相対的なサイズを変更できるようにします。 ウィンドウスプリッターは、可変または固定のいずれかです。 固定スプリッターは2つの位置を切り替えますが、可変スプリッターは許容範囲内の任意の位置に調整できます。

A window splitter has a value that represents the size of one of the panes, which, in this pattern, is called the primary pane. When the splitter has its minimum value, the primary pane has its smallest size and the secondary pane has its largest size. The splitter also has an accessible name that matches the name of the primary pane.
ウィンドウスプリッターには、ペインの1つのサイズを表す値があります。 このパターンでは、これはプライマリーペインと呼ばれます。 スプリッターの値が最小の場合、プライマリーペインのサイズが最小になり、セカンダリーペインのサイズが最大になります。 スプリッターには、プライマリーペインの名前と一致するアクセス可能な名前もあります。

For example, consider a book reading application with a primary pane for the table of contents and a secondary pane that displays content from a section of the book. The two panes are divided by a vertical splitter labelled "Table of Contents". When the table of contents pane has its maximum size, the splitter has a value of 100, and when the table of contents is completely collapsed, the splitter has a value of 0.
例えば、目次のプライマリーペインと、本のセクションのコンテンツを表示するセカンダリーペインを備えた読書アプリケーションについて考えてみます。 2つのペインは、「目次」というラベルの付いた垂直スプリッターによって分割されています。 目次ペインの最大サイズの場合、スプリッターの値は 100 になり、目次が完全に折りたたまれている場合、スプリッターの値は 0 になります。

Note that the term "primary pane" does not describe the importance or purpose of content inside the pane.
「プライマリーペイン」という用語は、ペイン内のコンテンツの重要性や目的を説明していないことに注意してください。




Example
例

Work to develop an example window splitter widget is tracked by issue 130.
ウィンドウスプリッターウィジェットの例を開発する作業は、issue 130 によって追跡されます。 




Keyboard Interaction
キーボードの相互作用

    Left Arrow: Moves a vertical splitter to the left.
    左矢印：垂直スプリッターを左に移動します。

    Right Arrow: Moves a vertical splitter to the right.
    右矢印：垂直スプリッターを右に移動します。

    Up Arrow: Moves a horizontal splitter up.
    上矢印：水平スプリッターを上に移動します。

    Down Arrow: Moves a horizontal splitter down.
    下矢印：水平スプリッターを下に移動します。

    Enter: If the primary pane is not collapsed, collapses the pane. If the pane is collapsed, restores the splitter to its previous position.
    Enter：プライマリーペインが折りたたまれていない場合は、ペインを折りたたむ。 ペインが折りたたまれている場合は、スプリッターを前の位置に戻します。

    Home (Optional): Moves splitter to the position that gives the primary pane its smallest allowed size. This may completely collapse the primary pane.
    Home（任意）：スプリッターを、プライマリーペインに許可される最小サイズを与える位置に移動します。 これにより、プライマリーペインが完全に折りたたまれる可能性があります。

    End (Optional): Moves splitter to the position that gives the primary pane its largest allowed size. This may completely collapse the secondary pane.
    End（任意）：スプリッターを、プライマリーペインに許可される最大サイズを与える位置に移動します。 これにより、セカンダリーペインが完全に折りたたまれる可能性があります。

    F6 (Optional): Cycle through window panes.
    F6（任意）：ウィンドウペインを循環していきます。

Note
注

A fixed size splitter omits implementation of the arrow keys.
固定サイズのスプリッターでは、矢印キーの実装が省略されています。 




WAI-ARIA Roles, States, and Properties
WAI-ARIA のロール、状態、およびプロパティ

    The element that serves as the focusable splitter has role separator.
    フォーカス可能なスプリッターとして機能する要素には、区切り（separator）ロールがあります。

    The separator element has the aria-valuenow property set to a decimal value representing the current position of the separator.
    区切り要素の aria-valuenow プロパティは、区切りの現在の位置を表す10進値に設定されています。

    The separator element has the aria-valuemin property set to a decimal value that represents the position where the primary pane has its minimum size. This is typically 0.
    区切り要素の aria-valuemin プロパティは、プライマリーペインの最小サイズの位置を表す10進値に設定されています。 通常、これは 0 です。

    The separator element has the aria-valuemax property set to a decimal value that represents the position where the primary pane has its maximum size. This is typically 100.
    区切り要素のaria-valuemaxプロパティは、プライマリーペインの最大サイズの位置を表す10進値に設定されています。 通常、これは 100 です。

    If the primary pane has a visible label, it is referenced by aria-labelledby on the separator element. Otherwise, the separator element has a label provided by aria-label.
    プライマリーペインに可視ラベルがある場合、区切り要素の aria-labelledby によって参照されます。 それ以外の場合、区切り要素には aria-label によって提供されるラベルがあります。

    The separator element has aria-controls referring to the primary pane.
    区切り要素には、プライマリーペインを参照する aria-controls があります。 






4. Landmark Regions
4. ランドマークリージョン

ARIA landmark roles provide a powerful way to identify the organization and structure of a web page. By classifying and labelling sections of a page, they enable structural information that is conveyed visually through layout to be represented programmatically. Screen readers exploit landmark roles to provide keyboard navigation to important sections of a page. Landmark regions can also be used as targets for "skip links" and by browser extensions to enhanced keyboard navigation.
ARIA のランドマークロール（landmark roles）は、ウェブページの構成と構造を識別するための強力な方法を提供します。 ページのセクションを分類してラベルを付けることにより、レイアウトを通じて視覚的に伝えられる構造情報をプログラムで表現できるようになります。 スクリーンリーダーは、ランドマークロールを利用して、ページの重要なセクションへのキーボードナビゲーションを提供します。 ランドマークリージョン（landmark regions）は、「スキップリンク」のターゲットとして、および強化されたキーボードナビゲーションのためにブラウザー拡張機能によっても使用できます。

This section explains how HTML sectioning elements and ARIA landmark roles are used to make it easy for assistive technology users to understand the meaning of the layout of a page.
このセクションでは、支援技術のユーザーがページのレイアウトの意味を簡単に理解できるようにするために、HTML セクショニング要素と ARIA ランドマークロールをどのように使用するかについて説明しま




4.1 HTML Sectioning Elements
4.1 HTML セクショニング要素

Several HTML sectioning elements automatically create ARIA landmark regions. So, in order to provide assistive technology users with a logical view of a page, it is important to understand the effects of using HTML sectioning elements. [HTML-ARIA] contains more information on HTML element role mapping.
いくつかの HTML セクショニング要素は、ARIA ランドマークリージョンを自動的に作成します。 したがって、支援技術のユーザーにページの論理ビューを提供するには、HTML セクショニング要素を使用した場合の影響を理解することが重要です。 [HTML-ARIA] には、HTML 要素のロールのマッピングに関する詳細情報が含まれています。

Default landmark roles for HTML sectioning elements HTML Element 	Default Landmark Role
HTML セクショニング要素のデフォルトのランドマークロール 	HTML 要素 	デフォルトのランドマークロール

余談（aside） 	補足（complementary）

footer 	contentinfo when in context of the body element
フッター（footer） 	ボディ要素のコンテキストでのコンテンツ情報（contentinfo）

header 	banner when in context of the body element
ヘッダー（header） 	ボディ要素のコンテキストでのバナー（banner）

メイン（main） 	メイン（main）

ナビゲーション（nav） 	ナビゲーション（navigation）

section 	region when it has an accessible name using aria-labelledby or aria-label
セクション（section） 	aria-labelledby または aria-label を使用してアクセス可能な名前があるリージョン（region）




4.2 General Principles of Landmark Design
4.2 ランドマークデザインの一般原則

Including all perceivable content on a page in one of its landmark regions and giving each landmark region a semantically meaningful role is one of the most effective ways of ensuring assistive technology users will not overlook information that is relevant to their needs.
あるページで認識可能なすべてのコンテンツをランドマークリージョンのどれかに含め、各ランドマークリージョンに意味論的に意味のあるロールを与えることは、支援技術のユーザーが自分のニーズに関連する情報を見落とさないようにするための最も効果的な方法の1つです。 





Step 1: Identify the logical structure
ステップ1：論理構造を特定する

    Break the page into perceivable areas of content which designers typically indicate visually using alignment and spacing.
    ページをコンテンツの認識可能なエリア（perceivable areas）に分割します。 これは通常、デザイナーが配置と間隔を使用して視覚的に示します。

    Areas can be further defined into logical sub-areas as needed.
    エリアは、必要に応じてさらに論理的なサブエリア（logical sub-areas）に定義できます。

    An example of a sub-area is a portlet in a portal application.
    サブエリアの例は、ポータルアプリケーションのポートレットです。 





Step 2: Assign landmark roles to each area
ステップ2：各エリアにランドマークロールを割り当てる

    Assign landmark roles based on the type of content in the area.
    エリア内のコンテンツのタイプに基づいてランドマークロールを割り当てます。

    banner, main, complementary and contentinfo landmarks should be top level landmarks.
    バナー（banner）、メイン（main）、補足（complementary）、および コンテンツ情報（contentinfo）のランドマークは、トップレベルのランドマークである必要があります。

    Landmark roles can be nested to identify parent/child relationships of the information being presented.
    ランドマークロールをネストして、提示されている情報の親子関係を識別することができます。 





Step 3: Label areas
ステップ3：エリアにラベルを付ける

    If a specific landmark role is used more than once on a page, provide each instance of that landmark with a unique label. There is one rare circumstance where providing the same label to multiple instances of a landmark can be beneficial: the content and purpose of each instance is identical. For example, a large search results table has two sets of identical pagination controls -- one above and one below the table, so each set is in a navigation region labelled "Search Results". In this case, adding extra information to the label that distinguishes the two instances may be more distracting than helpful.
    特定のランドマークロールがページで複数回使用されている場合は、そのランドマークの各インスタンスに一意のラベルを付けます。 ランドマークの複数のインスタンスに同じラベルを提供することが有益なまれな状況が1つあります。 それは、各インスタンスのコンテンツと目的が同じであるということです。 例えば、大きな検索結果テーブルには、テーブルの上と下に同じページ付けコントロールの2つのセットがあり、それぞれのセットは「検索結果」というラベルの付いたナビゲーションリージョンにあります。 この場合、2つのインスタンスを区別する追加情報をラベルに追加すると、役立つというよりも気が散る可能性があります。

    If a landmark is only used once on the page it may not require a label. See Landmark Roles section below.
    ランドマークがページ上で1回だけ使用される場合、ラベルは必要ない場合があります。 以下のランドマークロールのセクションを参照してください。

    If an area begins with a heading element (e.g. h1-h6) it can be used as the label for the area using the aria-labelledby attribute.
    エリアが見出し要素（h1-h6 など）で始まる場合、aria-labelledby 属性を使用してエリアのラベルとして使用できます。

    If an area requires a label and does not have a heading element, provide a label using the aria-label attribute.
    エリアにラベルが必要で、見出し要素がない場合は、aria-label 属性を使用してラベルを指定します。

    Do not use the landmark role as part of the label. For example, a navigation landmark with a label "Site Navigation" will be announced by a screen reader as "Site Navigation Navigation". The label should simply be "Site".
    ラベルの一部としてランドマークロールを使用しないでください。 例えば、「サイトナビゲーション」というラベルの付いたナビゲーションランドマークは、スクリーンリーダーによって「サイトナビゲーションナビゲーション」としてアナウンスされます。 ラベルは単に「サイト」である必要があります。





4.3 Landmark Roles
4.3 ランドマークロール




4.3.1 Banner
4.3.1 バナー

A banner landmark identifies site-oriented content at the beginning of each page within a website. Site-oriented content typically includes things such as the logo or identity of the site sponsor, and site-specific search tool. A banner usually appears at the top of the page and typically spans the full width.
バナーランドマーク（banner landmark）は、ウェブサイト内の各ページの先頭にあるサイト指向のコンテンツを識別します。 サイト指向のコンテンツには通常、サイトスポンサーのロゴや身元、サイト固有の検索ツールなどが含まれます。 バナーは通常、ページの上部に表示され、通常は全幅に広がります。

    Each page may have one banner landmark.
    各ページには、1つのバナーランドマークがあります。

    The banner landmark should be a top-level landmark.
    バナーランドマークはトップレベルのランドマークである必要があります。

    When a page contains nested document and/or application roles (e.g. typically through the use of iframe and frame elements), each document or application role may have one banner landmark.
    ページにネストされた文書（document）ロールやアプリケーション（application）ロールが含まれている場合（例えば、通常はインラインフレーム（iframe）要素およびフレーム（frame）要素の使用を介して）、文書ロールやアプリケーションロールのそれぞれに1つのバナーランドマークが含まれる場合があります。

    If a page includes more than one banner landmark, each should have a unique label (see Step 3 above).
    ページに複数のバナーランドマークが含まれている場合は、それぞれに一意のラベルを付ける必要があります（上記のステップ3を参照）。 





HTML Techniques
HTML の手法

    The HTML header element defines a banner landmark when its context is the body element.
    HTML ヘッダー（header）要素は、コンテキストがボディ要素である場合にバナーランドマークを定義します。

    The HTML header element is not considered a banner landmark when it is descendant of any of following elements (see HTML Accessibility Mappings [HTML-AAM]):
    HTML ヘッダー要素は、次の要素のいずれかの子孫である場合、バナーランドマークとは見なされません（HTML アクセシビリティマッピング [HTML-AAM] を参照）。 

        article
        記事（article）

        aside
        余談（aside）

        main
        メイン（main）

        nav
        ナビゲーション（nav）

        section
        セクション（section）





ARIA Techniques
ARIA の手法

If the HTML header element technique is not being used, a role="banner" attribute should be used to define a banner landmark.
HTML ヘッダー要素の手法を使用していない場合は、role="banner" 属性を使用してバナーランドマークを定義する必要があります。 




Examples
例

Banner Landmark Example
バナーランドマークの例 




4.3.2 Complementary
4.3.2 補足

A complementary landmark is a supporting section of the document, designed to be complementary to the main content at a similar level in the DOM hierarchy, but remains meaningful when separated from the main content.
補足ランドマーク（complementary landmark）は、文書のサポートセクションであり、DOM 階層の同様のレベルでメインコンテンツを補足するように設計されていますが、メインコンテンツから分離しても意味があります。

    complementary landmarks should be top level landmarks (e.g. not contained within any other landmarks).
    補足ランドマークは、トップレベルのランドマークである必要があります（例えば、他のランドマークに含まれていない）。

    If the complementary content is not related to the main content, a more general role should be assigned (e.g. region).
    補足コンテンツがメインコンテンツに関連していない場合は、より一般的なロールを割り当てる必要があります（region など）。

    If a page includes more than one complementary landmark, each should have a unique label (see Step 3 above).
    ページに複数の補足ランドマークが含まれている場合は、それぞれに一意のラベルを付ける必要があります（上記のステップ3を参照）。 





HTML Technique
HTML の手法

Use the HTML aside element to define a complementary landmark.
HTML 余談（aside）要素を使用して、補足ランドマークを定義します。



ARIA Technique
ARIA の手法

If the HTML aside element technique is not being used, use a role="complementary" attribute to define a complementary landmark.
HTML 余談要素の手法が使用されていない場合は、role="complementary" 属性を使用して補足ランドマークを定義します。



Examples
例

Complementary Landmark Example
補足ランドマークの例 




4.3.3 Contentinfo
4.3.3 コンテンツ情報

A contentinfo landmark is a way to identify common information at the bottom of each page within a website, typically called the "footer" of the page, including information such as copyrights and links to privacy and accessibility statements.
コンテンツ情報ランドマーク（contentinfo landmark）は、ウェブサイト内の各ページの下部にあって一般的な情報を識別する方法であり、通常はページの「フッター」と呼ばれ、著作権やプライバシーやアクセシビリティに関する声明へのリンクなどの情報が含まれます。

    Each page may have one contentinfo landmark.
    各ページには、コンテンツ情報ランドマークが1つある場合があります。

    The contentinfo landmark should be a top-level landmark.
    コンテンツ情報ランドマークはトップレベルのランドマークである必要があります。

    When a page contains nested document and/or application roles (e.g. typically through the use of iframe and frame elements), each document or application role may have one contentinfo landmark.
    ページにネストされた文書（document）ロールやアプリケーション（application）ロールが含まれている場合（例えば、通常はインラインフレーム（iframe）要素やフレーム（frame）要素の使用を介して）、文書ロールやアプリケーションロールのそれぞれには1つのコンテンツ情報ランドマークが含まれる場合があります。

    If a page includes more than one contentinfo landmark, each should have a unique label (see Step 3 above).
    ページに複数のコンテンツ情報ランドマークが含まれている場合は、それぞれに一意のラベルを付ける必要があります（上記のステップ3を参照）。 




HTML Techniques
HTML の手法

    The HTML footer element defines a contentinfo landmark when its context is the body element.
    HTML フッター（footer）要素は、コンテキストがボディ要素である場合にコンテンツ情報ランドマークを定義します。

    The HTML footer element is not considered a contentinfo landmark when it is descendant of any of following elements (see HTML Accessibility Mappings [HTML-AAM]):
    HTML フッター要素は、次の要素のいずれかの子孫である場合、コンテンツ情報ランドマークとは見なされません（HTML アクセシビリティマッピング [HTML-AAM] を参照）。 

        article
        記事（article）

        aside
        余談（aside）

        main
        メイン（main）

        nav
        ナビゲーション（nav）

        section
        セクション（section）




ARIA Technique
ARIA の手法

If the HTML footer element technique is not being used, a role="contentinfo" attribute should be used to define a contentinfo landmark.
HTML フッター要素の手法を使用していない場合は、role="contentinfo" 属性を使用してコンテンツ情報ランドマークを定義する必要があります。



Examples
例

Contentinfo Landmark Example
コンテンツ情報ランドマークの例 




4.3.4 Form
4.3.4 フォーム

A form landmark identifies a region that contains a collection of items and objects that, as a whole, combine to create a form when no other named landmark is appropriate (e.g. main or search).
フォームランドマーク（form landmark）は、他の名前付きランドマークが適切でない場合（メインや検索など）に全体として結合してフォームを作成する項目とオブジェクトのコレクションを含むリージョンを識別します。

    Use the search landmark instead of the form landmark when the form is used for search functionality.
    フォームを検索機能に使用する場合は、フォームランドマークの代わりに検索ランドマークを使用してください。

    A form landmark should have a label to help users understand the purpose of the form.
    フォームランドマークには、ユーザーがフォームの目的を理解しやすいようにラベルを付ける必要があります。

    A label for the form landmark should be visible to all users (e.g. an h1-h6 element).
    フォームランドマークのラベルは、すべてのユーザーに可視である必要があります（h1-h6 要素など）。

    If a page includes more than one form landmark, each should have a unique label (see Step 3 above).
    ページに複数のフォームランドマークが含まれている場合は、それぞれに一意のラベルを付ける必要があります（上記のステップ3を参照）。

    Whenever possible, controls contained in a form landmark in an HTML document should use native host semantics:
    可能な限り、HTML 文書のフォームランドマークに含まれるコントロールは、次のようなネイティブなホストの意味論を使用する必要があります。 

        button
        ボタン（button）

        input
        入力（input）

        select
        選択（select）

        textarea
        テキストエリア（textarea）





HTML Techniques
HTML の手法

The HTML form element defines a form landmark when it has an accessible name (e.g. aria-labelledby, aria-label or title).
HTML フォーム要素は、アクセス可能な名前（aria-labelledby、aria-label、title など）がある場合にフォームランドマークを定義します。



ARIA Technique
ARIA の手法

Use the role="form" to identify a region of the page; do not use it to identify every form field.
role="form" を使用して、ページのリージョンを識別します。 すべてのフォームフィールドを識別するために使用しないでください。 




Examples
例

Form Landmark Example
フォームランドマークの例




4.3.5 Main
4.3.5 メイン

A main landmark identifies the primary content of the page.
メインランドマーク（main landmark）は、ページの主要なコンテンツを識別します。

    Each page should have one main landmark.
    各ページには1つのメインランドマークが必要です。

    The main landmark should be a top-level landmark.
    メインランドマークはトップレベルのランドマークである必要があります。

    When a page contains nested document and/or application roles (e.g. typically through the use of iframe and frame elements), each document or application role may have one main landmark.
    ページにネストされた文書（document）ロールやアプリケーション（application）ロールが含まれている場合（例えば、通常はインラインフレーム（iframe）要素やフレーム（frame）要素の使用を介して）、文書ロールやアプリケーションロールのそれぞれには1つのメインランドマークがあります。

    If a page includes more than one main landmark, each should have a unique label (see Step 3 above).
    ページに複数のメインランドマークが含まれている場合は、それぞれに一意のラベルを付ける必要があります（上記のステップ3を参照）。 





HTML Technique
HTML の手法

Use the HTML main element to define a main landmark.
HTML メイン（main）要素を使用して、メインランドマークを定義します。



ARIA Technique
ARIA の手法

If the HTML main element technique is not being used, use a role="main" attribute to define a main landmark.
HTML メイン要素の手法を使用していない場合は、role="main" 属性を使用してメインランドマークを定義します。 




Examples
例

Main Landmark Example
メインランドマークの例




4.3.6 Navigation
4.3.6 ナビゲーション

Navigation landmarks provide a way to identify groups (e.g. lists) of links that are intended to be used for website or page content navigation.
ナビゲーションランドマーク（navigation landmark）は、ウェブサイトやページコンテンツのナビゲーションに使用することを目的としたリンクのグループ（リストなど）を識別する方法を提供します。

    If a page includes more than one navigation landmark, each should have a unique label (see Step 3 above).
    ページに複数のナビゲーションランドマークが含まれている場合は、それぞれに一意のラベルを付ける必要があります（上記のステップ3を参照）。

    If a navigation landmark has an identical set of links as another navigation landmark on the page, use the same label for each navigation landmark.
    ナビゲーションランドマークがページ上で別のナビゲーションランドマークと同じリンクのセットを持つ場合は、各ナビゲーションランドマークに同じラベルを使用します。 





HTML Technique
HTML の手法

Use the HTML nav element to define a navigation landmark.
HTML ナビゲーション（nav）要素を使用して、ナビゲーションランドマークを定義します。



ARIA Technique
ARIA の手法

If the HTML nav element technique is not being used, use a role="navigation" attribute to define a navigation landmark.
HTML ナビゲーション要素の手法を使用していない場合は、role="navigation" 属性を使用してナビゲーションランドマークを定義します。



Examples
例

Navigation Landmark Example
ナビゲーションランドマークの例




4.3.7 Region
4.3.7 リージョン

A region landmark is a perceivable section of the page containing content that is sufficiently important for users to be able to navigate to the section.
リージョンランドマーク（region landmark）は、ユーザーがそのセクションにナビゲートできるようにするために十分に重要なコンテンツを含む、ページの認識可能なセクションです。

    A region landmark must have a label.
    リージョンランドマークにはラベルが必要です。

    If a page includes more than one region landmark, each should have a unique label (see Step 3 above).
    ページに複数のリージョンランドマークが含まれている場合は、それぞれに一意のラベルを付ける必要があります（上記のステップ3を参照）。

    The region landmark can be used identify content that named landmarks do not appropriately describe.
    リージョンランドマークは、名前付きランドマークが適切に説明できないコンテンツを識別するために使用できます。 





HTML Technique
HTML の手法

The HTML section element defines a region landmark when it has an accessible name (e.g. aria-labelledby, aria-label or title).
HTML セクション（section）要素は、アクセス可能な名前（aria-labelledby、aria-label、title など）がある場合にリージョンランドマークを定義します。




ARIA Technique
ARIA の手法

If the HTML section element technique is not being used, use a role="region" attribute to define a region landmark.
HTML セクション要素の手法を使用していない場合は、role="region" 属性を使用してリージョンランドマークを定義します。



Examples
例

Region Landmark Example
リージョンランドマークの例




4.3.8 Search
4.3.8 検索

A search landmark contains a collection of items and objects that, as a whole, combine to create search functionality.
検索ランドマーク（search landmark）には、全体として組み合わせて検索機能を作成する、項目とオブジェクトのコレクションが含まれています。

    Use the search landmark instead of the form landmark when the form is used for search functionality.
    フォームを検索機能に使用する場合は、フォームランドマークの代わりに検索ランドマークを使用してください。

    If a page includes more than one search landmark, each should have a unique label (see Step 3 above).
    ページに複数の検索ランドマークが含まれている場合は、それぞれに一意のラベルを付ける必要があります（上記のステップ3を参照）。 





HTML Technique
HTML の手法

There is no HTML element that defines a search landmark.
検索ランドマークを定義する HTML 要素はありません。



ARIA Technique
ARIA の手法

The role="search" attribute defines a search landmark.
role="search" 属性は、検索ランドマークを定義します。



Examples
例

Search Landmark Example
検索ランドマークの例




5. Providing Accessible Names and Descriptions
5. アクセス可能な名前と説明を提供する

Providing elements with accessible names, and where appropriate, accessible descriptions is one of the most important responsibilities authors have when developing accessible web experiences. While doing so is straightforward for most elements, technical mistakes that can completely block users of assistive technologies are easy to make and unfortunately common. To help authors effectively provide accessible names and descriptions, this section explains their purpose, when authors need to provide them, how browsers assemble them, and rules for coding and composing them. It also guides authors in the use of the following naming and describing techniques and WAI-ARIA properties:
アクセス可能な名前と、必要に応じてアクセス可能な説明を要素に提供することは、アクセス可能なウェブエクスペリエンスを開発するときに作成者が負う最も重要な責任の1つです。 そうすることはほとんどの要素にとって簡単ですが、支援技術のユーザーを完全にブロックする可能性のある技術的な間違いは簡単に起こり、残念ながらよくあることです。 このセクションでは、作成者がアクセス可能な名前と説明を効果的に提供できるように、それらの目的、作成者がそれらを提供する必要がある場合、ブラウザーがそれらを組み立てる方法、およびそれらをコーディングおよび構成するためのルールについて説明します。 また、以下の命名と説明の手法および WAI-ARIA プロパティの使用について作成者をガイドします。

    Naming:
    命名：

        Naming with child content.
        子コンテンツによる命名。

        Naming with a string attribute via aria-label.
        aria-label を介した文字列属性による命名。

        Naming by referencing content with aria-labelledby.
        aria-labelledby でコンテンツを参照することによる命名。

        Naming form controls with the label element.
        ラベル（label）要素によるフォームコントロールの命名。

        Naming fieldsets with the legend element.
        凡例（legend）要素によるフィールドセット（fieldset）の命名。

        Naming tables and figures with captions.
        キャプションによるテーブルと図の命名。

        Fallback names derived from titles and placeholders.
        タイトルとプレースホルダーから導き出されたフォールバック名。

    Describing:
    説明：

        Describing by referencing content with aria-describedby.
        aria-describedby でコンテンツを参照することによる説明。

        Describing tables and figures with captions.
        キャプションによるテーブルと図の説明。

        Descriptions derived from titles.
        タイトルから導き出された説明。





5.1 What ARE Accessible Names and Descriptions?
5.1 アクセス可能な名前と説明とは何ですか？

An accessible name is a short string, typically 1 to 3 words, that authors associate with an element to provide users of assistive technologies with a label for the element. For example, an input field might have an accessible name of "User ID" or a button might be named "Submit".
アクセス可能な名前は、作成者が要素に関連付けて支援技術のユーザーに要素のラベルを提供する短い文字列（通常は1〜3語）です。 例えば、入力フィールドに「ユーザー ID」というアクセス可能な名前を付けたり、ボタンに「送信」という名前を付けたりすることができます。

An accessible name serves two primary purposes for users of assistive technologies, such as screen readers:
アクセス可能な名前は、スクリーンリーダーなどの支援技術のユーザーにとって2つの主要な目的を果たします。

    Convey the purpose or intent of the element.
    要素の目的または意図を伝えます。

    Distinguish the element from other elements on the page.
    その要素をページ上の他の要素と区別します。

Both the WAI-ARIA specification and WCAG require all focusable, interactive elements to have an accessible name. In addition dialogs and some structural containers, such as tables and regions, are required to have a name. Many other elements can be named, but whether a name will enhance the accessible experience is determined by various characteristics of the surrounding context. Finally, there are some elements where providing an accessible name is technically possible but not advisable. The Accessible Name Guidance by Role section lists naming requirements and guidelines for every ARIA role.
WAI-ARIA 仕様と WCAG はどちらも、すべてのフォーカス可能なインタラクティブな要素にアクセス可能な名前を付けることを要求しています。 さらに、ダイアログと、テーブルやリージョンなどの一部の構造コンテナーには、名前を付ける必要があります。 他の多くの要素に名前を付けることができますが、名前がアクセス可能なエクスペリエンスを向上させるかどうかは、周囲のコンテキストのさまざまな特性によって決まります。 最後に、アクセス可能な名前を提供することは技術的には可能でも、お勧めできない要素がいくつかあります。 ロール別のアクセス可能な名前ガイダンスのセクションには、すべての ARIA ロールの命名要件とガイドラインがリストされています。

An accessible description is also an author-provided string that is rendered by assistive technologies. Authors supply a description when there is a need to associate additional information with an element, such as instructions or format requirements for an input field.
アクセス可能な説明は、支援技術によってレンダリングされる作成者提供の文字列でもあります。 作成者は、入力フィールドの指示やフォーマット要件など、追加情報を要素に関連付ける必要がある場合に説明を提供します。

assistive technologies present names differently from descriptions. For instance, screen readers typically announce the name and role of an element first, e.g., a button named "Mute Conversation"could be spoken as "Mute Conversation button". If an element has a state, it could be announced either before or after the name and role; after name and role is the typical default. For example, a switch button named "Mute Conversation" in the "off" state could be announced as "Mute Conversation switch button off". Because descriptions are optional strings that are usually significantly longer than names, they are presented last, sometimes after a slight delay. For example, "Mute Conversation Switch button off, Silences alerts and notifications about activity in this conversation." To reduce verbosity, some screen readers do not announce descriptions by default but instead inform users of their presence so that users can press a key that will announce the description.
支援技術は、説明とは異なる名前を提示します。 例えば、スクリーンリーダーは通常、要素の名前とロールを最初にアナウンスします。 例えば、「会話のミュート」という名前のボタンは、「会話のミュートボタン」と読み上げることができます。 要素に状態がある場合、名前とロールの前または後にアナウンスできますが、名前とロールの後が一般的なデフォルトです。 例えば、「オフ」状態の「会話のミュート」という名前のスイッチボタンは、「会話のミュートスイッチボタンオフ」としてアナウンスできます。 説明はオプションの文字列であり、通常は名前よりもかなり長いため、最後に提示されますが、少し遅れて提示されることもあります。 例えば、「会話のミュートスイッチボタンオフ、この会話の活動に関するアラートと通知が無音になります。」などです。 冗長性を減らすために、一部のスクリーンリーダーはデフォルトで説明をアナウンスしませんが、代わりにユーザーにその存在を通知して、ユーザーが説明をアナウンスするキーを押すことができるようにします。




5.2 How Are Name and Description Strings Derived?
5.2 名前と説明の文字列はどのように導き出されますか？

Because there are several elements and attributes for specifying text to include in an accessible name or description string, and because authors can combine them in a practically endless number of ways, browsers implement fairly complex algorithms for assembling the strings. The sections on accessible name calculation and accessible description calculation explain the algorithms and how they implement precedence. However, most authors do not need such detailed understanding of the algorithms since nearly all circumstances where a name or description is useful are supported by the coding patterns described in the naming techniques and describing techniques sections.
アクセス可能な名前または説明の文字列に含めるテキストを指定するための要素と属性がいくつかあり、作成者はそれらを事実上無限の方法で組み合わせることができるため、ブラウザーは文字列を組み立てるためのかなり複雑なアルゴリズムを実装します。 アクセス可能な名前の計算とアクセス可能な説明の計算に関するセクションでは、アルゴリズムとそれらが優先順位を実装する方法について説明します。 ただし、名前または説明が役立つほとんどすべての状況は、命名手法および説明手法のセクションで説明されているコーディングパターンによってサポートされているため、ほとんどの作成者はアルゴリズムのそのような詳細な理解を必要としません。 




5.3 Accessible Names
5.3 アクセス可能な名前




5.3.1 Cardinal Rules of Naming
5.3.1 命名の基本的なルール




5.3.1.1 Rule 1: Heed Warnings and Test Thoroughly
5.3.1.1 ルール1：警告に留意し、徹底的にテストする

Several of the naming techniques below include notes that warn against specific coding patterns that are either prohibited by the ARIA specification or fall into gray space that is not yet fully specified. Some of these prohibited or ambiguous patterns may appear logical and even yield desired names in some browsers. However, it is unlikely they will provide consistent results across browsers, especially over time as work to improve the consistency of name calculation across browsers progresses.
以下の命名手法のいくつかには、ARIA 仕様で禁止されている、またはまだ完全に指定されていない灰色空間に分類される特定のコーディングパターンに対して警告する注記が含まれています。 これらの禁止またはあいまいなパターンの一部は、論理的に表示され、一部のブラウザーでは目的の名前を生成することさえあります。 ただし、ブラウザー間での名前計算の一貫性を向上させる作業が進むにつれて、特に時間の経過とともに変化し、ブラウザー間で一貫した結果が得られる可能性はほとんどありません。

In addition to heeding the warnings provided in the naming techniques, it is difficult to over emphasize the importance of testing to ensure that names browsers calculate match expectations.
命名手法で提供される警告に留意することに加えて、ブラウザーが計算する名前が期待値と一致することを確認するためのテストの重要性を強調しすぎることは困難です。 




5.3.1.2 Rule 2: Prefer Visible Text
5.3.1.2 ルール2：可視テキストを優先する

When a user interface includes visible text that could be used to provide an appropriate accessible name, using the visible text for the accessible name simplifies maintenance, prevents bugs, and reduces language translation requirements. When names are generated from text that exists only in markup and is never displayed visually, there is a greater likelihood that accessible names will not be updated when the user interface design or content are changed.
ユーザーインターフェイスに適切なアクセス可能な名前を提供するために使用できる可視テキストが含まれている場合、アクセス可能な名前に可視テキストを使用すると、メンテナンスが簡素化され、バグが防止され、言語翻訳の要件が軽減されます。 マークアップにのみ存在し、視覚的に表示されないテキストから名前が生成される場合、ユーザーインターフェイスのデザインやコンテンツが変更されたときに、アクセス可能な名前が更新されない可能性が高くなります。

If an interactive element, such as an input field or button, does not have a visually persistent text label, consider adjusting the design to include one. In addition to serving as a more robust source for an accessible name, visible text labels enhance accessibility for many people with disabilities who do not use assistive technologies that present invisible accessible names. In most circumstances, visible text labels also make the user interface easier to understand for all users.
入力フィールドやボタンなどのインタラクティブな要素に視覚的に永続的なテキストラベルがない場合は、デザインを調整してテキストラベルを含めることを検討してください。 可視のテキストラベルは、アクセス可能な名前のより堅牢なソースとして機能することに加えて、不可視のアクセス可能な名前を提示する支援技術を使用しない多くの障害者のアクセシビリティを強化します。 ほとんどの場合、可視のテキストラベルにより、すべてのユーザーがユーザーインターフェイスを理解しやすくなります。 




5.3.1.3 Rule 3: Prefer Native Techniques
5.3.1.3 ルール3：ネイティブな手法を優先する

In HTML documents, whenever possible, rely on HTML naming techniques, such as the HTML label element for form elements and caption element for tables. While less flexible, their simplicity and reliance on visible text help ensure robust accessible experiences. Several of the naming techniques highlight specific accessibility advantages of using HTML features instead of ARIA attributes.
HTML 文書では、可能な限り、HTML のフォーム要素のラベル要素やテーブルのキャプション要素などの HTML 命名手法に依存してください。 柔軟性は劣りますが、そのシンプルさと可視テキストへの依存は、堅牢でアクセス可能なエクスペリエンスを保証するのに役立ちます。 命名手法のいくつかは、ARIA 属性の代わりに HTML 機能を使用することの特定のアクセシビリティの利点を強調しています。 




5.3.1.4 Rule 4: Avoid Browser Fallback
5.3.1.4 ルール4：ブラウザーのフォールバックを回避する

When authors do not specify an accessible name using an element or attribute that is intended for naming, browsers attempt to help assistive technology users by resorting to fallback methods for generating a name. For example, the HTML title and placeholder attributes are used as last resort sources of content for accessible names. Because the purpose of these attributes is not naming, their content typically yields low quality accessible names that are not effective.
作成者が命名を目的とした要素または属性を使用してアクセス可能な名前を指定しない場合、ブラウザーは、名前を生成するためのフォールバック方法に頼ることによって、支援技術のユーザーを支援しようとします。 例えば、HTML のタイトル（title）属性とプレースホルダー（placeholder）属性は、アクセス可能な名前のコンテンツの最後の手段として使用されます。 これらの属性の目的は命名ではないため、それらのコンテンツは通常、効果的ではない低品質のアクセス可能な名前を生成します。 




5.3.1.5 Rule 5: Compose Brief, Useful Names
5.3.1.5 ルール5：簡潔で有用な名前を作成する

Similar to how visually crowded screens and ambiguous icons reduce usability, excessively long, insufficiently distinct, or unclear accessible names can make a user interface very difficult, or even impossible, to use for someone who relies on a non-visual form of the user interface. In other words, for a web experience to be accessible, its accessible names must be effective. The section on Composing Effective and User-friendly Accessible Names provides guidance for balancing brevity and clarity.
視覚的に混雑した画面とあいまいなアイコンが使いやすさを低下させるのと同様に、過度に長い、十分に区別できない、または不明瞭なアクセス可能な名前は、非視覚的な形式のユーザーインターフェイスに依存するユーザーにとってユーザーインターフェイスの使用を非常に困難または不可能にする可能性があります。 言い換えれば、ウェブエクスペリエンスにアクセスできるようにするには、そのアクセス可能な名前が効果的である必要があります。 効果的でユーザーフレンドリーなアクセス可能な名前の構成に関するセクションでは、簡潔さと明確さのバランスを取るためのガイダンスを提供します。 




5.3.2 Naming Techniques
5.3.2 命名手法



5.3.2.1 Naming with Child Content
5.3.2.1 子コンテンツによる命名

Certain elements get their name from the content they contain. For example, the following link is named "Home".
特定の要素は、それらに含まれるコンテンツから名前を取得します。 例えば、次のリンクの名前は「ホーム」です。 

<a href="/">Home</a>
<a href="/">ホーム</a>

When assistive technologies render an element that gets its accessible name from its content, such as a link or button, the accessible name is the only content the user can perceive for that element. This is in contrast to other elements, such as text fields or tables, where the accessible name is a label that is presented in addition to the value or content of the element. For instance, the accessible name of a table can be derived from a caption element, and assistive technologies render both the caption and all other content contained inside the table.
支援技術が、リンクやボタンなど、コンテンツからアクセス可能な名前を取得する要素をレンダリングする場合、アクセス可能な名前は、ユーザーがその要素に対して認識できる唯一のコンテンツです。 これは、アクセス可能な名前が要素の値またはコンテンツに加えて提示されるラベルであるテキストフィールドやテーブルなどの他の要素とは対照的です。 例えば、テーブルのアクセス可能な名前はキャプション要素から導き出すことができ、支援技術はキャプションとテーブル内に含まれる他のすべてのコンテンツの両方をレンダリングします。

Elements having one of the following roles are, by default, named by a string calculated from their descendant content:
次のいずれかのロールを持つ要素には、デフォルトで、子孫のコンテンツから計算された文字列によって名前が付けられます。 

    button
    ボタン（button）

    cell
    セル（cell）

    checkbox
    チェックボックス（checkbox）

    columnheader
    列ヘッダー（columnheader）

    gridcell
    グリッドセル（gridcell）

    heading
    見出し（heading）

    link
    リンク（link）

    menuitem (content contained in a child menu element is excluded.)
    メニュー項目（menuitem。 子メニュー要素に含まれるコンテンツは除外されます。）

    menuitemcheckbox
    メニュー項目チェックボックス（menuitemcheckbox）

    menuitemradio
    メニュー項目ラジオボタン（menuitemradio）

    option
    オプション（option）

    radio
    ラジオボタン（radio）

    row
    行（row）

    rowheader
    行ヘッダー（rowheader）

    switch
    スイッチ（switch）

    tab
    タブ（tab）

    tooltip
    ツールチップ（tooltip）

    treeitem (content included in a child group element is excluded.)
    ツリー項目（treeitem。 子グループ要素に含まれるコンテンツは除外されます。） 

When calculating a name from content for an element, user agents recursively walk through each of its descendant elements, calculate a name string for each descendant, and concatenate the resulting strings. In two special cases, certain descendants are ignored: group descendants of treeitem elements and menu descendants of menuitem elements are omitted from the calculation. For example, in the following tree, the name of the first tree item is "Fruits"; "Apples", "Bananas", and "Oranges" are omitted.
要素のコンテンツから名前を計算する場合、ユーザーエージェントはその子孫要素のそれぞれを再帰的にたどり、各子孫の名前文字列を計算し、結果の文字列を連結します。 2つの特殊なケースでは、特定の子孫が無視されます。 ツリー項目要素のグループ子孫とメニュー項目要素のメニュー子孫は計算から省略されます。 例えば、次のツリーでは、最初のツリー項目の名前は「フルーツ」です。 「りんご」「バナナ」「オレンジ」は省略しています。

<ul role="tree">

  <li role="treeitem">Fruits
  <li role="treeitem">フルーツ

    <ul role="group">

      <li role="treeitem">Apples</li>
      <li role="treeitem">りんご</li>

      <li role="treeitem">Bananas</li>
      <li role="treeitem">バナナ</li>

      <li role="treeitem">Oranges</li>
      <li role="treeitem">オレンジ</li>

    </ul>

  </li>

</ul>

Warning
警告

If an element with one of the above roles that supports naming from child content is named by using aria-label or aria-labelledby, content contained in the element and its descendants is hidden from assistive technology users unless the descendant content is referenced by aria-labelledby. It is strongly recommended to avoid using either of these attributes to override content of one of the above elements except in rare circumstances where hiding content from assistive technology users is beneficial. In addition, in situations where visible content is hidden from assistive technology users by use of one of these attributes, thorough testing with assistive technologies is particularly important.
子コンテンツからの命名をサポートする上記のロールのいずれかを持つ要素が aria-label または aria-labelledby を使用して命名された場合、その要素に含まれるコンテンツとその子孫は、子孫コンテンツが aria-labelledby によって参照されない限り、支援技術ユーザーから隠されます。 支援技術のユーザーからコンテンツを非表示にすることが有益であるまれな状況を除いて、上記の要素のいずれかのコンテンツをオーバーライドするためにこれらの属性のいずれかを使用しないことを強くお勧めします。 さらに、これらの属性の1つを使用して、可視コンテンツが支援技術のユーザーから隠されている状況では、支援技術を使用した徹底的なテストが特に重要です。 




5.3.2.2 Naming with a String Attribute Via aria-label
5.3.2.2 aria-label を介した文字列属性による命名

The aria-label property enables authors to name an element with a string that is not visually rendered. For example, the name of the following button is "Close".
aria-label プロパティを使用すると、作成者は視覚的にレンダリングされない文字列で要素に名前を付けることができます。 例えば、次のボタンの名前は「閉じる」です。 

<button type="button" aria-label="Close">X</button>
<button type="button" aria-label="閉じる">X</button>

The aria-label property is useful when there is no visible text content that will serve as an appropriate accessible name.
aria-label プロパティは、適切なアクセス可能な名前として機能する可視テキストコンテンツがない場合に役立ちます。

The aria-label property affects assistive technology users in one of two different ways, depending on the role of the element to which it is applied. When applied to an element with one of the roles that supports naming from child content, aria-label hides descendant content from assistive technology users and replaces it with the value of aria-label. However, when applied to nearly any other type of element, assistive technologies will render both the value of aria-label and the content of the element. For example, the name of the following navigation region is "Product".
aria-label プロパティは、適用される要素のロールに応じて、2つの異なる方法のいずれかで支援技術ユーザーに影響を与えます。 子コンテンツからの命名をサポートするロールの1つを持つ要素に適用されると、aria-label は、支援技術ユーザーから子孫コンテンツを非表示にし、それを aria-label の値に置き換えます。 ただし、他のほぼすべてのタイプの要素に適用すると、支援技術は aria-label の値と要素のコンテンツの両方をレンダリングします。 例えば、次のナビゲーションリージョンの名前は「製品」です。 

<nav aria-label="Product">
<nav aria-label="製品">

  <!-- list of navigation links to product pages -->
  <!-- 製品ページへのナビゲーションリンクのリスト -->

</nav>

When encountering this navigation region, a screen reader user will hear the name and role of the element, e.g., "Product navigation region", and then be able to read through the links contained in the region.
このナビゲーションリージョンに遭遇すると、スクリーンリーダーのユーザーは、要素の名前とロール（「製品ナビゲーションリージョン」など）を聞き、そのリージョンに含まれるリンクを読み進めることができます。

Warning
警告

    If aria-label is applied to an element with one of the roles that supports naming from child content, content contained in the element and its descendants is hidden from assistive technology users. It is strongly recommended to avoid using aria-label to override content of one of these elements except in rare circumstances where hiding content from assistive technology users is beneficial.
    子コンテンツからの命名をサポートするロールの1つを持つ要素に aria-label が適用される場合、要素とその子孫に含まれるコンテンツは、支援技術のユーザーから隠されます。 支援技術のユーザーからコンテンツを隠すことが有益であるまれな状況を除いて、これらの要素の1つのコンテンツをオーバーライドするために aria-label を使用することは避けることを強くお勧めします。

    There are certain types of elements, such as paragraphs and list items, that should not be named with aria-label. They are identified in the table in the Accessible Name Guidance by Role section.
    段落やリスト項目など、aria-label で名前を付けてはならない特定の種類の要素があります。 これらは、ロール別のアクセス可能な名前のガイダンスのセクションの表で識別されます。

    Because the value of aria-label is not rendered visually, testing with assistive technologies to ensure the expected name is presented to users is particularly important.
    aria-label の値は視覚的にレンダリングされないため、期待される名前がユーザーに提示されることを確認するための支援技術を使用したテストは特に重要です。

    When a user interface is translated into multiple languages, ensure that aria-label values are translated.
    ユーザーインターフェイスを複数の言語に翻訳する場合は、aria-label 値が翻訳されていることを確認してください。





5.3.2.3 Naming with Referenced Content Via aria-labelledby
5.3.2.3 aria-labelledby を介した参照コンテンツによる命名

The aria-labelledby property enables authors to reference other elements on the page to define an accessible name. For example, the following switch is named by the text content of a previous sibling element.
aria-labelledby プロパティを使用すると、作成者はページ上の他の要素を参照して、アクセス可能な名前を定義できます。 例えば、次のスイッチは、前の兄弟要素のテキストコンテンツによって名前が付けられています。 

<span id="night-mode-label">Night mode</span>
<span role="switch" aria-checked="false" tabindex="0" aria-labelledby="night-mode-label"></span>

Note that while using aria-labelledby is similar in this situation to using an HTML label element with the for attribute, one significant difference is that browsers do not automatically make clicking on the labeling element activate the labeled element; that is an author responsibility. However, HTML label cannot be used to label a span element. Fortunately, an HTML input with type="checkbox" allows the ARIA switch role, so when feasible, using the following approach creates a more robust solution.
この状況での aria-labelledby の使用は、for 属性を持つ HTML ラベル要素の使用と似ていますが、1つの重要な違いは、ブラウザーがラベル要素をクリックしてもラベル付けされた要素が自動的にアクティブ化されないことです。 それは作成者の責任です。 ただし、HTML ラベルを使用してスパン要素にラベルを付けることはできません。 幸い、type="checkbox" を使用した HTML 入力では、ARIA スイッチロールが許可されるため、可能であれば、次のアプローチを使用すると、より堅牢なソリューションを作成できます。

<label for="night-mode">Night mode</label>
<input type="checkbox" role="switch" id="night-mode">

The aria-labelledby property is useful in a wide variety of situations because:
aria-labelledby プロパティは、次の理由でさまざまな状況で役立ちます。

    It has the highest precedence when browsers calculate accessible names, i.e., it overrides names from child content and all other naming attributes, including aria-label.
    ブラウザーがアクセス可能な名前を計算するときに最も優先されます。 つまり、子コンテンツおよび aria-label を含む他のすべての命名属性からの名前を上書きします。

    It can concatenate content from multiple elements into a single name string.
    複数の要素のコンテンツを1つの名前文字列に連結できます。

    It incorporates content from elements regardless of their visibility, i.e., it even includes content from elements with the HTML hidden attribute, CSS display: none, or CSS visibility: hidden in the calculated name string.
    可視性に関係なく要素のコンテンツを組み込みます。 つまり、計算された名前文字列に HTML hidden 属性、CSS display: none、または CSS visibility: hidden を持つ要素のコンテンツも含まれます。

    It incorporates the value of input elements, i.e., if it references a textbox, the value of the textbox is included in the calculated name string.
    入力要素の値が組み込まれます。 つまり、テキストボックスを参照している場合、テキストボックスの値は計算された名前の文字列に含まれます。

An example of referencing a hidden element with aria-labelledby could be a label for a night switch control:
aria-labelledby で非表示の要素を参照する例は、次のナイトスイッチコントロールのラベルです。 

<span id="night-mode-label" hidden>Night mode</span>
<input type="checkbox" role="switch" aria-labelledby="night-mode-label">

In some cases, the most effective name for an element is its own content combined with the content of another element. Because aria-labelledby has highest precedence in name calculation, in those situations, it is possible to use aria-labelledby to reference both the element itself and the other element. In the following example, the "Read more..." link is named by the element itself and the article’s heading, resulting in a name for the link of "Read more... 7 ways you can help save the bees".
場合によっては、要素の最も効果的な名前は、別の要素のコンテンツと組み合わせた独自のコンテンツです。 aria-labelledby は名前の計算で最も優先されるため、そのような状況では、aria-labelledby を使用して要素自体と他の要素の両方を参照することができます。 次の例では、「続きを読む...」リンクは要素自体と記事の見出しによって名前が付けられ、「続きを読む...ミツバチを救うのに役立つ7つの方法」がリンクの名前になります。

<h2 id="bees-heading">7 ways you can help save the bees</h2>
<h2 id="bees-heading">ミツバチを救うのに役立つ7つの方法</h2>

<p>Bees are disappearing rapidly. Here are seven things you can do to help.</p>
<p>ミツバチは急速に姿を消しています。 ここにあなたが助けるためにできる7つのことがあります。</p>

<p><a id="bees-read-more" aria-labelledby="bees-read-more bees-heading">Read more...</a></p>
<p><a id="bees-read-more" aria-labelledby="bees-read-more bees-heading">続きを読む...</a></p>

When multiple elements are referenced by aria-labelledby, text content from each referenced element is concatenated in the order specified in the aria-labelledby value. If an element is referenced more than one time, only the first reference is processed. When concatenating content from multiple elements, browsers trim leading and trailing white space and separate content from each element with a single space.
複数の要素が aria-labelledby によって参照されている場合、参照されている各要素のテキストコンテンツは、aria-labelledby 値で指定された順に連結されます。 要素が複数回参照される場合、最初の参照のみが処理されます。 複数の要素のコンテンツを連結する場合、ブラウザーは先頭と末尾のスペースを削除し、各要素のコンテンツを1つのスペースで区切ります。

<button id="download-button" aria-labelledby="download-button download-details">Download</button>

<span id="download-details">PDF, 2.4 MB</span>

In the above example, the accessible name of the button will be "Download PDF, 2.4 MB", with a space between "Download" and "PDF", and not "DownloadPDF, 2.4 MB".
上記の例では、ボタンのアクセス可能な名前は「DownloadPDF、2.4 MB」ではなく、「Download PDF、2.4 MB」であり、「Download」と「PDF」の間にスペースがあります。

Warning
警告

    The aria-labelledby property cannot be chained, i.e., if an element with aria-labelledby references another element that also has aria-labelledby, the aria-labelledby attribute on the referenced element will be ignored.
    1. aria-labelledby プロパティを連鎖させることはできません。 つまり、aria-labelledby を持つ要素が、aria-labelledby を持つ別の要素を参照する場合、参照される要素の aria-labelledby 属性は無視されます。

    If an element is referenced by aria-labelledby more than one time during a name calculation, the second and any subsequent references will be ignored.
    2. 名前の計算中に要素が aria-labelledby によって複数回参照された場合、2番目以降の参照は無視されます。

    There are certain types of elements, such as paragraphs and list items, that should not be named with aria-labelledby. They are identified in the table in the Accessible Name Guidance by Role section.
    3. 段落やリスト項目など、aria-labelledby で名前を付けてはならない特定の種類の要素があります。 これらは、ロール別のアクセス可能な名前のガイダンスのセクションの表で識別されます。

    If aria-labelledby is applied to an element with one of the roles that supports naming from child content, content contained in the element and its descendants is hidden from assistive technology users unless it is also referenced by aria-labelledby. It is strongly recommended to avoid using this attribute to override content of one of these elements except in rare circumstances where hiding content from assistive technology users is beneficial.
    4. 子コンテンツからの命名をサポートするロールの1つを持つ要素に aria-labelledby が適用される場合、その要素とその子孫に含まれるコンテンツは、aria-labelledby によっても参照されない限り、支援技術ユーザーから隠されます。 支援技術のユーザーからコンテンツを隠すことが有益であるまれな状況を除いて、これらの要素の1つのコンテンツをオーバーライドするためにこの属性を使用することは避けることを強くお勧めします。

    Because calculating the name of an element with aria-labelledby can be complex and reference hidden content, testing with assistive technologies to ensure the expected name is presented to users is particularly important.
    5. aria-labelledby を使用して要素の名前を計算することは複雑で、非表示のコンテンツを参照する可能性があるため、期待される名前がユーザーに提示されることを確認するための支援技術を使用したテストは特に重要です。





5.3.2.4 Naming Form Controls with the Label Element
5.3.2.4 ラベル要素によるフォームコントロールの命名

The HTML label element enables authors to identify content that serves as a label and associate it with a form control. When a label element is associated with a form control, browsers calculate an accessible name for the form control from the label content.
HTML ラベル要素を使用すると、作成者はラベルとして機能するコンテンツを識別し、それをフォームコントロールに関連付けることができます。 ラベル要素がフォームコントロールに関連付けられている場合、ブラウザーはラベルコンテンツからフォームコントロールのアクセス可能な名前を計算します。

For example, text displayed adjacent to a checkbox may be visually associated with the checkbox, so it is understood as the checkbox label by users who can perceive that visual association. However, unless the text is programmatically associated with the checkbox, assistive technology users will experience a checkbox without a label. Wrapping the checkbox and the labeling text in a label element as follows gives the checkbox an accessible name.
例えば、チェックボックスの横に表示されるテキストは、チェックボックスに視覚的に関連付けられている場合があるため、その視覚的な関連付けを認識できるユーザーには、チェックボックスのラベルとして理解されます。 ただし、テキストがプログラムでチェックボックスに関連付けられていない限り、支援技術のユーザーはラベルのないチェックボックスを体験することになります。 チェックボックスとラベル付けテキストを次のようにラベル要素でラップすると、チェックボックスにアクセス可能な名前が付けられます。 

<label>

  <input type="checkbox" name="subscribe">

  subscribe to our newsletter
  ニュースレターを購読する

</label>

A form control can also be associated with a label by using the for attribute on the label element. This allows the label and the form control to be siblings or have different parents in the DOM, but requires adding an id attribute to the form control, which can be error-prone. When possible, use the above encapsulation technique for association instead of the following for attribute technique.
フォームコントロールは、ラベル要素の for 属性を使用してラベルに関連付けることもできます。 これにより、ラベルとフォームコントロールを兄弟にすることも、DOM 内で異なる親を持つこともできますが、フォームコントロールに id 属性を追加する必要があり、エラーが発生しやすくなります。 可能であれば、属性手法の次の代わりに、上記のカプセル化手法を関連付けに使用します。

<input type="checkbox" name="subscribe" id="subscribe_checkbox">

<label for="subscribe_checkbox">subscribe to our newsletter</label>
<label for="subscribe_checkbox">ニュースレターを購読する</label>

Using the label element is an effective technique for satisfying Rule 2: Prefer Visible Text. It also satisfies Rule 3: Prefer Native Techniques. Native HTML labels offer an important usability and accessibility advantage over ARIA labeling techniques: browsers automatically make clicking the label equivalent to clicking the form control. This increases the hit area of the form control.
ラベル要素の使用は、ルール2：可視テキストを優先するを満たすための効果的な手法です。 また、ルール3：ネイティブな手法を優先するを満たしています。 ネイティブな HTML ラベルは、ARIA ラベル付け手法に比べて、使いやすさとアクセシビリティの重要な利点を提供します。 ブラウザーは、フォームコントロールのクリックとラベルのクリックを自動的に同等にします。 これにより、フォームコントロールのヒットエリアが増加します。




5.3.2.5 Naming Fieldsets with the Legend Element
5.3.2.5 凡例要素によるフィールドセットの命名

The HTML fieldset element can be used to group form controls, and the legend element can be used to give the group a name. For example, a group of radio buttons can be grouped together in a fieldset, where the legend element labels the group for the radio buttons.
HTML フィールドセット（fieldset）要素を使用してフォームコントロールをグループ化し、凡例（legend）要素を使用してグループに名前を付けることができます。 例えば、ラジオボタンのグループをフィールドセットにグループ化できます。 この場合、凡例要素はラジオボタンのグループにラベルを付けます。 

<fieldset>

  <legend>Select your starter class</legend>
  <legend>スタータークラスを選択します</legend>

  <label><input type="radio" name="starter-class" value="green"> Green</label>
  <label><input type="radio" name="starter-class" value="green"> 緑</label>

  <label><input type="radio" name="starter-class" value="red"> Red</label>
  <label><input type="radio" name="starter-class" value="red"> 赤</label>

  <label><input type="radio" name="starter-class" value="blue"> Blue</label>
  <label><input type="radio" name="starter-class" value="blue"> 青</label>

</fieldset>

This grouping technique is particularly useful for presenting multiple choice questions. It enables authors to associate a question with a group of answers. If a question is not programmatically associated with its answer options, assistive technology users may access the answers without being aware of the question.
このグループ化手法は、多肢選択問題を提示する場合に特に役立ちます。 これにより、作成者は質問を回答のグループに関連付けることができます。 質問がプログラムで回答オプションに関連付けられていない場合、支援技術のユーザーは質問に気付かずに回答にアクセスすることがあります。

Similar benefits can be gained from grouping and naming other types of related form fields using fieldset and legend.
フィールドセットと凡例を使用して、他のタイプの関連するフォームフィールドをグループ化し、命名することで、同様の利点を得ることができます。 

<fieldset>

  <legend>Shipping address</legend>
  <legend>お届け先の住所</legend>

  <p><label>Full name <input name="name" required></label></p>
  <p><label>氏名 <input name="name" required></label></p>

  <p><label>Address line 1 <input name="address-1" required></label></p>
  <p><label>住所欄 1 <input name="address-1" required></label></p>

  <p><label>Address line 2 <input name="address-2"></label></p>
  <p><label>住所欄 2 <input name="address-2"></label></p>

  ...

</fieldset>

<fieldset>

  <legend>Billing address</legend>
  <legend>請求先住所</legend>

  ...

</fieldset>

Using the legend element to name a fieldset element satisfies Rule 2: Prefer Visible Text and Rule 3: Prefer Native Techniques.
凡例要素を使用してフィールドセット要素に名前を付けると、ルール2：可視テキストを優先するおよびルール3：ネイティブな手法を優先するが満たされます。





5.3.2.6 Naming Tables and Figures with Captions
5.3.2.6 キャプションによるテーブルと図の命名

The accessible name for HTML table and figure elements can be derived from a child caption or figcaption element, respectively. Tables and figures often have a caption to explain what they are about, how to read them, and sometimes giving them numbers used to refer to them in surrounding prose. Captions can help all users better understand content, but are especially helpful to users of assistive technologies.
HTML テーブル（table、表）要素と図（figure）要素のアクセス可能な名前は、それぞれ子キャプション（caption）要素または子図キャプション（figcaption）要素から導き出すことができます。 テーブルや図には、その内容や読み方を説明するキャプションが付いていることが多く、周囲の散文でそれらを参照するために使用される番号が付けられていることもあります。 キャプションは、すべてのユーザーがコンテンツをよりよく理解するのに役立ちますが、支援技術のユーザーには特に役立ちます。

In HTML, the table element marks up a data table, and can be provided with a caption using the caption element. If the table element does not have aria-label or aria-labelledby, then the caption will be used as the accessible name. For example, the accessible name of the following table is "Special opening hours".
HTML では、テーブル要素はデータテーブルをマークアップし、キャプション要素を使用してキャプションを提供できます。 テーブル要素に aria-label または aria-labelledby がない場合、キャプションがアクセス可能な名前として使用されます。 例えば、次のテーブルのアクセス可能な名前は「特別営業時間」です。 

<table>

 <caption>Special opening hours</caption>
 <caption>特別営業時間</caption>

 <tr><td>30 May <td>Closed
 <tr><td>5月30日 <td>定休日

 <tr><td>6 June <td>11:00-16:00
 <tr><td>6月6日 <td>11:00-16:00

</table>

The following example gives the table a number ("Table 1") so it can be referenced.
次の例では、参照できるようにテーブルに番号（「表1」）を付けています。

<table>

 <caption>Table 1. Traditional dietary intake of Okinawans and other Japanese circa 1950</caption>
 <caption>表1. 1950年頃の沖縄県民およびその他の日本人の伝統的な食事摂取量</caption>

 <thead>

  <tr>

   <th>

   <th>Okinawa, 1949
   <th>沖縄、1949年

   <th>Japan, 1950
   <th>日本、1950年

 <tbody>

  <tr>

   <th>Total calories
   <th>総カロリー

   <td>1785

   <td>2068

  [...]

</table>

Note: Above table content is from Caloric restriction, the traditional Okinawan diet, and healthy aging: the diet of the world's longest-lived people and its potential impact on morbidity and life span.
注：上記の表の内容は、カロリー制限、伝統的な沖縄の食事、健康的な老化、つまり世界で最も長生きする人々の食事と、罹患率と寿命への潜在的な影響（英語）からのものです。

If a table is named using aria-label or aria-labelledby, then a caption element, if present, will become an accessible description. For an example, see Describing Tables and Figures with Captions.
テーブルに aria-label または aria-labelledby を使用して名前が付けられている場合、キャプション要素が存在する場合は、アクセス可能な説明になります。 例については、キャプションによるテーブルと図の説明を参照してください。

Similarly, an HTML figure element can be given a caption using the figcaption element. The caption can appear before or after the figure, but it is more common for figures to have the caption after.
同様に、HTML 図要素には、図キャプション要素を使用してキャプションを付けることができます。 キャプションは図の前または後に表示できますが、図の後にキャプションを付けるのが一般的です。 

<figure>

 <img alt="Painting of a person walking in a desert." src="Hole_JesusalDesierto.jpg">
 <img alt="砂漠を歩く人の絵。" src="Hole_JesusalDesierto.jpg">

 <figcaption>Jesus entering the desert as imagined by William Hole, 1908</figcaption>
 <figcaption>ウィリアム・ホールが想像した、イエスの砂漠への入場、1908年</figcaption>

</figure>

Like with table elements, if a figure is not named using aria-label or aria-labelledby, the content of the figcaption element will be used as the accessible name. However unlike table elements, if the figcaption element is not used for the name, it does not become an accessible description unless it is referenced by aria-describedby. Nevertheless, assistive technologies will render the content of a figcaption regardless of whether it is used as a name, description, or neither.
テーブル要素と同様に、図に aria-label または aria-labelledby を使用して名前が付けられていない場合、図キャプション要素のコンテンツがアクセス可能な名前として使用されます。 ただし、テーブル要素とは異なり、図キャプション要素が名前のために使用されていない場合、aria-describedby によって参照されない限り、アクセス可能な説明にはなりません。 それでも、支援技術は、名前、説明、またはどちらとして使用されているかに関係なく、図キャプションのコンテンツをレンダリングします。

Using the caption element to name a table element, or a figcaption element to name a figure element, satisfies Rule 2: Prefer Visible Text and Rule 3: Prefer Native Techniques.
キャプション要素を使用してテーブル要素に名前を付けるか、図キャプション要素を使用して図要素に名前を付けると、ルール2：可視テキストを優先するおよびルール3：ネイティブな手法を優先するが満たされます。




5.3.2.7 Fallback Names Derived from Titles and Placeholders
5.3.2.7 タイトルとプレースホルダーから導き出されたフォールバック名

When an accessible name is not provided using one of the primary techniques (e.g., the aria-label or aria-labelledby attributes), or native markup techniques (e.g., the HTML label element, or the alt attribute of the HTML img element), browsers calculate an accessible name from other attributes as a fallback mechanism. Because the attributes used in fallback name calculation are not intended for naming, they typically yield low quality accessible names that are not effective. So, As advised by Rule 4: Avoid Browser Fallback, prefer the explicit labeling techniques described above over fallback techniques described in this section.
主要な手法（例：aria-label 属性または aria-labelledby 属性）またはネイティブなマークアップ手法（例：HTML ラベル要素または HTML 画像要素の alt 属性）のいずれかを使用してアクセス可能な名前が提供されていない場合、ブラウザーは、フォールバックメカニズムとして他の属性からアクセス可能な名前を計算します。 フォールバック名の計算で使用される属性は命名を目的としていないため、通常、効果的でない低品質のアクセス可能な名前が生成されます。 したがって、ルール4：ブラウザーのフォールバックを回避するでアドバイスされているように、このセクションで説明するフォールバック手法よりも、上記の明示的なラベル付け手法を優先してください。

Any HTML element can have a title attribute specified. The title attribute may be used as the element's fallback accessible name. The title attribute is commonly presented visually as a tooltip when the user hovers over the element with a pointing device, which is not particularly discoverable, and is also not accessible to visual users without a pointing device.
すべての HTML 要素にタイトル（title）属性を指定できます。 タイトル属性は、要素のフォールバックアクセス可能な名前として使用できます。 タイトル属性は通常、ユーザーがポインティングデバイスを使用して要素にカーソルを合わせると、ツールチップとして視覚的に提示されます。 これは特に発見可能なものではなく、ポインティングデバイスがないと視覚的なユーザーもアクセスできません。

For example, a fieldset element without a legend element child, but with a title attribute, gets its accessible name from the title attribute.
例えば、凡例要素の子がなく、タイトル属性を持つフィールドセット要素は、タイトル属性からアクセス可能な名前を取得します。

<fieldset title="Select your starter class">
<fieldset title="スタータークラスを選択します">

  <label><input type="radio" name="starter-class" value="green"> Green</label>
  <label><input type="radio" name="starter-class" value="green"> 緑</label>

  <label><input type="radio" name="starter-class" value="red"> Red</label>
  <label><input type="radio" name="starter-class" value="red"> 赤</label>

  <label><input type="radio" name="starter-class" value="blue"> Blue</label>
  <label><input type="radio" name="starter-class" value="blue"> 青</label>

</fieldset>

For the HTML input and textarea elements, the placeholder attribute is used as a fallback labeling mechanism if nothing else (including the title attribute) results in a label. It is better to use a label element, since it does not disappear visually when the user focuses the form control.
HTML の入力要素とテキストエリア要素の場合、他に何も（タイトル属性を含めて）ラベルがない場合、プレースホルダー（placeholder）属性がフォールバックラベル付けメカニズムとして使用されます。 ユーザーがフォームコントロールにフォーカスしたときに視覚的に消えてしまわない、ラベル要素を使用することをお勧めします。

<!-- Using a <label> is recommended -->
<!-- <label> の使用をお勧めします -->

<label>Search <input type=search name=q></label>
<label>検索 <input type=search name=q></label>


<!-- A placeholder is used as fallback -->
<!-- プレースホルダーがフォールバックとして使用されます -->

<input type=search name=q placeholder="Search">
<input type=search name=q placeholder="検索">





5.3.3 Composing Effective and User-friendly Accessible Names
5.3.3 効果的でユーザーフレンドリーなアクセス可能な名前の構成

For assistive technology users, especially screen reader users, the quality of accessible names is one of the most significant contributors to usability. Names that do not provide enough information reduce users' effectiveness while names that are too long reduce efficiency. And, names that are difficult to understand reduce effectiveness, efficiency, and enjoyment.
支援技術のユーザー、特にスクリーンリーダーのユーザーにとって、アクセス可能な名前の品質は、使いやすさの最も重要な要因の1つです。 十分な情報を提供しない名前はユーザーの効率を低下させ、長すぎる名前は効率を低下させます。 また、理解しにくい名前は、効果、効率、楽しみを損ないます。

The following guidelines provide a starting point for crafting user friendly names.
次のガイドラインは、ユーザーフレンドリーな名前を作成するための開始点を提供します。

    Convey function or purpose, not form. For example, if an icon that looks like the letter "X" closes a dialog, name it "Close", not "X". Similarly, if a set of navigation links in the left side bar navigate among the product pages in a shopping site, name the navigation region "Product", not "Left".
    形ではなく、機能または目的を伝えます。 例えば、文字「X」のようなアイコンがダイアログを閉じる場合は、「X」ではなく「閉じる」という名前を付けます。 同様に、左側のサイドバーの一連のナビゲーションリンクがショッピングサイトの製品ページ間を移動する場合は、ナビゲーション領域に「左」ではなく「製品」という名前を付けます。

    Put the most distinguishing and important words first. Often, for interactive elements that perform an action, this means a verb is the first word. For instance, if a list of contacts displays "Edit", "Delete", and "Actions" buttons for each contact, then "Edit John Doe", "Delete John Doe", and "Actions for John Doe" would be better accessible names than "John Doe edit", "John Doe delete", and "John Doe actions". By placing the verb first in the name, screen reader users can more easily and quickly distinguish the buttons from one another as well as from the element that opens the contact card for John Doe.
    最も特徴的で重要な単語を最初に置きます。 多くの場合、アクションを実行するインタラクティブな要素の場合、これは動詞が最初の単語であることを意味します。 例えば、連絡先のリストに連絡先ごとに「編集」、「削除」、「アクション」ボタンが表示されている場合、「編集 John Doe」、「削除 John Doe」、「アクション John Doe」の方が「John Doe 編集」、「John Doe 削除」、「John Doe アクション」よりもアクセスしやすい名前になります。 スクリーンリーダーのユーザーは、名前の最初に動詞を配置することで、ボタンを互いに、また John Doe の連絡先カードを開く要素からより簡単かつ迅速に区別できます。

    Be concise. For many elements, one to three words is sufficient. Only add more words when necessary.
    簡潔にしてください。 多くの要素では、1〜3語で十分です。 必要な場合にのみ単語を追加してください。

    Do NOT include a WAI-ARIA role name in the accessible name. For example, do not include the word "button" in the name of a button, the word "image" in the name of an image, or the word "navigation" in the name of a navigation region. Doing so would create duplicate screen reader output since screen readers convey the role of an element in addition to its name.
    アクセス可能な名前に WAI-ARIA ロール名を含めないでください。 例えば、ボタンの名前に「ボタン」という単語を含めたり、画像の名前に「画像」という単語を含めたり、ナビゲーションリージョンの名前に「ナビゲーション」という単語を含めたりしないでください。 そうすると、スクリーンリーダーは名前に加えて要素のロールを伝えるため、重複したスクリーンリーダー出力が作成されてしまいます。

    Create unique names for elements with the same role unless the elements are actually identical. For example, ensure every link on a page has a different name except in cases where multiple links reference the same location. Similarly, give every navigation region on a page a different name unless there are regions with identical content that performs identical navigation functions.
    要素が実際に同一でない限り、同じロールを持つ要素に一意の名前を作成します。 例えば、複数のリンクが同じ場所を参照している場合を除いて、ページ上のすべてのリンクの名前が異なることを確認してください。 同様に、同じナビゲーション機能を実行する同じコンテンツのリージョンがない限り、ページ上のすべてのナビゲーションリージョンに異なる名前を付けます。

    Start names with a capital letter; it helps some screen readers speak them with appropriate inflection. Do not end names with a period; they are not sentences.
    名前は大文字で始めます。 一部のスクリーンリーダーが適切な語尾変化でそれらを話すのに役立ちます。 名前をピリオドで終わらせないでください。 それらは文ではありません。





5.3.4 Accessible Name Guidance by Role
5.3.4 ロール別のアクセス可能な名前ガイダンス

Certain elements always require a name, others may usually or sometimes require a name, and still others should never be named. The table below lists all ARIA roles and provides the following information for each :
特定の要素は常に名前を必要とし、他の要素は通常または場合によっては名前が必要で、さらに他の要素では名前を付けるべきではありません。 下の表に、すべての ARIA ロールを示し、それぞれについて次の情報を示します。


Necessity of Naming
命名の必要性：

    Indicates how necessary it is for authors to add a naming attribute or element to supplement or override the content of an element with the specified role. This column may include one of the following values:
    指定されたロールを持つ要素のコンテンツを補足またはオーバーライドするために、作成者は命名するための属性または要素を追加する必要があることを示します。 この列には、次のいずれかの値が含まれる場合があります。

        Required Only If Content Insufficient: An element with this role is named by its descendant content. If aria-label or aria-labelledby is applied, content contained in the element and its descendants is hidden from assistive technology users unless it is also referenced by aria-labelledby. Avoid hiding descendant content except in the rare circumstances where doing so benefits assistive technology users.
        コンテンツが不十分な場合にのみ必要：このロールを持つ要素は、その子孫コンテンツによって名前が付けられます。 aria-label または aria-labelledby が適用される場合、要素とその子孫に含まれるコンテンツは、aria-labelledby によっても参照されない限り、支援技術のユーザーから隠されます。 支援技術のユーザーに利益をもたらすまれな状況を除いて、子孫コンテンツを非表示にしないでください。

        Required: The ARIA specification requires authors to provide a name; a missing name triggers accessibility validators to flag a violation.
        必須：ARIA 仕様では、作成者が名前を指定する必要があります。 名前が欠落していると、アクセシビリティのバリデーターがトリガーされて違反にフラグが付けられます。

        Recommended: Providing a name is strongly recommended.
        推奨：名前を指定することを強くお勧めします。

        Discretionary: Naming is either optional or, in the circumstances described in the guidance column, is discouraged.
        裁量：命名は任意であるか、ガイダンス列に記載されている状況ではお勧めしません。

        Do Not Name: Naming is strongly discouraged even if it is technically permitted; often assistive technologies do not render a name even if provided.
        名前を付けないでください：技術的に許可されている場合でも、命名することは強くお勧めしません。 多くの場合、支援技術は提供されても名前をレンダリングしません。


Guidance:
ガイダンス：

    Provides information to help determine if providing a name is beneficial, and if so, describes any recommended techniques. 
    名前を提供することが有益かどうかを判断するのに役立つ情報を提供し、有益である場合は、推奨される手法について説明します。 


role 	Necessity of Naming 	Guidance
ロール 	命名の必要性 	ガイダンス


alert 	Discretionary 	Some screen readers announce the name of an alert before announcing the content of the alert. Thus, aria-label provides a method for prefacing the visible content of an alert with text that is not displayed as part of the alert. Using aria-label is functionally equivalent to providing off-screen text in the contents of the alert, except off-screen text would be announced by screen readers that do not support aria-label on alert elements.
アラート（alert） 	裁量 	一部のスクリーンリーダーは、アラートのコンテンツをアナウンスする前にアラートの名前をアナウンスします。 したがって、aria-label は、アラートの可視コンテンツの前に、アラートの一部として表示されないテキストを表示する方法を提供します。 aria-label の使用は、アラートのコンテンツにオフスクリーンテキストを提供することと機能的に同等です。 ただし、オフスクリーンテキストは、アラート要素で aria-label をサポートしていないスクリーンリーダーによってアナウンスされます。


alertdialog 	Required 	Use aria-labelledby if a visible label is present, otherwise use aria-label.
アラートダイアログ（alertdialog） 	必須 	可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


application 	Required 	Use aria-labelledby if a visible label is present, otherwise use aria-label.
アプリケーション（application） 	必須 	可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


article 	Recommended 	
記事（article） 	推奨

    Recommended to distinguish articles from one another; helps users when navigating among articles.
    記事を互いに区別することをお勧めします。 記事間をナビゲートするときにユーザーを支援します。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


banner 	Discretionary 	
バナー（banner） 	裁量

    Necessary in the uncommon circumstance where two banner landmark regions are present on the same page. It is otherwise optional.
    2つのバナーランドマークリージョンが同じページに存在するという珍しい状況で必要です。 それ以外の場合は任意です。

    Named using aria-labelledby if a visible label is present, otherwise with aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用して名前を付け、それ以外の場合は aria-label を使用します。

    See the Banner Landmark section.
    バナーランドマークのセクションを参照してください。


button 	Required Only If Content Insufficient 	
ボタン（button） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。


cell 	Required Only If Content Insufficient 	
セル（cell） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    Note that a name is not required; assistive technologies expect an empty cell in a table to be represented by an empty name.
    名前は必須ではないことに注意してください。 支援技術は、テーブル内の空のセルが空の名前で表されることを想定しています。

    Note that associated row or column headers do not name a cell; the name of a cell in a table is its content. Headers are complementary information.
    関連する行ヘッダーまたは列ヘッダーはセルに名前を付けないことに注意してください。 テーブル内のセルの名前はそのコンテンツです。 ヘッダーは補足情報です。


checkbox 	Required Only If Content Insufficient 	
チェックボックス（checkbox） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide any descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    If based on HTML type="checkbox", use a label element.
    HTML type="checkbox" に基づく場合は、ラベル要素を使用します。

    Otherwise, reference visible content via aria-labelledby.
    それ以外の場合、aria-labelledby を介して可視コンテンツを参照してください。


columnheader 	Required Only If Content Insufficient 	
列ヘッダー（columnheader） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    If the columnheader role is implied from an HTML th, the HTML abbr attribute can be used to specify an abbreviated version of the name that is only announced when screen readers are reading an associated cell within the table, grid, or treegrid.
    列ヘッダーロールが HTML テーブルヘッダーセル（th）要素により暗示されている場合、HTML 略語（abbr）属性を使用して、スクリーンリーダーがテーブル、グリッド、またはツリーグリッド内の関連するセルを読み取っているときにのみアナウンスされる名前の短縮版を指定できます。


combobox 	Required 	
コンボボックス（combobox） 	必須

    If the combobox role is applied to an HTML select or input element, can be named with an HTML label element.
    コンボボックスロールが HTML の選択要素または入力要素に適用される場合、HTML ラベル要素を使用して名前を付けることができます。

    Otherwise use aria-labelledby if a visible label is present.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用します。

    Use aria-label if a visible label is not present.
    可視ラベルが存在しない場合は、aria-label を使用してください。


complementary 	Recommended 	
補足（complementary） 	推奨

    Naming is necessary when two complementary landmark regions are present on the same page.
    2つの補足ランドマークリージョンが同じページに存在する場合は、命名する必要があります。

    Naming is recommended even when one complementary region is present to help users understand the purpose of the region's content when navigating among landmark regions.
    ユーザーがランドマークリージョン間をナビゲートするときにリージョンのコンテンツの目的を理解できるように、補足リージョンが1つ存在する場合でも命名することをお勧めします。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Complementary Landmark section.
    補足ランドマークのセクションを参照してください。


contentinfo 	Discretionary 	
コンテンツ情報（contentinfo） 	裁量

    Necessary in the uncommon circumstance where two contentinfo landmark regions are present on the same page. It is otherwise optional.
    2つのコンテンツ情報ランドマークリージョンが同じページに存在するというまれな状況で必要です。 それ以外の場合は任意です。

    Named using aria-labelledby if a visible label is present, otherwise with aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用して名前を付け、それ以外の場合は aria-label を使用します。


definition 	Recommended 	Reference the term being defined with role="term", using aria-labelledby.
定義（definition） 	推奨 	aria-labelledby を使用して、role="term" で定義されている用語を参照します。


dialog 	Required 	Use aria-labelledby if a visible label is present, otherwise use aria-label.
ダイアログ（dialog） 	必須 	可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


directory 	Discretionary 	
ディレクトリー（directory） 	裁量

    Naming can help users understand the purpose of the directory.
    命名すると、ユーザーがディレクトリーの目的を理解するのに役立ちます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


document 	Discretionary 	Elements with the document role are contained within an element with the application role, which is required to have a name. Typically, the name of the application element will provide sufficient context and identity for the document element. Because the application element is used only to create unusual, custom widgets, careful assessment is necessary to determine whether or not adding an accessible name is beneficial.
文書（document） 	裁量 	文書ロールを持つ要素は、アプリケーションロールを持つ要素内に含まれています。 アプリケーションロールには名前が必要です。 通常、アプリケーション要素の名前は、文書要素に十分なコンテキストと身元を提供します。 アプリケーション要素は通常とは異なるカスタムウィジェットを作成するためにのみ使用されるため、アクセス可能な名前を追加することが有益かどうかを判断するには、慎重な評価が必要です。


feed 	Recommended 	
フィード（feed） 	推奨

    Helps screen reader users understand the context and purpose of the feed.
    スクリーンリーダーのユーザーがフィードのコンテキストと目的を理解するのに役立ちます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Feed Design Pattern.
    フィードのデザインパターンを参照してください。


figure 	Recommended 	
図（figure） 	推奨

    For HTML, use the figure and figcaption elements. The figcaption will serve as the accessible name for the figure. See the Naming Tables and Figures with Captions section.
    HTML の場合、図要素と図キャプション要素を使用します。 図キャプションは、図のアクセス可能な名前として機能します。 キャプションによるテーブルと図の命名のセクションを参照してください。

    When not using HTML, or when retrofitting legacy HTML, use the aria-labelledby on the figure, pointing to the figure's caption.
    HTML を使用しない場合、または従来の HTML を後付けする場合は、図に aria-labelledby を使用して、図のキャプションを指します。

    If there is no visible caption, aria-label can be used.
    可視キャプションがない場合は、aria-label を使用できます


form 	Recommended 	
フォーム（form） 	推奨

    Helps screen reader users understand the context and purpose of the form landmark.
    スクリーンリーダーのユーザーがフォームランドマークのコンテキストと目的を理解するのに役立ちます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Form Landmark section.
    フォームランドマークのセクションを参照してください。


grid 	Required 	
グリッド（grid） 	必須

    If the grid is applied to an HTML table element, then the accessible name can be derived from the table's caption element.
    グリッドが HTML テーブル要素に適用されている場合、アクセス可能な名前はテーブルのキャプション要素から導き出すことができます。

    Otherwise, use aria-labelledby if a visible label is present, otherwise use aria-label.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


gridcell 	Required Only If Content Insufficient 	
グリッドセル（gridcell） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    Note that a name is not required; assistive technologies expect an empty cell in a grid to be represented by an empty name.
    名前は必須ではないことに注意してください。 支援技術は、グリッド内の空のセルが空の名前で表されることを期待しています。

    Note that associated row or column headers do not name a gridcell; the name of a cell in a grid is its content. Headers are complementary information.
    関連する行ヘッダーまたは列ヘッダーはグリッドセルに名前を付けないことに注意してください。 グリッド内のセルの名前はその内容です。 ヘッダーは補足情報です。


group 	Discretionary 	
グループ（group） 	裁量

    When using the HTML fieldset element, the accessible name can be derived from the legend element.
    HTML フィールドセット要素を使用する場合、アクセス可能な名前は凡例要素から導き出すことができます。

    When using the HTML details element, do not provide an accessible name for this element. The user interacts with the summary element, and that can derive its accessible name from its contents.
    HTML 詳細開示（details）要素を使用するときは、この要素にアクセス可能な名前を指定しないでください。 ユーザーは開示概要（summary）要素を操作し、その内容からアクセス可能な名前を取得できます。

    When using the HTML optgroup element, use the label attribute.
    HTML オプショングループ（optgroup）要素を使用する場合は、ラベル属性を使用します。 

    Otherwise, use aria-labelledby if a visible label is present, otherwise use aria-label.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


heading 	Required Only If Content Insufficient 	
見出し（heading） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。


img 	Required 	For the HTML img element, use the alt attribute. For other elements with the img role, use aria-labelledby or aria-label.
画像（img） 	必須 	HTML 画像要素には、alt 属性を使用します。 画像ロールを持つ他の要素については、aria-labelledby または aria-label を使用してください。


link 	Required Only If Content Insufficient 	
リンク（link） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。


list 	Discretionary 	
リスト（list） 	裁量

    Potentially beneficial for users of screen readers that support both list names and navigation among lists on a page.
    リスト名とページ上のリスト間のナビゲーションの両方をサポートするスクリーンリーダーのユーザーにとって潜在的に有益です。

    Potentially a source of distracting or undesirable screen reader verbosity, especially if nested within a named container, such as a navigation region.
    特にナビゲーションリージョンなどの名前付きコンテナー内にネストされている場合は、気が散ったり望ましくないスクリーンリーダーの冗長さの原因となる可能性があります。 

    Can be named using aria-labelledby if a visible label is present, otherwise with aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用して名前を付けることができ、それ以外の場合は aria-label を使用します。


listbox 	Required 	
リストボックス（listbox） 	必須

    If the listbox role is applied to an HTML select element (with the multiple attribute or a size attribute having a value greater than 1), can be named with an HTML label element.
    リストボックスロールが HTML 選択要素（複数（multiple）属性または1より大きい値を持つサイズ属性を持つ）に適用される場合、HTML ラベル要素で名前を付けることができます。

    Otherwise use aria-labelledby if a visible label is present.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用します。

    Use aria-label if a visible label is not present.
    可視ラベルが存在しない場合は、aria-label を使用してください。

    See the Listbox Design Pattern.
    リストボックスのデザインパターンを参照してください。


listitem 	Do Not Name 	Not supported by assistive technologies; it is necessary to include relevant content within the list item.
リスト項目（listitem） 	名前を付けないでください 	支援技術ではサポートされていません。 リスト項目に関連するコンテンツを含める必要があります。


log 	Required 	Use aria-labelledby if a visible label is present, otherwise use aria-label.
ログ（log） 	必須 	可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


main 	Discretionary 	
メイン（main） 	裁量

    Potentially helpful for orienting assistive technology users, especially in single-page applications where main content changes happen without generating a page load event.
    特に、ページ読み込みイベントを生成せずにメインコンテンツの変更が発生する単一ページのアプリケーションで、支援技術のユーザーを方向付けるのに役立つ可能性があります。

    Can be named using aria-labelledby if a visible label is present, otherwise with aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用して名前を付けることができ、それ以外の場合は aria-label を使用します。

    See the Main Landmark section.
    メインランドマークのセクションを参照してください。


marquee 	Required 	Use aria-labelledby if a visible label is present, otherwise use aria-label.
マーキー（marquee） 	必須 	可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


math 	Recommended 	
数学（math） 	推奨

    If the math element has only presentational children and the accessible name is intended to convey the mathematical expression, use aria-label to provide a string that represents the expression.
    数学要素にプレゼンテーション化した子のみがあり、アクセス可能な名前が数式を伝えることを目的としている場合は、aria-label を使用して、式を表す文字列を指定します。

    If the math element contains navigable content that conveys the mathematical expression and a visible label for the expression is present, use aria-labelledby.
    数学要素に数式を伝えるナビゲート可能なコンテンツが含まれていて、式のための可視ラベルが存在する場合は、aria-labelledby を使用します。

    Otherwise, use aaria-label to name the expression, e.g., aria-label="Pythagorean Theorem".
    それ以外の場合、aaria-label を使用して式に名前を付けます（例：aria-label="ピタゴラスの定理"）。 


menu 	Recommended 	
メニュー（menu） 	推奨

    Use aria-labelledby to refer to the menuitem or button that controls this element's display.
    aria-labelledby を使用して、この要素の表示を制御するメニュー項目またはボタンを参照します。

    Otherwise, use aria-label.
    それ以外の場合、aria-label を使用します。

    See the Menu or Menu bar Design Pattern.
    メニューまたはメニューバーのデザインパターンを参照してください。 


menubar 	Recommended 	
メニューバー（menubar） 	推奨

    Helps screen reader users understand the context and purpose of menuitem elements in a menubar. Naming a menubar is comparable to naming a menu button. The name of a button that opens a menu conveys the purpose of the menu it opens. Since a menubar element is displayed persistently, a name on the menubar can serve that same purpose.
    スクリーンリーダーのユーザーがメニューバーのメニュー項目要素のコンテキストと目的を理解するのに役立ちます。 メニューバーに命名することは、メニューボタンに命名することに相当します。 メニューを開くボタンの名前は、それが開くメニューの目的を伝えます。 メニューバー要素は永続的に表示されるため、メニューバー上の名前も同じ目的を果たすことができます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Menu or Menu bar Design Pattern.
    メニューまたはメニューバーのデザインパターンを参照してください。 


menuitem 	Required Only If Content Insufficient 	
メニュー項目（menuitem） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide any descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    Note: content contained within a child menu is automatically excluded from the accessible name calculation.
    注：子メニューに含まれるコンテンツは、アクセス可能な名前の計算から自動的に除外されます。

    See the Menu or Menu bar Design Pattern.
    メニューまたはメニューバーのデザインパターンを参照してください。 


menuitemcheckbox 	Required Only If Content Insufficient 	
メニュー項目チェックボックス（menuitemcheckbox） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide any descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    See the Menu or Menu bar Design Pattern.
    メニューまたはメニューバーのデザインパターンを参照してください。 


menuitemradio 	Required Only If Content Insufficient 	
メニュー項目ラジオボタン（menuitemradio） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide any descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    See the Menu or Menu bar Design Pattern.
    メニューまたはメニューバーのデザインパターンを参照してください。 


navigation 	Recommended 	
ナビゲーション（navigation） 	推奨

    Helps screen reader users understand the context and purpose of the navigation landmark.
    スクリーンリーダーのユーザーがナビゲーションランドマークのコンテキストと目的を理解するのに役立ちます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Navigation Landmark section.
    ナビゲーションランドマークのセクションを参照してください。


none 	Do Not Name 	An element with role="none" is not part of the accessibility tree (except in error cases). Do not use aria-labelledby or aria-label.
none 	名前を付けないでください 	role="none" の要素は、アクセシビリティツリーの一部ではありません（エラーの場合を除く）。 aria-labelledby または aria-label は使用しないでください。


note 	Discretionary 	
メモ（note） 	裁量

    Naming is optional, but can help screen reader users understand the context and purpose of the note.
    命名は任意ですが、スクリーンリーダーのユーザーがメモのコンテキストと目的を理解するのに役立ちます。

    Named using aria-labelledby if a visible label is present, otherwise with aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用して名前を付け、それ以外の場合は aria-label を使用します。


option 	Required Only If Content Insufficient 	
オプション（option） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide any descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    See the Combo Box Design Pattern.
    コンボボックスのデザインパターンを参照してください。


presentation 	Do Not Name 	An element with role="presentation" is not part of the accessibility tree (except in error cases). Do not use aria-labelledby or aria-label.
プレゼンテーション（presentation） 	名前を付けないでください 	role="presentation" の要素は、アクセシビリティツリーの一部ではありません（エラーの場合を除く）。 aria-labelledby または aria-label は使用しないでください。


progressbar 	Required 	
プログレスバー（progressbar） 	必須

    If the progressbar role is applied to an HTML progress element, can be named with an HTML label element.
    プログレスバーロールが HTML プログレス（progress）要素に適用される場合、HTML ラベル要素で名前を付けることができます。

    Otherwise use aria-labelledby if a visible label is present.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用します。

    Use aria-label if a visible label is not present.
    可視ラベルが存在しない場合は、aria-label を使用してください。


radio 	Required Only If Content Insufficient 	
ラジオボタン（radio） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide any descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    If based on HTML type="checkbox", use a label element.
    HTML type="checkbox" に基づく場合は、ラベル要素を使用します。

    Otherwise, reference visible content via aria-labelledby.
    それ以外の場合、aria-labelledby を介して可視コンテンツを参照してください。


radiogroup 	Required 	
ラジオグループ（radiogroup） 	必須

    Recommended to help assistive technology users understand the purpose of the group of radio buttons.
    支援技術のユーザーがラジオボタンのグループの目的を理解できるようにするために推奨されます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Radio Group Design Pattern.
    ラジオグループのデザインパターンを参照してください。


region 	Required 	
リージョン（region） 	必須

    Helps screen reader users understand the context and purpose of the landmark.
    スクリーンリーダーのユーザーがランドマークのコンテキストと目的を理解するのに役立ちます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Region Landmark section.
    リージョンランドマークのセクションを参照してください。


row 	Required Only If Content Insufficient AND descendant of a treegrid AND the row is focusable 	When row elements are focusable in a treegrid, screen readers announce the entire contents of a row when navigating by row. This is typically the most appropriate behavior. However, in some circumstances, it could be beneficial to change the order in which cells are announced or exclude announcement of certain cells by using aria-labelledby to specify which cells to announce.
行（row） 	コンテンツが不十分で、ツリーグリッドの子孫であり、行がフォーカス可能である場合にのみ必要 	行要素がツリーグリッドでフォーカス可能である場合、スクリーンリーダーは、行ごとにナビゲートするときに行の内容全体をアナウンスします。 これは通常、最も適切な振る舞いです。 ただし、状況によっては、aria-labelledby を使用してアナウンスするセルを指定することにより、セルがアナウンスされる順序を変更したり、特定のセルのアナウンスを除外したりすることが有益な場合があります。


rowgroup 	Do Not Name 	Not supported by assistive technologies.
行グループ（rowgroup） 	名前を付けないでください 	支援技術ではサポートされていません。


rowheader 	Required Only If Content Insufficient 	
行ヘッダー（rowheader） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    If the rowheader role is implied from an HTML th, the HTML abbr attribute can be used to specify an abbreviated version of the name that is only announced when screen readers are reading an associated cell within the table, grid, or treegrid.
    行ヘッダーロールが HTML テーブルヘッダーセル（th）により暗示されている場合、HTML 略語（abbr）属性を使用して、スクリーンリーダーがテーブル、グリッド、またはツリーグリッド内の関連するセルを読み取っているときにのみアナウンスされる名前の短縮版を指定できます。


scrollbar 	Discretionary 	
スクロールバー（scrollbar） 	裁量

    Naming is optional, but can potentially help screen reader users understand the purpose of the scrollbar. The purpose is also conveyed using the aria-controls attribute, which is required for scrollbar.
    命名は任意ですが、スクリーンリーダーのユーザーがスクロールバーの目的を理解するのに役立つ可能性があります。 目的は、スクロールバーに必要な aria-controls 属性も使用して伝えられます。

    Named using aria-labelledby if a visible label is present, otherwise with aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用して名前を付け、それ以外の場合は aria-label を使用します。


search 	Recommended 	
検索（search） 	推奨

    Helps screen reader users understand the context and purpose of the search landmark.
    スクリーンリーダーのユーザーが検索ランドマークのコンテキストと目的を理解するのに役立ちます。

    Named using aria-labelledby if a visible label is present, otherwise with aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用して名前を付け、それ以外の場合は aria-label を使用します。

    See the Search Landmark section.
    検索ランドマークのセクションを参照してください。


searchbox 	Required 	
検索ボックス（searchbox） 	必須

    If the searchbox role is applied to an HTML input element, can be named with an HTML label element.
    検索ボックスロールが HTML 入力要素に適用されている場合は、HTML ラベル要素を使用して名前を付けることができます。

    Otherwise use aria-labelledby if a visible label is present.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用します。

    Use aria-label if a visible label is not present.
    可視ラベルが存在しない場合は、aria-label を使用してください。


separator 	Discretionary 	
区切り（separator） 	裁量

    Recommended if there is more than one focusable separator element on the page.
    ページに複数のフォーカス可能な区切り要素がある場合に推奨されます。

    Can help assistive technology users understand the purpose of the separator.
    支援技術のユーザーが区切りの目的を理解するのに役立ちます。

    Named using aria-labelledby if a visible label is present, otherwise with aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用して名前を付け、それ以外の場合は aria-label を使用します。


slider 	Required 	
スライダー（slider） 	必須

    If the slider role is applied to an HTML input element, can be named with an HTML label element.
    スライダーロールが HTML 入力要素に適用される場合、HTML ラベル要素で名前を付けることができます。

    Otherwise use aria-labelledby if a visible label is present.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用します。

    Use aria-label if a visible label is not present.
    可視ラベルが存在しない場合は、aria-label を使用してください。

    See the Slider Design Pattern and the Slider (Multi-Thumb) Design Pattern.
    スライダーのデザインパターンとスライダー（複数つまみ）のデザインパターンを参照してください。 


spinbutton 	Required 	
スピンボタン（spinbutton） 	必須

    If the ---textbox---+++spinbutton+++ role is applied to an HTML input element, can be named with an HTML label element.
    スピンボタンロールが HTML 入力要素に適用される場合、HTML ラベル要素で名前を付けることができます。

    Otherwise use aria-labelledby if a visible label is present.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用します。

    Use aria-label if a visible label is not present.
    可視ラベルが存在しない場合は、aria-label を使用してください。

    See the Spinbutton Design Pattern.
    スピンボタンのデザインパターンを参照してください。


status 	Discretionary 	Some screen readers announce the name of a status element before announcing the content of the status element. Thus, aria-label provides a method for prefacing the visible content of a status element with text that is not displayed as part of the status element. Using aria-label is functionally equivalent to providing off-screen text in the contents of the status element, except off-screen text would be announced by screen readers that do not support aria-label on status elements.
ステータス（status） 	裁量 	一部のスクリーンリーダーは、ステータス要素の内容をアナウンスする前に、ステータス要素の名前をアナウンスします。 したがって、aria-label は、ステータス要素の可視コンテンツの前に、ステータス要素の一部として表示されないテキストを表示する方法を提供します。 aria-label を使用することは、ステータス要素のコンテンツにオフスクリーンテキストを提供することと機能的に同等です。 ただし、オフスクリーンテキストは、ステータス要素で aria-label をサポートしないスクリーンリーダーによってアナウンスされます。


switch 	Required Only If Content Insufficient 	
スイッチ（switch） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide any descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    If based on HTML type="checkbox", use a label element.
    HTML type="checkbox" に基づく場合は、ラベル要素を使用します。

    Otherwise, reference visible content via aria-labelledby.
    それ以外の場合、aria-labelledby を介して可視コンテンツを参照してください。


tab 	Required Only If Content Insufficient 	
タブ（tab） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。


table 	Required 	
テーブル（table） 	必須

    If using HTML table element, use the caption element.
    HTML テーブル要素を使用する場合は、キャプション要素を使用します。

    Otherwise use aria-labelledby if a visible label is present.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用します。

    Use aria-label if a visible label is not present.
    可視ラベルが存在しない場合は、aria-label を使用してください。

    See the Table Design Pattern.
    テーブルのデザインパターンを参照してください。


tablist 	Recommended 	
タブリスト（tablist） 	推奨

    Helps screen reader users understand the context and purpose of the tablist.
    スクリーンリーダーのユーザーがタブリストのコンテキストと目的を理解するのに役立ちます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Carousel Design Pattern and Tabs Design Pattern.
    カルーセルのデザインパターンとタブのデザインパターンを参照してください。


tabpanel 	Required 	
タブパネル（tabpanel） 	必須

    Use aria-labelledby pointing to the tab element that controls the tabpanel.
    タブパネルを制御するタブ要素を指す aria-labelledby を使用します。

    See the Carousel Design Pattern and Tabs Design Pattern.
    カルーセルのデザインパターンとタブのデザインパターンを参照してください。


term 	Do Not Name 	Since a term is usually the name for the role="definition" element, it could be confusing if the term itself also has a name.
用語（term） 	名前を付けないでください 	通常、用語は role="definition" 要素の名前であるため、用語自体にも名前があると混乱する可能性があります。


textbox 	Required 	
テキストボックス（textbox） 	必須

    If the textbox role is applied to an HTML input or textarea element, can be named with an HTML label element.
    テキストボックスロールが HTML の入力要素またはテキストエリア要素に適用される場合、HTML ラベル要素で名前を付けることができます。

    Otherwise use aria-labelledby if a visible label is present.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用します。

    Use aria-label if a visible label is not present.
    可視ラベルが存在しない場合は、aria-label を使用してください。


timer 	Required 	Use aria-labelledby if a visible label is present, otherwise use aria-label.
タイマー（timer） 	必須 	可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。


toolbar 	Recommended 	
ツールバー（toolbar） 	推奨

    If there is more than one toolbar element on the page, naming is required.
    ページに複数のツールバー要素がある場合は、命名する必要があります。

    Helps assistive technology users to understand the purpose of the toolbar, even when there is only one toolbar on the page.
    ページにツールバーが1つしかない場合でも、支援技術のユーザーがツールバーの目的を理解するのに役立ちます。

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Toolbar Pattern.
    ツールバーのパターンを参照してください。


tooltip 	Required Only If Content Insufficient 	
ツールチップ（tooltip） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。


tree 	Required 	
ツリー（tree） 	必須

    Use aria-labelledby if a visible label is present, otherwise use aria-label.
    可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Tree View Design Pattern.
    ツリービューのデザインパターンを参照してください。


treegrid 	Required 	
ツリーグリッド（treegrid） 	必須

    If the treegrid is applied to an HTML table element, then the accessible name can be derived from the table's caption element.
    ツリーグリッドが HTML テーブル要素に適用されている場合、アクセス可能な名前はテーブルのキャプション要素から導き出すことができます。

    Otherwise, use aria-labelledby if a visible label is present, otherwise use aria-label.
    それ以外の場合、可視ラベルが存在する場合は aria-labelledby を使用し、それ以外の場合は aria-label を使用します。

    See the Treegrid Design Pattern.
    ツリーグリッドのデザインパターンを参照してください。


treeitem 	Required Only If Content Insufficient 	
ツリー項目（treeitem） 	コンテンツが不十分な場合にのみ必要

    Warning! Using aria-label or aria-labelledby will hide any descendant content from assistive technologies.
    警告！ aria-label または aria-labelledby を使用すると、支援技術から子孫コンテンツが隠されます。

    Ideally named by visible, descendant content.
    理想的には、可視の子孫コンテンツによって名前を付けます。

    Note: content contained within a child group is automatically excluded from the accessible name calculation.
    注：子グループに含まれるコンテンツは、アクセス可能な名前の計算から自動的に除外されます。

    See the Tree View Design Pattern.
    ツリービューのデザインパターンを参照してください。





5.3.5 Accessible name calculation
5.3.5 アクセス可能な名前の計算

User agents construct an accessible name string for an element by walking through a list of potential naming methods and using the first that generates a name. The algorithm they follow is defined in the accessible name specification. It is roughly like the following:
ユーザーエージェントは、潜在的な命名方法のリストをたどり、名前を生成する最初の方法を使用して、要素のアクセス可能な名前文字列を構築します。 それらが従うアルゴリズムは、アクセス可能な名前の仕様で定義されています。 おおまかに次のようになります。

    The aria-labelledby property is used if present.
    1. 存在する場合、aria-labelledby プロパティが使用されます。

    If the name is still empty, the aria-label property is used if present.
    2. 名前がまだ空の場合、存在する場合は aria-label プロパティが使用されます。


    If the name is still empty, then host-language-specific attributes or elements are used if present. For HTML, these are, depending on the element:
    3. 名前がまだ空の場合は、ホスト言語固有の属性または要素が存在する場合はそれが使用されます。 HTML の場合、これらは要素に応じて次のようになります。

    input whose type attribute is in the Button, Submit Button, or Reset Button state
    タイプ属性がボタン状態、送信ボタン状態、またはリセットボタン状態にある入力（input）

        The value attribute.
        値（value）属性。

    input whose type attribute is in the Image Button state
    タイプ属性が画像ボタン状態にある入力（input）

    img
    画像（img）

    area
    エリア（area）

        The alt attribute. 
        alt 属性。

    fieldset
    フィールドセット（fieldset）

        The first child legend element.
        最初の子凡例（legend）要素。

    Other form elements
    その他のフォーム要素

        The associated label element(s).
        関連するラベル要素。

    figure
    図（figure）

        The first child figcaption element.
        最初の子図キャプション（figcaption）要素。

    table
    テーブル

        The first child caption element.
        最初の子キャプション要素。


    If the name is still empty, then for elements with a role that supports naming from child content, the content of the element is used.
    4. 名前がまだ空の場合、子コンテンツからの命名をサポートするロールを持つ要素の場合、要素のコンテンツが使用されます。


    Finally, if the name is still empty, then other fallback host-language-specific attributes or elements are used if present. For HTML, these are, depending on the element:
    5. 最後に、名前がまだ空の場合は、他のフォールバックのホスト言語固有の属性または要素が存在する場合はそれが使用されます。 HTML の場合、これらは要素に応じて次のようになります。

    input whose type attribute is in the Text, Password, Search, Telephone, or URL states
    タイプ属性がテキスト状態、パスワード状態、検索状態、電話状態、または URL 状態にある入力（input）

    textarea
    テキストエリア（textarea）

        The title attribute. Otherwise, the placeholder attribute.
        タイトル属性。 それ以外の場合は、プレースホルダー属性。

    input whose type attribute is in the Submit Button state
    タイプ属性が送信ボタン状態にある入力（input）

        A localized string of the word "submit".
        "submit" という単語のローカライズされた文字列。

    input whose type attribute is in the Reset Button state
    タイプ属性がリセットボタン状態にある入力（input）

        A localized string of the word "reset".
        "reset" という単語のローカライズされた文字列。

    input whose type attribute is in the Image Button state
    タイプ属性が画像ボタン状態にある入力（input）

        The title attribute. Otherwise, a localized string of the phrase "Submit Query".
        タイトル属性。 それ以外の場合は、"Submit Query" というフレーズのローカライズされた文字列。

    summary
    概要（summary）

        The word "Details".
        "Details" という言葉。

    Other elements
    その他の要素

        The title attribute.
        タイトル属性。

The final step is a fallback mechanism. Generally when labeling an element, use one of the non-fallback mechanisms.
最後のステップはフォールバックメカニズムです。 通常、要素にラベルを付けるときは、フォールバックでないメカニズムの1つを使用します。

When calculating a name from content, the user agent walks through all descendant nodes except in the cases of treeitem and menuitem as described below. And, when following references in an aria-labelledby attribute, it similarly walks the tree of each referenced element. Thus, the naming algorithm is recursive. The following two sections explain non-recursive and recursive examples of how the algorithm works.
コンテンツから名前を計算する場合、ユーザーエージェントは、以下で説明するツリー項目（treeitem）とメニュー項目（menuitem）の場合を除いて、すべての子孫ノードをたどります。 また、aria-labelledby 属性で参照を追跡する場合、同様に、参照されている各要素のツリーをたどります。 したがって、命名アルゴリズムは再帰的です。 次の2つのセクションでは、アルゴリズムがどのように機能するかの非再帰的な例および再帰的な例について説明します。

When calculating a name from content for the treeitem role, descendant content of child group elements are not included. For example, in the following tree, the name of the first tree item is "Fruits"; "Apples", "Bananas", and "Oranges" are automatically omitted.
ツリー項目ロールのコンテンツから名前を計算する場合、子グループ要素の子孫コンテンツは含まれません。 例えば、次のツリーでは、最初のツリー項目の名前は「フルーツ」です。 「りんご」、「バナナ」、「オレンジ」は自動的に省略されます。 

<ul role="tree">

  <li role="treeitem">Fruits
  <li role="treeitem">フルーツ

    <ul role="group">

      <li role="treeitem">Apples</li>
      <li role="treeitem">りんご</li>

      <li role="treeitem">Bananas</li>
      <li role="treeitem">バナナ</li>

      <li role="treeitem">Oranges</li>
      <li role="treeitem">オレンジ</li>

    </ul>

  </li>

</ul>

Similarly, when calculating a name from content for the menuitem role, descendant content of child menu elements are not included. So, the name of the first parent menuitem in the following menu is "Fruits".
同様に、メニュー項目ロールのコンテンツから名前を計算する場合、子メニュー要素の子孫コンテンツは含まれません。 したがって、次のメニューの最初の親メニュー項目の名前は「フルーツ」です。

<ul role="menu">

  <li role="menuitem">Fruits
  <li role="menuitem">フルーツ

    <ul role="menu">

      <li role="menuitem">Apples</li>
      <li role="menuitem">りんご</li>

      <li role="menuitem">Bananas</li>
      <li role="menuitem">バナナ</li>

      <li role="menuitem">Oranges</li>
      <li role="menuitem">オレンジ</li>

    </ul>

  </li>

</ul>





5.3.5.1 Examples of non-recursive accessible name calculation
5.3.5.1 非再帰的なアクセス可能な名前の計算の例

Consider an input element that has no associated label element and only a name attribute and so does not have an accessible name (do not do this):
ラベル要素が関連付けられておらず、名前属性のみがあり、アクセス可能な名前がない入力要素について考えてみます（これは行わないでください）。 

<input name="code">

If there is a placeholder attribute, then it serves as a naming fallback mechanism (avoid doing this):
プレースホルダー属性がある場合、それは命名フォールバックメカニズムとして機能します（これを行うことは避けてください）。

<input name="code"

       placeholder="One-time code">
       placeholder="ワンタイムコード">

If there is also a title attribute, then it is used as the accessible name instead of placeholder, but it is still a fallback (avoid doing this):
タイトル属性もある場合は、プレースホルダーの代わりにアクセス可能な名前として使用されますが、それでもフォールバックです（これを行うことは避けてください）。

<input name="code"

       placeholder="123456"

       title="One-time code">
       title="ワンタイムコード">

If there is also a label element (recommended), then that is used as the accessible name, and the title attribute is instead used as the accessible description:
ラベル要素（推奨）もある場合は、それがアクセス可能な名前として使用され、代わりにタイトル属性がアクセス可能な説明として使用されます。

<label>One-time code
<label>ワンタイムコード

 <input name="code"

        placeholder="123456"

        title="Get your code from the app.">
        title="アプリからコードを取得します。">

</label>

If there is also an aria-label attribute (not recommended unless it adds clarity for assistive technology users), then that becomes the accessible name, overriding the label element:
aria-label 属性もある場合（支援技術ユーザーに明確さを提供しない限り推奨されません）、それがアクセス可能な名前になり、ラベル要素をオーバーライドします。

<label>Code
<label>コード

 <input name="code"

        aria-label="One-time code"
        aria-label="ワンタイムコード"

        placeholder="123456"

        title="Get your code from the app.">
        title="アプリからコードを取得します。">

</label>

If there is also an aria-labelledby attribute, that wins over the other elements and attributes (the aria-label attribute ought to be removed if it is not used):
aria-labelledby 属性もある場合、それは他の要素と属性に優先します（aria-label 属性は使用しない場合は削除する必要があります）。

<p>Please fill in your <span id="code-label">one-time code</span> to log in.</p>
<p>ログインするには、<span id="code-label">ワンタイムコード</span>を入力してください。</p>

<p>

 <label>Code
 <label>コード

  <input name="code"

         aria-labelledby="code-label"

         aria-label="This is ignored"
         aria-label="これは無視されます"

         placeholder="123456"

         title="Get your code from the app.">
         title="アプリからコードを取得します。">

 </label>

</p>





5.3.5.2 Examples of recursive accessible name calculation
5.3.5.2 再帰的なアクセス可能な名前の計算の例

The accessible name calculation algorithm will be invoked recursively when necessary. An aria-labelledby reference causes the algorithm to be invoked recursively, and when computing an accessible name from content the algorithm is invoked recursively for each child node.
アクセス可能な名前計算アルゴリズムは、必要に応じて再帰的に呼び出されます。 aria-labelledby 参照により、アルゴリズムが再帰的に呼び出され、コンテンツからアクセス可能な名前を計算するときに、アルゴリズムは子ノードごとに再帰的に呼び出されます。

In this example, the label for the button is computed by recursing into each child node, resulting in "Move to trash".
この例では、ボタンのラベルは、各子ノードに繰り返しアクセスすることで計算され、「ゴミ箱に移動」になります。 

<button>Move to <img src="bin.svg" alt="trash"></button>
<button><img src="bin.svg" alt="ゴミ箱">に移動</button>

When following an aria-labelledby reference, the algorithm avoids following the same reference twice to avoid infinite loops.
aria-labelledby 参照をたどる場合、アルゴリズムは、無限ループを避けるために、同じ参照を2回たどることを避けます。


In this example, the label for the button is computed by first following the aria-labelledby reference to the parent element, and then computing the label for that element from the child nodes, first visiting the button element again but ignoring the aria-labelledby reference and instead using the aria-label, and then visiting the next child (the text node). The resulting label is "Remove meeting: Daily status report".
この例では、ボタンのラベルは、最初に親要素への aria-labelledby 参照をたどり、次に子ノードからその要素のラベルを計算することによって計算されます。 最初にボタン要素に再度アクセスしますが、aria-labelledby 参照は無視します。 代わりに、aria-label を使用して、それから次の子（テキストノード）にアクセスします。 結果のラベルは「会議の削除：日次状況報告」です。 

<div id="meeting-1">

  <button aria-labelledby="meeting-1" aria-label="Remove meeting:">X</button>
  <button aria-labelledby="meeting-1" aria-label="会議の削除：">X</button>

  Daily status report
  日次状況報告

</div>





5.4 Accessible Descriptions
5.4 アクセス可能な説明




5.4.1 Describing Techniques
5.4.1 説明手法




5.4.1.1 Describing by referencing content with aria-describedby
5.4.1.1 aria-describedby でコンテンツを参照することによる説明


The aria-describedby property works similarly to the aria-labelledby property. For example, a button could be described by a sibling paragraph.
aria-scribedby プロパティは、aria-labelledby プロパティと同様に機能します。 例えば、ボタンは兄弟の段落によって説明することができます。 

<button aria-describedby="trash-desc">Move to trash</button>
<button aria-describedby="trash-desc">ゴミ箱に移動</button>

...

<p id="trash-desc">Items in the trash will be permanently removed after 30 days.</p>
<p id="trash-desc">ゴミ箱の中の項目は30日後に永久に削除されます。</p>

Descriptions are reduced to text strings. For example, if the description contains an HTML img element, a text equivalent of the image is computed.
説明はテキスト文字列に切り詰められます。 例えば、説明に HTML 画像要素が含まれている場合、画像に相当するテキストが計算されます。

<button aria-describedby="trash-desc"> Move to <img src="bin.svg" alt="trash"></button>
<button aria-describedby="trash-desc"> <img src="bin.svg" alt="ゴミ箱">に移動</button>

...

<p id="trash-desc">Items in <img src="bin.svg" alt="the trash"> will be permanently removed after 30 days.</p>
<p id="trash-desc"><img src="bin.svg" alt="ゴミ箱">の中の項目は30日後に永久に削除されます。</p>

As with aria-labelledby, it is possible to reference an element using aria-describedby even if that element is hidden. For example, a text field in a form could have a description that is hidden by default, but can be revealed on request using a disclosure widget. The description could also be referenced from the text field directly with aria-describedby. In the following example, the accessible description for the input element is "Your username is the name that you use to log in to this service."
aria-labelledby と同様に、要素が非表示になっている場合でも、aria-describedby を使用して要素を参照することができます。 例えば、フォームのテキストフィールドには、デフォルトで非表示になっている説明を含めることができますが、開示ウィジェットを使用して要求に応じて表示できます。 説明は、テキストフィールドから aria-describedby を使用して直接参照することもできます。 次の例では、入力要素のアクセス可能な説明は「ユーザー名は、このサービスへのログインに使用する名前です。」です。

<label for="username">Username</label>
<label for="username">ユーザー名</label>

<input id="username" name="username" aria-describedby="username-desc">

<button aria-expanded="false" aria-controls="username-desc" aria-label="Help about username">?</button>
<button aria-expanded="false" aria-controls="username-desc" aria-label="ユーザー名に関するヘルプ">?</button>

<p id="username-desc" hidden>

  Your username is the name that you use to log in to this service.
  ユーザー名は、このサービスへのログインに使用する名前です。

</p>





5.4.1.2 Describing Tables and Figures with Captions
5.4.1.2 キャプションによるテーブルと図の説明

In HTML, if the table is named using aria-label or aria-labelledby, a child caption element becomes an accessible description. For example, a preceding heading might serve as an appropriate accessible name, and the caption element might contain a longer description. In such a situation, aria-labelledby could be used on the table to set the accessible name to the heading content and the caption would become the accessible description.
HTML では、テーブルに aria-label または aria-labelledby を使用して名前が付けられている場合、子キャプション要素がアクセス可能な説明になります。 例えば、前の見出しが適切なアクセス可能な名前として機能し、キャプション要素に長い説明が含まれている場合があります。 このような状況では、aria-labelledby をテーブルで使用して、アクセス可能な名前を見出しのコンテンツに設定すると、キャプションがアクセス可能な説明になります。 

<h2 id="events-heading">Upcoming events</h2>
<h2 id="events-heading">今後のイベント</h2>

<table aria-labelledby="events-heading">

 <caption>

  Calendar of upcoming events, weeks 27 through 31, with each week starting with
  毎週月曜日から始まる、27週から31週までの今後のイベントのカレンダー。 

  Monday. The first column is the week number.
  最初の列は週番号です。

 </caption>

 <tr><th>Week<th>Monday<th>Tuesday<th>Wednesday<th>Thursday<th>Friday<th>Saturday<th>Sunday
 <tr><th>週<th>月曜日<th>火曜日<th>水曜日<th>木曜日<th>金曜日<th>土曜日<th>日曜日

 <tr><td>27<td><td><td><td><td><td><td>

 <tr><td>28<td><td><td><td><td><td><td><a href="/events/9856">Crown Princess's birthday</a>
 <tr><td>28<td><td><td><td><td><td><td><a href="/events/9856">皇太子妃の誕生日</a>

 <tr><td>29<td><td><td><td><td><td><td>

 <tr><td>30<td><td><td><td><td><td><td>

 <tr><td>31<td><td><td><td><td><td><td>

</table>

The HTML figure element can get its accessible name from its figcaption element, but it will not be used as the accessible description, even if it was not used as the accessible name. If the figcaption element is appropriate as an accessible description, and the accessible name is set using aria-labelledby or aria-label, then the figcaption can be explicitly set as the accessible description using the aria-describedby attribute.
HTML 図要素は図キャプション要素からアクセス可能な名前を取得できますが、アクセス可能な名前として使用されていなくても、アクセス可能な説明としては使用されません。 図キャプション要素がアクセス可能な説明として適切であり、アクセス可能な名前が aria-labelledby または aria-label を使用して設定されている場合、図キャプションは、aria-describedby 属性を使用してアクセス可能な説明として明示的に設定できます。

<h2 id="neutron">Neutron</h2>
<h2 id="neutron">中性子</h2>

<figure aria-labelledby="neutron" aria-describedby="neutron-caption">

 <img src="neutron.svg" alt="Within the neutron are three quarks (blue 'u',
 <img src="neutron.svg" alt="中性子の中には、相互接続された3つのクォーク

 red 'd', green 'd') that are interconnected.">
 （青 'u'、赤 'd'、緑 'd'）があります。">

 <figcaption id="neutron-caption">

  The quark content of the neutron. The color assignment of individual quarks is
  中性子のクォーク含有量。 個々のクォークの色の割り当ては任意ですが、

  arbitrary, but all three colors must be present. Forces between quarks are
  3色すべてが存在する必要があります。 

  mediated by gluons.
  クォーク間の力はグルーオンによって媒介されます。

 </figcaption>

</figure>





5.4.1.3 Descriptions Derived from Titles
5.4.1.3 タイトルから導き出された説明

If an accessible description was not provided using the aria-describedby attribute or one of the primary host-language-specific attributes or elements (e.g., the caption element for table), then, for HTML, if the element has a title attribute, that is used as the accessible description.
aria-describedby 属性または主要なホスト言語固有の属性または要素の1つ（例えば、テーブルのキャプション要素）を使用してアクセス可能な説明が提供されなかった場合、HTML の場合、要素にタイトル属性があると、 アクセス可能な説明として使用されます。

A visible description together with aria-describedby is generally recommended. If a description that is not visible is desired, then the title attribute can be used, for any HTML element that can have an accessible description.
aria-describedby と一緒に可視の説明が一般的に推奨されます。 可視でない説明が必要な場合は、アクセス可能な説明を持つことができる任意の HTML 要素にタイトル属性を使用できます。

Note that the title attribute might not be accessible to some users, in particular sighted users not using a screen reader and not using a pointing device that supports hover (e.g., a mouse).
一部のユーザー、特にスクリーンリーダーを使用しておらず、ホバーをサポートするポインティングデバイス（マウスなど）を使用していない視力のあるユーザーは、タイトル属性にアクセスできない場合があることに注意してください。

For example, an input element with input constrained using the pattern attribute can use the title attribute to describe what the expected input is.
例えば、パターン属性を使用して入力が制約されている入力要素は、タイトル属性を使用して、予想される入力を説明することができます。 

<label> Part number:
<label> 部品番号：

 <input pattern="[0-9][A-Z]{3}" name="part"

        title="A part number is a digit followed by three uppercase letters."/>
        title="部品番号は、数字の後に3つの大文字が続きます。"/>

</label>

The title attribute in this case can be shown to the user as a tooltip when the user hovers or focuses the control, but also as part of the error message when the user agent validates the form, if the input element's value doesn't match the pattern.
この場合のタイトル属性は、ユーザーがコントロールをホバーまたはフォーカスしたときにツールチップとしてユーザーに表示できますが、入力要素の値がパターンと一致しない場合に、ユーザーエージェントがフォームを検証するときのエラーメッセージの一部として表示することもできます。

As another example, a link can use the title attribute to describe the link in more detail.
別の例として、リンクはタイトル属性を使用して、リンクをより詳細に説明できます。 

<a href="http://twitter.com/W3C"

   title="Follow W3C on Twitter">
   title="Twitter で W3C をフォローする">

   <img src="/2008/site/images/Twitter_bird_logo_2012.svg"

        alt="Twitter" class="social-icon" height="40" />

</a>





5.4.2 Accessible description calculation
5.4.2 アクセス可能な説明の計算

Like the accessible name calculation, the accessible description calculation produces a text string.
アクセス可能な名前の計算と同様に、アクセス可能な説明の計算ではテキスト文字列が生成されます。

The accessible description calculation algorithm is the same as the accessible name calculation algorithm except for a few branch points that depend on whether a name or description is being calculated. In particular, when accumulating text for an accessible description, the algorithm uses aria-describedby instead of aria-labelledby.
アクセス可能な説明の計算アルゴリズムは、名前または説明のどちらが計算されているかに依存するいくつかの分岐点を除いて、アクセス可能な名前の計算アルゴリズムと同じです。 特に、アクセス可能な説明のテキストを蓄積する場合、アルゴリズムは aria-labelledby の代わりに aria-describedby を使用します。

User agents construct an accessible description string for an element by walking through a list of potential description methods and using the first that generates a description. The algorithm they follow is defined in the accessible name specification. It is roughly like the following:
ユーザーエージェントは、潜在的な説明方法のリストをたどり、説明を生成する最初の方法を使用して、要素のアクセス可能な説明文字列を構築します。 それらが従うアルゴリズムは、アクセス可能な名前の仕様で定義されています。 それは、おおまかに次のようになります。

    The aria-describedby property is used if present.
    1. 存在する場合、aria-describedby プロパティが使用されます。

    If the description is still empty, then host-language-specific attributes or elements are used if present, if it wasn't already used as the accessible name. For HTML, these are, depending on the element:
    2. 説明がまだ空の場合、アクセス可能な名前としてまだ使用されていなければ、ホスト言語固有の属性または要素が存在する場合はそれが使用されます。 HTML の場合、これらは要素に応じて次のようになります。

    input whose type attribute is in the Button, Submit Button, or Reset Button state
    タイプ属性がボタン状態、送信ボタン状態、またはリセットボタン状態にある入力（input）

        The value attribute.
        値（value）属性。

    summary
    概要（summary）

        The element's subtree.
        要素のサブツリー。

    table
    テーブル（table）

        The first child caption element.
        最初の子キャプション要素。

    Finally, if the description is still empty, then other host-language-specific attributes or elements are used if present, if it wasn't already used for the accessible name. For HTML, this is the title attribute.
    3. 最後に、説明がまだ空の場合、アクセス可能な名前にまだ使用されていなければ、他のホスト言語固有の属性または要素が存在する場合はそれが使用されます。 HTML の場合、これはタイトル属性です。





6. Developing a Keyboard Interface
6. キーボードインターフェイスの開発

Unlike native HTML form elements, browsers do not provide keyboard support for graphical user interface (GUI) components that are made accessible with ARIA; authors have to provide the keyboard support in their code. This section describes the principles and methods for making the functionality of a web page that includes ARIA widgets, such as menus and grids, as well as interactive components, such as toolbars and dialogs, operable with a keyboard. Along with the basics of focus management, this section offers guidance toward the objective of providing experiences to people who rely on a keyboard that are as efficient and enjoyable as the experiences available to others.
ネイティブな HTML フォーム要素とは異なり、ブラウザーは、ARIA でアクセス可能にしているグラフィカルユーザーインターフェイス（GUI）コンポーネントのキーボードサポートを提供しません。 作成者は、コードでキーボードサポートを提供する必要があります。 このセクションでは、メニューやグリッドなどの ARIA ウィジェット、およびツールバーやダイアログなどのインタラクティブなコンポーネントを含むウェブページの機能をキーボードで操作できるようにするための原則と方法について説明します。 このセクションでは、フォーカス管理の基本に加えて、キーボードに依存しているユーザーにも他のユーザーと同じくらい効率的で楽しいエクスペリエンスを提供するという目的に向けたガイダンスを提供します。 

This section covers:
このセクションの内容は次のとおりです。

    Understanding fundamental principles of focus movement conventions used in ARIA design patterns.
    1. ARIA デザインパターンで使用されるフォーカス移動規則の基本原則を理解する。

    Maintaining visible focus, predictable focus movement, and distinguishing between keyboard focus and the selected state.
    2. 可視フォーカスの維持、予測可能なフォーカスの動き、キーボードのフォーカスと選択された状態の区別。

    Managing movement of keyboard focus between components, e.g., how the focus moves when the Tab and Shift+Tab keys are pressed.
    3. コンポーネント間のキーボードフォーカスの移動を管理します。例えば、Tab キーおよび Shift + Tab キーが押されたときにフォーカスがどのように移動するかなどです。

    Managing movement of keyboard focus inside components that contain multiple focusable elements, e.g., two different methods for programmatically exposing focus inside widgets like radio groups, menus, listboxes, trees, and grids.
    4. 複数のフォーカス可能な要素を含むコンポーネント内のキーボードフォーカスの動きを管理します。 例えば、ラジオグループ、メニュー、リストボックス、ツリー、グリッドなどのウィジェット内のフォーカスをプログラムで公開するための2つの異なる方法です。

    Determining when to make disabled interactive elements focusable.
    5. 無効化されているインタラクティブな要素をいつフォーカス可能にするかを決定します。

    Assigning and revealing keyboard shortcuts, including guidance on how to avoid problematic conflicts with keyboard commands of assistive technologies, browsers, and operating systems.
    6. 支援技術、ブラウザー、およびオペレーティングシステムのキーボードコマンドとの問題のある競合を回避する方法に関するガイダンスを含む、キーボードショートカットの割り当てと公開。 





6.1 Fundamental Keyboard Navigation Conventions
6.1 基本的なキーボードナビゲーション規則

ARIA roles, states, and properties model accessibility behaviors and features shared among GUI components of popular desktop GUIs, including Microsoft Windows, macOS, and GNOME. Similarly, ARIA design patterns borrow user expectations and keyboard conventions from those platforms, consistently incorporating common conventions with the aim of facilitating easy learning and efficient operation of keyboard interfaces across the web.
ARIA のロール、状態、およびプロパティは、Microsoft Windows、macOS、GNOME などの一般的なデスクトップ GUI の GUI コンポーネント間で共有されるアクセシビリティの振る舞いと機能をモデル化します。 同様に、ARIA デザインパターンは、これらのプラットフォームからユーザーの期待とキーボード規則を借用し、ウェブ全体でのキーボードインターフェイスの簡単な学習と効率的な操作を容易にすることを目的として、共通の規則を一貫して組み込んでいます。

For a web page to be accessible, all interactive elements must be operable via the keyboard. In addition, consistent application of the common GUI keyboard interface conventions described in the ARIA design patterns is important, especially for assistive technology users. Consider, for example, a screen reader user operating a tree. Just as familiar visual styling helps users discover how to expand a tree branch with a mouse, ARIA attributes give the tree the sound and feel of a tree in a desktop application. So, screen reader users will commonly expect that pressing the right arrow key will expand a collapsed node. Because the screen reader knows the element is a tree, it also has the ability to instruct a novice user how to operate it. Similarly, voice recognition software can implement commands for expanding and collapsing branches because it recognizes the element as a tree and can execute appropriate keyboard commands. All this is only possible if the tree implements the GUI keyboard conventions as described in the ARIA tree pattern.
ウェブページにアクセスするには、すべてのインタラクティブな要素がキーボードを介して操作可能である必要があります。 さらに、ARIA デザインパターンで説明されている一般的な GUI キーボードインターフェイス規則を一貫して適用することは、特に支援技術のユーザーにとって重要です。 例えば、ツリーを操作しているスクリーンリーダーユーザーについて考えてみます。 使い慣れた視覚的なスタイルが、ユーザーがマウスでツリーの枝を拡張する方法を発見するのに役立つのと同じように、ARIA 属性は、デスクトップアプリケーションでツリーに音と感触を与えます。 そのため、スクリーンリーダーのユーザーは通常、右矢印キーを押すと折りたたまれたノードが展開されることを期待します。 スクリーンリーダーは要素がツリーであることを認識しているため、初心者ユーザーに操作方法を指示することもできます。 同様に、音声認識ソフトウェアは、要素をツリーとして認識し、適切なキーボードコマンドを実行できるため、枝を展開および折りたたむためのコマンドを実装できます。 これはすべて、ツリーが ARIA ツリーのパターンで説明されている GUI キーボード規則を実装している場合にのみ可能です。

A primary keyboard navigation convention common across all platforms is that the tab and shift+tab keys move focus from one UI component to another while other keys, primarily the arrow keys, move focus inside of components that include multiple focusable elements. The path that the focus follows when pressing the tab key is known as the tab sequence or tab ring.
すべてのプラットフォームに共通する主要なキーボードナビゲーション規則は、Tab キーと Shift + Tab キーで、ある UI コンポーネントから別のコンポーネントにフォーカスを移動し、他のキー、主に矢印キーで、複数のフォーカス可能な要素を含むコンポーネント内でフォーカスを移動することです。 Tab キーを押したときにフォーカスがたどるパスは、タブシーケンスまたはタブリングと呼ばれます。

Common examples of UI components that contain multiple focusable elements are radio groups, tablists, menus, and grids. A radio group, for example, contains multiple radio buttons, each of which is focusable. However, only one of the radio buttons is included in the tab sequence. After pressing the Tab key moves focus to a radio button in the group, pressing arrow keys moves focus among the radio buttons in the group, and pressing the Tab key moves focus out of the radio group to the next element in the tab sequence.
複数のフォーカス可能な要素を含む UI コンポーネントの一般的な例は、ラジオグループ、タブリスト、メニュー、およびグリッドです。 例えば、ラジオグループには複数のラジオボタンがあり、それぞれにフォーカスがあります。 ただし、タブシーケンスに含まれるラジオボタンは1つだけです。 Tab キーを押すと、フォーカスがグループ内のラジオボタンに移動し、矢印キーを押すと、グループ内のラジオボタン間でフォーカスが移動し、Tab キーを押すと、ラジオグループからタブシーケンスの次の要素にフォーカスが移動します。

The ARIA specification refers to a discrete UI component that contains multiple focusable elements as a composite widget. The process of controlling focus movement inside a composite is called managing focus. Following are some ARIA design patterns with example implementations that demonstrate focus management:
ARIA 仕様は、複合ウィジェットとして複数のフォーカス可能な要素を含む個別の UI コンポーネントを参照しています。 複合ウィジェット内のフォーカスの動きを制御するプロセスは、フォーカスの管理と呼ばれます。 以下は、フォーカス管理を示す実装例を含むいくつかの ARIA デザインパターンです。

    Combobox
    コンボボックス

    Grid
    グリッド

    Listbox
    リストボックス

    Menu or menu bar
    メニューまたはメニューバー

    Radiogroup
    ラジオグループ

    Tabs
    タブ

    Toolbar
    ツールバー

    Tree Grid
    ツリーグリッド

    Tree View
    ツリービュー





6.2 Discernible and Predictable Keyboard Focus
6.2 識別可能で予測可能なキーボードフォーカス

Work to complete this section is tracked by issue 217.
このセクションを完了するための作業は、issue 217 によって追跡されます。

When operating with a keyboard, two essentials of a good experience are the abilities to easily discern the location of the keyboard focus and to discover where focus landed after a navigation key has been pressed. The following factors affect to what extent a web page affords users these capabilities.
キーボードを使用して操作する場合、優れたエクスペリエンスの2つの重要な要素は、キーボードフォーカスの場所を簡単に識別し、ナビゲーションキーを押した後にフォーカスがどこにあるのかを発見する能力です。 次の要因は、ウェブページがユーザーにこれらの能力をどの程度提供するかに影響します。

    Visibility of the focus indicator: Users need to be able to easily distinguish the keyboard focus indicator from other features of the visual design. Just as a mouse user may move the mouse to help find the mouse pointer, a keyboard user may press a navigation key to watch for movement. If visual changes in response to focus movement are subtle, many users will lose track of focus and be unable to operate. Authors are advised to rely on the default focus indicators provided by browsers. If overriding the default, consider:
    1. フォーカスインジケーターの可視性：ユーザーは、キーボードのフォーカスインジケーターをビジュアルデザインの他の機能と簡単に区別できる必要があります。 マウスユーザーがマウスを動かしてマウスポインターを見つけるのと同じように、キーボードユーザーはナビゲーションキーを押して動きを監視できます。 フォーカスの動きに応じた視覚的な変化が微妙な場合、多くのユーザーはフォーカスを追跡できなくなり、操作できなくなります。 作成者は、ブラウザーが提供するデフォルトのフォーカスインジケーターに依存することをお勧めします。 デフォルトをオーバーライドする場合は、次のことを考慮してください。

        something about ... Colors and gradients can disappear in high contrast modes.
        何かについて ... 色とグラデーションは高コントラストモードで消えることがあります。

        Users need to be able to easily distinguish between focus and selection as described in § 6.3 Focus VS Selection and the Perception of Dual Focus, especially when a component that contains selected elements does not contain the focus.
        ユーザーは、特に選択された要素を含むコンポーネントにフォーカスが含まれていない場合、§6.3 フォーカス VS 選択とデュアルフォーカスの認識で説明されているように、フォーカスと選択を簡単に区別できる必要があります。

        ... other considerations to be added ...
        ... 追加するその他の考慮事項 ...

    Persistence of focus: It is essential that there is always a component within the user interface that is active (document.activeElement is not null or is not the body element) and that the active element has a visual focus indicator. Authors need to manage events that effect the currently active element so focus remains visible and moves logically. For example, if the user closes a dialog or performs a destructive operation like deleting an item from a list, the active element may be hidden or removed from the DOM. If such events are not managed to set focus on the button that triggered the dialog or on the list item following the deleted item, browsers move focus to the body element, effectively causing a loss of focus within the user interface.
    2. フォーカスの持続性：ユーザーインターフェイス内にアクティブなコンポーネントが常に存在し（document.activeElement が null でないか、ボディ要素ではない）、アクティブな要素に視覚的なフォーカスインジケーターがあることが重要です。 作成者は、現在アクティブな要素に影響を与えるイベントを管理して、フォーカスが可視のままで論理的に移動するようにする必要があります。 例えば、ユーザーがダイアログを閉じたり、リストから項目を削除するなどの破壊的な操作を実行したりすると、アクティブな要素が非表示になるか、DOM から削除される可能性があります。 そのようなイベントが、ダイアログをトリガーしたボタンまたは削除された項目に続くリスト項目にフォーカスを設定するように管理されていない場合、ブラウザーはフォーカスをボディ要素に移動し、ユーザーインターフェイス内のフォーカスを事実上失います。

    Predictability of movement: Usability of a keyboard interface is heavily influenced by how readily users can guess where focus will land after a navigation key is pressed. Some possible approaches to optimizing predictability include:
    3. 動きの予測可能性：キーボードインターフェイスの使いやすさは、ナビゲーションキーが押された後、フォーカスがどこに到達するかをユーザーがどれだけ簡単に推測できるかに大きく影響されます。 予測可能性を最適化するためのいくつかの可能なアプローチは次のとおりです。

        Move focus in a pattern that matches the reading order of the page's language. In left to right languages, for example, create a tab sequence that moves focus left to right and then top to bottom.
        ページの言語の読み順に一致するパターンでフォーカスを移動します。 例えば、左から右の言語では、フォーカスを左から右に移動し、次に上から下に移動するタブシーケンスを作成します。

        Incorporate all elements of a section of the page in the tab sequence before moving focus to another section. For instance, in a page with multiple columns that has content in a left side bar, center region, and right side bar, build a tab sequence that covers all elements in the left sidebar before focus moves to the first focusable element in the center column.
        フォーカスを別のセクションに移動する前に、ページのセクションのすべての要素をタブシーケンスに組み込みます。 例えば、左側のサイドバー、中央のリージョン、右側のサイドバーにコンテンツがある複数の列があるページでは、フォーカスが中央の列の最初のフォーカス可能な要素に移動する前に、左側のサイドバーのすべての要素をカバーするタブシーケンスを作成します。

        When the distance between two consecutive elements in the tab sequence is significant, avoid movement that would be perceived as backward. For example, on a page with a left to right language, a jump from the last element in the bottom right of the main content to the top element in a left-hand sidebar is likely to be less predictable and more difficult to follow, especially for users with a narrow field of view.
        タブシーケンス内の2つの連続する要素間の距離が大きい場合は、後ろ向きに認識されるような動きを避けてください。 例えば、左から右の言語のページでは、メインコンテンツの右下の最後の要素から左側のサイドバーの一番上の要素へのジャンプは、特に視野が狭いユーザーにとっては、予測が難しく、追跡が難しい可能性があります。

        Follow consistent patterns across a site. The keyboard experience is more predictable when similar pages have similar focus movement patterns.
        サイト全体で一貫したパターンに従います。 同様のページに同様のフォーカス移動パターンがある場合、キーボードエクスペリエンスはより予測可能です。

        Do not set initial focus when the page loads except in cases where:
        次の場合を除いて、ページの読み込み時に初期フォーカスを設定しないでください。

            The page offers a single, primary function that nearly all users employ immediately after page load.
            そのページは、ほぼすべてのユーザーがページの読み込み直後に使用する単一の主要な機能を提供します。

            Any given user is likely to use the page often.
            どのようなユーザーでも、そのページを頻繁に使用する可能性があります。





6.3 Focus VS Selection and the Perception of Dual Focus
6.3 フォーカス VS 選択とデュアルフォーカスの認識

Occasionally, it may appear as if two elements on the page have focus at the same time. For example, in a multi-select list box, when an option is selected it may be greyed. Yet, the focus indicator can still be moved to other options, which may also be selected. Similarly, when a user activates a tab in a tablist, the selected state is set on the tab and its visual appearance changes. However, the user can still navigate, moving the focus indicator elsewhere on the page while the tab retains its selected appearance and state.
場合によっては、ページ上の2つの要素に同時にフォーカスがあるように見えることがあります。 例えば、複数選択リストボックスで、オプションを選択すると、灰色で表示される場合があります。 それでも、フォーカスインジケーターは他のオプションに移動することができ、それらも選択できます。 同様に、ユーザーがタブリストのタブをアクティブ化すると、選択された状態がタブに設定され、その外観が変化します。 ただし、タブが選択された外観と状態を保持している間、ユーザーは引き続きナビゲートして、フォーカスインジケーターをページ上の別の場所に移動できます。

Focus and selection are quite different. From the keyboard user's perspective, focus is a pointer, like a mouse pointer; it tracks the path of navigation. There is only one point of focus at any time and all operations take place at the point of focus. On the other hand, selection is an operation that can be performed in some widgets, such as list boxes, trees, and tablists. If a widget supports only single selection, then only one item can be selected and very often the selected state will simply follow the focus when focus is moved inside of the widget. That is, in some widgets, moving focus may also perform the select operation. However, if the widget supports multiple selection, then more than one item can be in a selected state, and keys for moving focus do not perform selection. Some multi-select widgets do support key commands that both move focus and change selection, but those keys are different from the normal navigation keys. Finally, when focus leaves a widget that includes a selected element, the selected state persists.
フォーカスと選択はかなり異なります。 キーボードユーザーの観点からは、フォーカスはマウスポインターのようなポインターです。 それは、ナビゲーションのパスを追跡します。 フォーカス先は常に1つだけであり、すべての操作はフォーカス先で行われます。 一方、選択は、リストボックス、ツリー、タブリストなどの一部のウィジェットで実行できる操作です。 ウィジェットが単一選択のみをサポートしている場合、選択できる項目は1つだけであり、多くの場合、選択された状態は、フォーカスがウィジェット内で移動されたときにフォーカスに従うだけです。 つまり、一部のウィジェットでは、フォーカスを移動すると選択操作も実行される場合があります。 ただし、ウィジェットが複数選択をサポートしている場合は、複数の項目が選択された状態になる可能性があり、フォーカスを移動するためのキーは選択を実行しません。 一部の複数選択ウィジェットは、フォーカスの移動と選択の変更の両方を行うキーコマンドをサポートしていますが、これらのキーは通常のナビゲーションキーとは異なります。 最後に、フォーカスが選択された要素を含むウィジェットを離れると、選択された状態が持続します。

From the developer's perspective, the difference is simple -- the focused element is the active element (document.activeElement). Selected elements are elements that have aria-selected="true".
開発者の観点からは、違いは単純です。 フォーカスされた要素はアクティブな要素（document.activeElement）です。 選択された要素は、aria-selected="true" を持つ要素です。

With respect to focus and the selected state, the most important considerations for designers and developers are:
フォーカスと選択された状態に関して、設計者と開発者にとって最も重要な考慮事項は次のとおりです。

    The visual focus indicator must always be visible.
    視覚的なフォーカスインジケーターは常に可視でいる必要があります。

    The selected state must be visually distinct from the focus indicator.
    選択された状態は、フォーカスインジケーターと視覚的に区別できる必要があります。





6.4 Deciding When to Make Selection Automatically Follow Focus
6.4 フォーカスに従って自動的に選択を行うかの決定

in composite widgets where only one element may be selected, such as a tablist or single-select listbox, moving the focus may also cause the focused element to become the selected element. This is called having selection follow focus. Having selection follow focus is often beneficial to users, but in some circumstances, it is extremely detrimental to accessibility.
タブリストや単一選択リストボックスなど、1つの要素のみを選択できる複合ウィジェットでは、フォーカスを移動すると、フォーカスされた要素が選択された要素になる場合もあります。 これは、選択はフォーカスに従うと呼ばれます。 選択をフォーカスに従わせることは、多くの場合ユーザーにとって有益ですが、状況によっては、アクセシビリティに非常に悪影響を及ぼします。

For example, in a tablist, the selected state is used to indicate which panel is displayed. So, when selection follows focus in a tablist, moving focus from one tab to another automatically changes which panel is displayed. If the content of panels is present in the DOM, then displaying a new panel is nearly instantaneous. A keyboard user who wishes to display the fourth of six tabs can do so with 3 quick presses of the right arrow. And, a screen reader user who perceives the labels on tabs by navigating through them may efficiently read through the complete list without any latency.
例えば、タブリストでは、選択された状態を使用して、表示されるパネルを示します。 したがって、選択がタブリストのフォーカスに従う場合、フォーカスをあるタブから別のタブに移動すると、表示されるパネルが自動的に変更されます。 パネルのコンテンツが DOM に存在する場合、新しいパネルの表示はほぼ瞬時に行われます。 6つのタブのうち4番目を表示したいキーボードユーザーは、右矢印を3回すばやく押すことで表示できます。 また、タブ内をナビゲートしていくことでタブのラベルを認識するスクリーンリーダーのユーザーは、待ち時間なしで完全なリストを効率的に読み進めることができます。

However, if displaying a new panel causes a network request and possibly a page refresh, the effect of having selection automatically focus can be devastating to the experience for keyboard and screen reader users. In this case, displaying the fourth tab or reading through the list becomes a tedious and time-consuming task as the user experiences significant latency with each movement of focus. Further, if displaying a new tab refreshes the page, then the user not only has to wait for the new page to load but also return focus to the tab list.
ただし、新しいパネルを表示するとネットワーク要求が発生し、場合によってはページが更新される場合、フォーカスで選択を自動的に行うことの影響は、キーボードおよびスクリーンリーダーのユーザーのエクスペリエンスに壊滅的な影響を与える可能性があります。 この場合、4番目のタブを表示したり、リストを読み進めたりすることは、ユーザーがフォーカスを移動するたびにかなりの遅延が発生するため、面倒で時間のかかる作業になります。 さらに、新しいタブを表示するとページが更新される場合、ユーザーは新しいページが読み込まれるのを待つだけでなく、タブリストにフォーカスを戻す必要があります。

When selection does not follow focus, the user changes which element is selected by pressing the Enter or Space key.
選択がフォーカスに従わない場合、ユーザーは Enter キーまたはスペースキーを押して選択された要素を変更します。




6.5 Keyboard Navigation Between Components (The Tab Sequence)
6.5 コンポーネント間のキーボードナビゲーション（タブシーケンス）

As explained in section § 6.1 Fundamental Keyboard Navigation Conventions, all interactive UI components need to be reachable via the keyboard. This is best achieved by either including them in the tab sequence or by making them accessible from a component that is in the tab sequence, e.g., as part of a composite component. This section addresses building and managing the tab sequence, and subsequent sections cover making focusable elements that are contained within components keyboard accessible.
セクション§6.1 基本的なキーボードナビゲーション規則で説明されているように、すべてのインタラクティブな UI コンポーネントはキーボードを介して到達可能である必要があります。 これは、それらをタブシーケンスに含めるか、タブシーケンス内のコンポーネントから（例えば、複合ウィジェットのコンポーネントの一部として）アクセスできるようにすることで最もよく実現されます。 このセクションでは、タブシーケンスの構築と管理について説明し、後続のセクションでは、コンポーネントに含まれるフォーカス可能な要素をキーボードでアクセス可能にする方法について説明します。

The [HTML] tabindex and [SVG2] tabindex attributes can be used to add and remove elements from the tab sequence. The value of tabindex can also influence the order of the tab sequence, although authors are strongly advised not to use tabindex for that purpose.
[HTML] タブインデックス（tabindex）属性と [SVG2] タブインデックス属性を使用して、タブシーケンスの要素を追加および削除できます。 タブインデックスの値もタブシーケンスの順序に影響を与える可能性がありますが、作成者はその目的でタブインデックスを使用しないことを強くお勧めします。

In HTML, the default tab sequence of a web page includes only links and HTML form elements, except In macOS, where it includes only form elements. macOS system preferences include a keyboard setting that enables the tab key to move focus to all focusable elements.
HTML では、ウェブページのデフォルトのタブシーケンスにはリンクと HTML フォーム要素のみが含まれます。 ただし、macOS ではフォーム要素のみが含まれます。 macOS システム環境設定には、Tab キーでフォーカス可能なすべての要素にフォーカスを移動できるようにするキーボード設定が含まれています。

The default order of elements in the tab sequence is the order of elements in the DOM. The DOM order also determines screen reader reading order. It is important to keep the keyboard tab sequence and the screen reader reading order aligned, logical, and predictable as described in § 6.2 Discernible and Predictable Keyboard Focus. The most robust method of manipulating the order of the tab sequence while also maintaining alignment with the reading order that is currently available in all browsers is rearranging elements in the DOM.
タブシーケンス内の要素のデフォルトの順序は、DOM 内の要素の順序です。 DOM の順序によって、スクリーンリーダーの読み順も決まります。 §6.2 識別可能で予測可能なキーボードフォーカスで説明されているように、キーボードのタブシーケンスとスクリーンリーダーの読み順を揃え、論理的で、予測可能に保つことが重要です。 現在すべてのブラウザーで使用可能な読み順との整合性を維持しながら、タブシーケンスの順序を操作する最も堅牢な方法は、DOM 内の要素を再配置することです。

The values of the tabindex attribute have the following effects.
タブインデックス属性の値には、次の効果があります。

tabindex is not present or does not have a valid value
タブインデックスが存在しないか、有効な値がない

    The element has its default focus behavior. In HTML, only form controls and anchors with an HREF attribute are included in the tab sequence. 
    要素にはデフォルトのフォーカスの振る舞いがあります。 HTML では、フォームコントロールと HREF 属性を持つアンカーのみがタブシーケンスに含まれます。

tabindex="0"

    The element is included in the tab sequence based on its position in the DOM.
    要素は、DOM 内の位置に基づいてタブシーケンスに含まれます。

tabindex="-1"

    The element is not included in the tab sequence but is focusable with element.focus().
    要素はタブシーケンスに含まれていませんが、element.focus() でフォーカスできます。

tabindex="X" where X is an integer in the range 1 <= X <= 32767
tabindex="X"（X は 1 <= X <= 32767 の範囲の整数）

    Authors are strongly advised NOT to use these values. The element is placed in the tab sequence based on the value of tabindex. Elements with a tabindex value of 0 and elements that are focusable by default will be in the sequence after elements with a tabindex value of 1 or greater. 
    作成者は、これらの値を使用しないことを強くお勧めします。 要素は、タブインデックスの値に基づいてタブシーケンスに配置されます。 タブインデックス値が 0 の要素とデフォルトでフォーカス可能な要素は、タブインデックス値が 1 以上の要素の後の順序になります。





6.6 Keyboard Navigation Inside Components
6.6 コンポーネント内のキーボードナビゲーション

As described in section § 6.1 Fundamental Keyboard Navigation Conventions, the tab sequence should include only one focusable element of a composite UI component. Once a composite contains focus, keys other than Tab and Shift + Tab enable the user to move focus among its focusable elements. Authors are free to choose which keys move focus inside of a composite, but they are strongly advised to use the same key bindings as similar components in common GUI operating systems as demonstrated in § 3. Design Patterns and Widgets.
セクション §6.1 基本的なキーボードナビゲーション規則で説明されているように、タブシーケンスには、複合ウィジェットの UI コンポーネントのフォーカス可能な要素を1つだけ含める必要があります。 複合ウィジェットにフォーカスが含まれると、Tab キーおよび Shift + Tab キー以外のキーを使用して、ユーザーはフォーカス可能な要素間でフォーカスを移動できます。 作成者は、複合ウィジェット内でフォーカスを移動するキーを自由に選択できますが、§3. デザインパターンとウィジェットに示されているように、一般的な GUI オペレーティングシステムの同様のコンポーネントと同じキーバインディングを使用することを強くお勧めします。

The convention for where focus lands in a composite when it receives focus as a result of a Tab key event depends on the type of composite. It is typically one of the following.
Tab キーイベントの結果としてフォーカスを受け取ったときにフォーカスが複合ウィジェットに到達する場所の規則は、複合ウィジェットのタイプによって異なります。 通常、それは次のいずれかです。

    The element that had focus the last time the composite contained focus. Or, if the composite has not yet contained the focus, the first element. Widgets that usually employ this pattern include grid and tree grid.
    複合ウィジェットに最後にフォーカスが含まれたときにフォーカスがあった要素。 あるいは、複合ウィジェットにまだフォーカスが含まれていない場合は、最初の要素。 通常このパターンを使用するウィジェットには、グリッドとツリーグリッドが含まれます。

    The selected element. Or, if there is no selected element, the first element. Widgets where this pattern is commonly implemented include radio groups, tabs, list boxes, and trees. Note: For radio groups, this pattern is referring to the checked radio button; the selected state is not supported for radio buttons.
    選択された要素。 あるいは、選択された要素がない場合は、最初の要素。 このパターンが一般的に実装されるウィジェットには、ラジオグループ、タブ、リストボックス、およびツリーが含まれます。 注：ラジオグループの場合、このパターンはチェックされたラジオボタンを参照しています。 選択された状態は、ラジオボタンではサポートされていません。

    The first element. Components that typically follow this pattern include menubars and toolbars.
    最初の要素。 通常、このパターンに従うコンポーネントには、メニューバーとツールバーが含まれます。

The following sections explain two strategies for managing focus inside composite elements: creating a roving tabindex and using the aria-activedescendant property.
次のセクションでは、複合ウィジェット要素内のフォーカスを管理するための2つの戦略について説明します。 動き回るタブインデックスの作成と aria-activedescendant プロパティの使用です。




6.6.1 Managing Focus Within Components Using a Roving tabindex
6.6.1 動き回るタブインデックスを使用したコンポーネント内のフォーカスの管理

When using roving tabindex to manage focus in a composite UI component, the element that is to be included in the tab sequence has tabindex of "0" and all other focusable elements contained in the composite have tabindex of "-1". The algorithm for the roving tabindex strategy is as follows.
動き回るタブインデックスを使用して複合ウィジェットの UI コンポーネントのフォーカスを管理する場合、タブシーケンスに含まれる要素のタブインデックスは "0" であり、複合ウィジェットに含まれる他のすべてのフォーカス可能な要素のタブインデックスは "-1" です。 動き回るタブインデックス戦略のアルゴリズムは次のとおりです。

    When the component container is loaded or created, set tabindex="0" on the element that will initially be included in the tab sequence and set tabindex="-1" on all other focusable elements it contains.
    コンポーネントコンテナーが読み込みまたは作成されたら、最初にタブシーケンスに含まれる要素に tabindex="0" を設定し、それに含まれる他のすべてのフォーカス可能な要素に tabindex="-1" を設定します。

    When the component contains focus and the user presses a navigation key that moves focus within the component, such as an arrow key:
    コンポーネントにフォーカスが含まれていて、ユーザーが矢印キーなどのコンポーネント内でフォーカスを移動するナビゲーションキーを押すと、次のようになります。

        set tabindex="-1" on the element that has tabindex="0".
        tabindex="0" を持つ要素に tabindex="-1" を設定します。

        Set tabindex="0" on the element that will become focused as a result of the key event.
        キーイベントの結果としてフォーカスされる要素に tabindex="0" を設定します。

        Set focus, element.focus(), on the element that has tabindex="0".
        tabindex="0" を持つ要素に element.focus() でフォーカスを設定します。

    If the design calls for a specific element to be focused the next time the user moves focus into the composite with Tab or Shift+Tab, check if that target element has tabindex="0" when the composite loses focus. If it does not, set tabindex="0" on the target element and set tabindex="-1" on the element that previously had tabindex="0".
    次回ユーザーが Tab キーまたは Shift + Tab キーを使用して複合ウィジェットにフォーカスを移動したときに特定の要素にフォーカスする必要がある場合は、複合ウィジェットがフォーカスを失ったときにそのターゲット要素に tabindex="0" があるかどうかを確認します。 そうでない場合は、ターゲット要素に tabindex="0" を設定し、以前に tabindex="0" を持っていた要素に tabindex="-1" を設定します。

One benefit of using roving tabindex rather than aria-activedescendant to manage focus is that the user agent will scroll the newly focused element into view.
aria-activedescendant ではなく動き回るタブインデックスを使用してフォーカスを管理する利点の1つは、ユーザーエージェントが新しくフォーカスされた要素をスクロールして表示することです。




6.6.2 Managing Focus in Composites Using aria-activedescendant
6.6.2 aria-activedescendant を使用した複合ウィジェットでのフォーカスの管理

If a component container has an ARIA role that supports the aria-activedescendant property, it is not necessary to manipulate the tabindex attribute and move DOM focus among focusable elements within the container. Instead, only the container element needs to be included in the tab sequence. When the container has DOM focus, the value of aria-activedescendant on the container tells assistive technologies which element is active within the widget. Assistive technologies will consider the element referred to as active to be the focused element even though DOM focus is on the element that has the aria-activedescendant property. And, when the value of aria-activedescendant is changed, assistive technologies will receive focus change events equivalent to those received when DOM focus actually moves.
コンポーネントコンテナーに aria-activedescendant プロパティをサポートする ARIA ロールがある場合、タブインデックス属性を操作したり、コンテナー内のフォーカス可能な要素間で DOM フォーカスを移動したりする必要はありません。 代わりに、コンテナー要素のみをタブシーケンスに含める必要があります。 コンテナーに DOM フォーカスがある場合、コンテナーの aria-activedescendant の値は、ウィジェット内でアクティブな要素を支援技術に通知します。 支援技術は、DOM フォーカスが aria-activedescendant プロパティを持つ要素にある場合でも、アクティブとして参照される要素をフォーカスされた要素と見なします。 また、aria-activedescendant の値が変更されると、支援技術は、DOM フォーカスが実際に移動したときに受信したものと同等のフォーカス変更イベントを受信します。

The steps for using the aria-activedescendant method of managing focus are as follows.
フォーカスを管理するための aria-activedescendant の方法を使用する手順は次のとおりです。

    When the container element that has a role that supports aria-activedescendant is loaded or created, ensure that:
    aria-activedescendant をサポートするロールを持つコンテナー要素が読み込みまたは作成されるときは、次のことを確認してください。

        The container element is included in the tab sequence as described in § 6.5 Keyboard Navigation Between Components (The Tab Sequence) or is a focusable element of a composite that implements a roving tabindex.
        コンテナー要素は、§6.5 コンポーネント間のキーボードナビゲーション（タブシーケンス）で説明されているようにタブシーケンスに含まれるか、動き回るタブインデックスを実装する複合ウィジェットのフォーカス可能な要素です。

        It has aria-activedescendant="IDREF" where IDREF is the ID of the element within the container that should be identified as active when the widget receives focus. The referenced element needs to meet the DOM relationship requirements described below.
        aria-activedescendant="IDREF" があります。 ここで、IDREF は、ウィジェットがフォーカスを受け取ったときにアクティブとして識別される必要があるコンテナー内の要素の ID です。 参照される要素は、以下で説明する DOM 関係の要件を満たす必要があります。

    When the container element receives DOM focus, draw a visual focus indicator on the active element and ensure the active element is scrolled into view.
    コンテナー要素が DOM フォーカスを受け取ったら、アクティブな要素に視覚的なフォーカスインジケーターを描画し、アクティブな要素がスクロールして表示されることを確認します。

    When the composite widget contains focus and the user presses a navigation key that moves focus within the widget, such as an arrow key:
    複合ウィジェットにフォーカスが含まれていて、ユーザーが矢印キーなど、ウィジェット内でフォーカスを移動するナビゲーションキーを押すと、次のようになります。

        Change the value of aria-activedescendant on the container to refer to the element that should be reported to assistive technologies as active.
        コンテナーの aria-activedescendant の値を変更して、支援技術にアクティブとして報告する必要がある要素を参照します。

        Move the visual focus indicator and, if necessary, scrolled the active element into view.
        視覚的なフォーカスインジケーターを移動し、必要に応じて、アクティブな要素をスクロールして表示します。

    If the design calls for a specific element to be focused the next time a user moves focus into the composite with Tab or Shift+Tab, check if aria-activedescendant is referring to that target element when the container loses focus. If it is not, set aria-activedescendant to refer to the target element.
    次にユーザーが Tab キーまたは Shift + Tab キーを使用して複合ウィジェットにフォーカスを移動したときに特定の要素にフォーカスする必要がある場合は、コンテナーがフォーカスを失ったときに aria-activedescendant がそのターゲット要素を参照しているかどうかを確認します。 そうでない場合は、ターゲット要素を参照するように aria-activedescendant を設定します。

The specification for aria-activedescendant places important restrictions on the DOM relationship between the focused element that has the aria-activedescendant attribute and the element referenced as active by the value of the attribute. One of the following three conditions must be met.
aria-activedescendant の仕様は、aria-activedescendant 属性を持つフォーカスされた要素と、属性の値によってアクティブとして参照される要素との間の DOM 関係に重要な制限を課します。 次の3つの条件のいずれかが満たされている必要があります。

    The element referenced as active is a DOM descendant of the focused referencing element.
    1. アクティブとして参照される要素は、フォーカスされた参照している要素の DOM 子孫です。

    The focused referencing element has a value specified for the aria-owns property that includes the ID of the element referenced as active.
    2. フォーカスされた参照している要素には、アクティブとして参照された要素の ID を含む aria-owns プロパティに指定された値があります。

    The focused referencing element has role of textbox and has aria-controls property referring to an element with a role that supports aria-activedescendant and either:
    3. フォーカスされた参照している要素にはテキストボックスロールがあり、aria-activedescendant と次のどちらかをサポートするロールを持つ要素を参照する aria-controls プロパティがあります。

        The element referenced as active is a descendant of the controlled element.
        1. アクティブとして参照される要素は、（訳注：aria-controls プロパティが参照する）制御される要素の子孫です。

        The controlled element has a value specified for the aria-owns property that includes the ID of the element referenced as active.
        2. 制御される要素には、アクティブとして参照される要素の ID を含む aria-owns プロパティに指定された値があります。





6.7 Focusability of disabled controls
6.7 無効化されたコントロールのフォーカス可能性

By default, disabled HTML input elements are removed from the tab sequence. In most contexts, the normal expectation is that disabled interactive elements are not focusable. However, there are some contexts where it is common for disabled elements to be focusable, especially inside of composite widgets. For example, as demonstrated in the § 3.15 Menu or Menu bar pattern, disabled items are focusable when navigating through a menu with the arrow keys.
デフォルトでは、無効化されている HTML 入力要素はタブシーケンスから削除されます。 ほとんどの場合、通常の予想では、無効化されているインタラクティブな要素はフォーカスできません。 ただし、特に複合ウィジェット内で、無効化された要素がフォーカス可能であることが一般的であるコンテキストがいくつかあります。 例えば、§3.15 メニューやメニューバーのパターンに示されているように、矢印キーを使用してメニューをナビゲートしていくことで、無効化されている項目にフォーカスできます。

Removing focusability from disabled elements can offer users both advantages and disadvantages. Allowing keyboard users to skip disabled elements usually reduces the number of key presses required to complete a task. However, preventing focus from moving to disabled elements can hide their presence from screen reader users who "see" by moving the focus.
無効化されている要素からフォーカス可能性を取り除くと、ユーザーに長所と短所の両方を提供できます。 キーボードユーザーが無効化された要素をスキップできるようにすると、通常、タスクを完了するために必要なキーを押す回数が減ります。 ただし、フォーカスが無効化された要素に移動しないようにすると、フォーカスを移動して「見る」スクリーンリーダーユーザーからその存在を隠してしまうかもしれません。

Authors are encouraged to adopt a consistent set of conventions for the focusability of disabled elements. The examples in this guide adopt the following conventions, which both reflect common practice and attempt to balance competing concerns.
作成者は、無効化された要素のフォーカス可能性について一貫した一連の規則を採用することをお勧めします。 このガイドの例では、次の規則を採用しています。 これらの規則は、一般的な方法を反映し、競合する懸念とのバランスを取ることを目的としています。

    For elements that are in the tab sequence when enabled, remove them from the tab sequence when disabled.
    1. 有効化するとタブシーケンスに含まれる要素については、無効化するとタブシーケンスから取り除かれます。

    For the following composite widget elements, keep them focusable when disabled:
    2. 次の複合ウィジェット要素については、無効化したときにフォーカス可能にしてください。

        Options in a Listbox
        リストボックスのオプション

        Menu items in a Menu or menu bar
        メニューまたはメニューバーのメニュー項目

        Tab elements in a set of Tabs
        一連のタブ内のタブ要素

        Tree items in a Tree View
        ツリービューのツリー項目

    For elements contained in a toolbar, make them focusable if discoverability is a concern. Here are two examples to aid with this judgment.
    3. ツールバーに含まれる要素について、発見可能性が懸念される場合は、それらをフォーカス可能にします。 この判断に役立つ2つの例を次に示します。

        A toolbar with buttons for moving, removing, and adding items in a list includes buttons for "Up", "Down", "Add", and "Remove". The "Up" button is disabled and its focusability is removed when the first item in the list is selected. Given the presence of the "Down" button, discoverability of the "Up" button is not a concern.
        1. リスト内の項目を移動、削除、および追加するためのボタンを備えたツールバーには、「上へ」、「下へ」、「追加」、および「削除」のボタンが含まれています。 リストの最初の項目を選択すると、「上へ」ボタンが無効化され、フォーカス機能が取り除かれます。 「下へ」ボタンの存在を考えると、「上へ」ボタンの発見可能性が懸念されることはありません。

        A toolbar in an editor contains a set of special smart paste functions that are disabled when the clipboard is empty or when the function is not applicable to the current content of the clipboard. It could be helpful to keep the disabled buttons focusable if the ability to discover their functionality is primarily via their presence on the toolbar.
        2. エディターのツールバーには、クリップボードが空の場合、またはクリップボードの現在のコンテンツに機能が適用できない場合に無効化される特別なスマート貼り付け機能のセットが含まれています。 それらの機能を発見する能力が主にツールバー上のそれらの存在を介している場合、無効化されたボタンをフォーカス可能に保つことは役に立つかもしれません。

One design technique for mitigating the impact of including disabled elements in the path of keyboard focus is employing appropriate keyboard shortcuts as described in § 6.9 Keyboard Shortcuts.
キーボードフォーカスのパスに無効化された要素を含めることの影響を軽減するための1つの設計手法は、§6.9 キーボードショートカットで説明されている適切なキーボードショートカットを使用することです。




6.8 Key Assignment Conventions for Common Functions
6.8 共通機能のキー割り当て規則

The following key assignments can be used in any context where their conventionally associated functions are appropriate. While the assignments associated with Windows and Linux platforms can be implemented and used in browsers running in macOS, replacing them with macOS assignments in browsers running on a macOS device can make the keyboard interface more discoverable and intuitive for those users. In some cases, it may also help avoid system or browser keyboard conflicts.
以下のキー割り当ては、従来の関連機能が適切である任意のコンテキストで使用できます。 Windows および Linux プラットフォームに関連付けられた割り当ては、macOS で実行されているブラウザーで実装および使用できますが、macOS デバイスで実行されているブラウザーで macOS 割り当てに置き換えると、それらのユーザーにとってキーボードインターフェイスをより見つけやすく直感的にすることができます。 場合によっては、システムまたはブラウザーのキーボードの競合を回避するのにも役立つことがあります。

Function 	Windows/Linux Key 	macOS Key
機能 	Windows / Linux キー 	macOS キー 

open context menu 	Shift + F10 	
コンテキストメニューを開く 	Shift + F10 	

Copy to clipboard 	Control + C 	Command + C
クリップボードにコピー 	Control + C 	Command + C

Paste from clipboard 	Control + V 	Command + V
クリップボードから貼り付け 	Control + V 	Command + V

Cut to clipboard 	Control + X 	Command + X
クリップボードに切り取る 	Control + X 	Command + X

undo last action 	Control + Z 	Command + Z
最後のアクションを元に戻す 	Control + Z 	Command + Z

Redo action 	Control + Y 	Command + Shift + Z
アクションのやり直し 	Control + Y 	Command + Shift + Z




6.9 Keyboard Shortcuts
6.9 キーボードショートカット

When effectively designed, keyboard shortcuts that focus an element, activate a widget, or both can dramatically enhance usability of frequently used features of a page or site. This section addresses some of the keyboard shortcut design and implementation factors that most impact their effectiveness, including:
効果的に設計された場合、要素にフォーカスする、ウィジェットをアクティブ化する、またはその両方を行うキーボードショートカットは、ページまたはサイトの頻繁に使用される機能の使いやすさを劇的に向上させることができます。 このセクションでは、キーボードショートカットの設計と実装の要因のうち、その効果に最も影響を与える次のようなものをいくつか取り上げます。

    Understanding how keyboard shortcuts augment a keyboard interface and whether to make a particular shortcut move focus, perform a function, or both.
    キーボードショートカットがキーボードインターフェイスを強化する方法と、特定のショートカットでフォーカスを移動するか、機能を実行するか、またはその両方を行うかを理解します。

    Making key assignments and avoiding assignment conflicts with assistive technologies, browsers, and operating systems.
    キーの割り当てを行い、支援技術、ブラウザー、およびオペレーティングシステムとの割り当ての競合を回避します。

    Exposing and documenting key assignments.
    キーの割り当てを公開して文書化します。 





6.9.1 Designing the Scope and Behavior of Keyboard Shortcuts
6.9.1 キーボードショートカットの範囲と振る舞いの設計

This section explains the following factors when determining which elements and features to assign keyboard shortcuts and what behavior to give each shortcut:
このセクションでは、キーボードショートカットを割り当てる要素と機能、および各ショートカットに与える振る舞いを決定する際の次の要素について説明します。

    Ensuring discovery through navigation; keyboard shortcuts enhance, not replace, standard keyboard access.
    1. ナビゲーションを介した発見の保証。 キーボードショートカットは、標準のキーボードアクセスを置き換えるのではなく、強化します。

    Effectively choosing from among the following behaviors:
    2. 次の振る舞いから効果的なものを選択します。

        Navigation: Moving focus to an element.
        1. ナビゲーション：フォーカスを要素に移動します。

        Activation: Performing an operation associated with an element that does not have focus and might not be visible.
        2. アクティブ化：フォーカスがなく、可視でない可能性のある要素に関連付けられた操作を実行します。

        Navigation and activation: Both moving focus to an element and activating it.
        3. ナビゲーションとアクティブ化：フォーカスを要素に移動することと、要素をアクティブ化することの両方。

    Balancing efficiency and cognitive load: lack of a shortcut can reduce efficiency while too many shortcuts can increase cognitive load and clutter the experience.
    3. 効率と認知的負荷のバランスをとる：ショートカットがないと効率が低下する可能性がありますが、ショートカットが多すぎると認知的負荷が増加し、エクスペリエンスが乱雑になる可能性があります。 





6.9.1.1 Ensure Basic Access Via Navigation
6.9.1.1 ナビゲーションを介した基本的なアクセスの確保

Before assigning keyboard shortcuts, it is essential to ensure the features and functions to which shortcuts may be assigned are keyboard accessible without a keyboard shortcut. In other words, all elements that could be targets for keyboard shortcuts need to be focusable via the keyboard using the methods described in:
キーボードショートカットを割り当てる前に、ショートカットを割り当てることができる機能が、キーボードショートカットなしでキーボードアクセス可能であることを確認することが重要です。 つまり、キーボードショートカットのターゲットになる可能性のあるすべての要素は、次の説明の方法を使用して、キーボードを介してフォーカス可能である必要があります。

    § 6.5 Keyboard Navigation Between Components (The Tab Sequence)
    §6.5 コンポーネント間のキーボードナビゲーション（タブシーケンス）

    § 6.6 Keyboard Navigation Inside Components
    §6.6 コンポーネント内のキーボードナビゲーション

Do not use keyboard shortcuts as a substitute for access via navigation. This is essential to full keyboard access because:
ナビゲーションを介したアクセスの代わりにキーボードショートカットを使用しないでください。 これは、完全なキーボードアクセスに不可欠です。 理由は次のとおりです。

    The primary means of making functions and their shortcuts discoverable is by making the target elements focusable and revealing key assignments on the element itself.
    1. 機能とそのショートカットを検出可能にする主な手段は、ターゲット要素をフォーカス可能にし、要素自体のキー割り当てを明らかにすることです。

    If people who rely on the keyboard have to read documentation to learn which keys are required to use an interface, the interface may technically meet some accessibility standards but in practice is only accessible to the small subset of them who have the knowledge that such documentation exists, have the extra time available, and the ability to retain the necessary information.
    2. キーボードに依存している人がインターフェイスを使用するために必要なキーを学ぶために文書を読む必要がある場合、インターフェイスは技術的にいくつかのアクセシビリティ基準を満たしている可能性がありますが、実際には、そのような文書が存在することを知っていて、余分な時間があり、必要な情報を保持する能力を持っている人のうち、ごく一部の人しかアクセスできません。

    Not all devices that depend on keyboard interfaces can support keyboard shortcuts.
    3. キーボードインターフェイスに依存するすべてのデバイスがキーボードショートカットをサポートできるわけではありません。





6.9.1.2 Choose Appropriate Shortcut Behavior
6.9.1.2 適切なショートカットの振る舞いの選択

The following conventions may help identify the most advantageous behavior for a keyboard shortcut.
次の規則は、キーボードショートカットの最も有利な振る舞いを特定するのに役立つかもしれません。

    Move focus when the primary objective is to make navigation more efficient, e.g., reduce the number of times the user must press Tab or the arrow keys. This behavior is commonly expected when assigning a shortcut to a text box, toolbar, or composite, such as a listbox, tree, grid, or menubar. This behavior is also useful for moving focus to a section of a page, such as the main content or a complementary landmark section.
    主な目的がナビゲーションをより効率的にすることである場合、例えば、ユーザーが Tab キーや矢印キーを押す回数を減らすようにして、フォーカスを移動します。 この振る舞いは、テキストボックス、ツールバー、あるいはリストボックス、ツリー、グリッド、メニューバーなどの複合ウィジェットにショートカットを割り当てるときに一般的に期待されます。 この振る舞いは、メインコンテンツや補足ランドマークのセクションなど、ページのセクションにフォーカスを移動する場合にも役立ちます。

    Activate an element without moving focus when the target context of the function is the context that contains the focus. This behavior is most common for command buttons and for functions associated with elements that are not visible, such as a "Save" option that is accessible via a menu. For example, if the focus is on an option in a listbox and a toolbar contains buttons for moving and removing options, it is most beneficial to keep focus in the listbox when the user presses a key shortcut for one of the buttons in the toolbar. This behavior can be particularly important for screen reader users because it provides confirmation of the action performed and makes performing multiple commands more efficient. For instance, when a screen reader user presses the shortcut for the "Up" button, the user will be able to hear the new position of the option in the list since it still has the focus. Similarly, when the user presses the shortcut for deleting an option, the user can hear the next option in the list and immediately decide whether to press the delete shortcut again.
    機能のターゲットコンテキストがフォーカスを含むコンテキストである場合、フォーカスを移動せずに要素をアクティブ化します。 この振る舞いは、コマンドボタンや、メニューからアクセスできる「保存」オプションなど、可視でない要素に関連付けられている機能で最も一般的です。 例えば、フォーカスがリストボックスのオプションにあり、ツールバーにオプションを移動および削除するためのボタンが含まれている場合、ユーザーがツールバーのボタンの1つのキーショートカットを押したときに、リストボックスにフォーカスを維持することが最も効果的です。 この振る舞いは、実行されたアクションの確認を提供し、複数のコマンドの実行をより効率的にするため、スクリーンリーダーのユーザーにとって特に重要です。 例えば、スクリーンリーダーのユーザーが「上へ」ボタンのショートカットを押すと、まだリスト内にフォーカスがあるため、ユーザーはリスト内のオプションの新しい位置を聞くことができます。 同様に、ユーザーがオプションを削除するためのショートカットを押すと、ユーザーはリスト内の次のオプションを聞いて、すぐに削除ショートカットをもう一度押すかどうかを決定できます。

    Move focus and activate when the target of the shortcut has a single function and the context of that function is the same as the target. This behavior is typical when a shortcut is assigned to a button that opens a menu or dialog, to a checkbox, or to a navigation link or button.
    ショートカットのターゲットに単一の機能があり、その機能のコンテキストがターゲットと同じである場合は、フォーカスを移動してアクティブ化します。 この振る舞いは、メニューやダイアログを開くボタン、チェックボックス、またはナビゲーションリンクやボタンにショートカットが割り当てられている場合によく見られます。





6.9.1.3 Choose Where to Add Shortcuts
6.9.1.3 ショートカットを追加する場所の選択

Work to draft content for this section is tracked in issue 219.
このセクションのコンテンツの草案作成作業は、issue 219 で追跡されています。

The first goal when designing a keyboard interface is simple, efficient, and intuitive operation with only basic keyboard navigation support. If basic operation of a keyboard interface is inefficient, attempting to compensate for fundamental design issues, such as suboptimal layout or command structure, by implementing keyboard shortcuts will not likely reduce user frustration. The practical implication of this is that, in most well-designed user interfaces, the percentage of functionality that needs to be accessible via a keyboard shortcut in order to create optimal usability is not very high. In many simple user interfaces, keyboard shortcuts can be entirely superfluous. And, in user interfaces with too many keyboard shortcuts, the excess shortcuts create cognitive load that make the most useful ones more difficult to remember.
キーボードインターフェイスを設計する際の最初の目標は、基本的なキーボードナビゲーションのみをサポートする、シンプルで効率的で直感的な操作です。 キーボードインターフェイスの基本的な操作が非効率的である場合、キーボードショートカットを実装することによって、最適ではないレイアウトやコマンド構造などの基本的な設計の問題を補おうとしても、ユーザーのフラストレーションを軽減できない可能性があります。 これの実際的な意味は、ほとんどの適切に設計されたユーザーインターフェイスでは、最適なユーザビリティを作成するためにキーボードショートカットを介してアクセスする必要がある機能の割合がそれほど高くないということです。 多くの単純なユーザーインターフェイスでは、キーボードショートカットは完全に不要になる可能性があります。 また、キーボードショートカットが多すぎるユーザーインターフェイスでは、過剰なショートカットが認知的負荷となり、最も便利なショートカットを覚えにくくなります。

Consider the following when deciding where to assign keyboard shortcuts:
キーボードショートカットを割り当てる場所を決定するときは、次の点を考慮してください。

    To be written.
    1. これから書かれる。





6.9.2 Assigning Keyboard Shortcuts
6.9.2 キーボードショートカットの割り当て

When choosing the keys to assign to a shortcut, there are many factors to consider.
ショートカットに割り当てるキーを選択するときは、考慮すべき多くの要素があります。

    Making the shortcut easy to learn and remember by using a mnemonic (e.g., Control + S for "Save") or following a logical or spacial pattern.
    ニーモニック（「保存」の場合は Control + S など）を使用するか、論理的または空間的なパターンに従うことで、ショートカットの習得と記憶を容易にします。

    Localizing the interface, including for differences in which keys are available and how they behave and for language considerations that could impact mnemonics.
    使用可能なキーとその振る舞いの違い、およびニーモニックに影響を与える可能性のある言語の考慮事項を含む、インターフェイスのローカライズ。

    Avoiding and managing conflicts with key assignments used by an assistive technology, the browser, or the operating system.
    支援技術、ブラウザー、またはオペレーティングシステムで使用されるキー割り当てとの競合を回避および管理します。

Methods for designing a key shortcut scheme that supports learning and memory is beyond the scope of this guide. Unless the key shortcut scheme is extensive, it is likely sufficient to mimic concepts that are familiar from common desktop software, such as browsers. Similarly, while localization is important, describing how to address it is left to other resources that specialize in that topic.
学習と記憶をサポートするキーショートカットスキームを設計する方法は、このガイドの範囲を超えています。 キーショートカットスキームが広範でない限り、ブラウザーなどの一般的なデスクトップソフトウェアでよく知られている概念を模倣するだけで十分である可能性があります。 同様に、ローカライズは重要ですが、それに対処する方法の説明は、そのトピックを専門とする他のリソースに任されています。

The remainder of this section provides guidance balancing requirements and concerns related to key assignment conflicts. It is typically ideal if key assignments do not conflict with keys that are assigned to functions in the user's operating system, browser, or assistive technology. Conflicts can block efficient access to functions that are essential to the user, and a perfect storm of conflicts can trap a user. At the same time, there are some circumstances where intentional conflicts are useful. And, given the vast array of operating system, browser, and assistive technology keys, it is almost impossible to be certain conflicts do not exist. So it is also important to employ strategies that mitigate the impact of conflicts whether they are intentional or unknown.
このセクションの残りの部分では、キー割り当ての競合に関連する要件と懸念事項のバランスをとるガイダンスを提供します。 通常、キーの割り当てが、ユーザーのオペレーティングシステム、ブラウザー、または支援技術の機能に割り当てられているキーと競合しないことが理想的です。 競合は、ユーザーにとって不可欠な機能への効率的なアクセスをブロックする可能性があり、競合の最悪の事態はユーザーを罠にかける可能性があります。 同時に、意図的な対立が役立つ状況もあります。 また、オペレーティングシステム、ブラウザー、および支援技術のキーの膨大な配列を考えると、特定の競合が存在しないことを確認することはほとんど不可能です。 したがって、意図的であろうと未知であろうと、競合の影響を軽減する戦略を採用することも重要です。

Note
注

In the following sections, meta key refers to the Windows key on Windows-compatible keyboards and the Command key on MacOS-compatible keyboards.
以下のセクションでは、メタキーとは、Windows 互換キーボードの Windows キーと、MacOS 互換キーボードの Command キーを指します。




6.9.2.1 Operating System Key Conflicts
6.9.2.1 オペレーティングシステムのキーの競合

It is essential to avoid conflicts with keys that perform system level functions, such as application and window management and display and sound control. In general, this can be achieved by refraining from the following types of assignments.
アプリケーションやウィンドウの管理、ディスプレイやサウンドの制御など、システムレベルの機能を実行するキーとの競合を回避することが不可欠です。 一般に、これは次のタイプの割り当てを控えることによって達成できます。

    Any modifier keys + any of Tab, Enter, Space, or Escape.
    1. 任意の修飾キー + Tab、Enter、スペース、または Escape のいずれか。

    Meta key + any other single key (there are exceptions, but they can be risky as these keys can change across versions of operating systems).
    2. メタキー + その他の単一のキー（例外はありますが、これらのキーはオペレーティングシステムのバージョン間で変更される可能性があるため、リスクが伴う可能性があります）。

    Alt + a function key.
    3. Alt + ファンクションキー。

In addition, there are some important application level features that most applications, including browsers, generally support. These include:
さらに、ブラウザーを含むほとんどのアプリケーションが一般的にサポートするいくつかの重要なアプリケーションレベルの機能があります。 これらには、次のものが含まれます：

    Zoom
    1. ズーム

    Copy/Paste
    2. コピーペースト

    ... to be continued ...
    3. ... つづく ... 





6.9.2.2 Assistive Technology Key Conflicts
6.9.2.2 支援技術のキーの競合

Even though assistive technologies have collectively taken thousands of key assignments, avoiding conflicts is relatively easy. This is because assistive technologies have had to develop key assignment schemes that avoid conflicts with both operating systems and applications. They do this by hijacking specific keys as modifiers that uniquely define their key commands. For example, many assistive technologies use the Caps Lock key as a modifier.
支援技術は合わせて何千もの重要な割り当てを行ってきましたが、競合を回避することは比較的簡単です。 これは、支援技術が、オペレーティングシステムとアプリケーションの両方との競合を回避するキー割り当てスキームを開発する必要があったためです。 これは、キーコマンドを一意に定義する修飾子として特定のキーをハイジャックすることによって行われます。 例えば、多くの支援技術では、Caps Lock キーを修飾子として使用しています。

Deflect assistive technology key conflicts by steering clear of the following types of assignments.
次の種類の割り当てを回避することにより、支援技術のキーの競合を回避します。

    Caps Lock + any other combination of keys.
    1. Caps Lock + その他のキーの組み合わせ。

    Insert + any combination of other keys.
    2. Insert + その他のキーの組み合わせ。

    Scroll Lock + any combination of other keys.
    3. Scroll Lock + その他のキーの組み合わせ。

    macOS only: Control+Option + any combination of other keys.
    4. macOS のみ：Control + Option + その他のキーの組み合わせ。 






6.9.2.3 Browser Key Conflicts
6.9.2.3 ブラウザーのキーの競合

While there is considerable similarity among browser keyboard schemes, the patterns within the schemes are less homogenous. Consequently, it is more difficult to avoid conflicts with browser key assignments. While the impact of conflicts is sometimes mitigated by the availability of two paths to nearly every function -- keyboard accessible menus and keyboard shortcuts, avoiding conflicts with shortcuts to heavily used functions is nonetheless important. Pay special attention to avoiding conflicts with shortcuts to:
ブラウザーのキーボードスキームにはかなりの類似性がありますが、スキーム内のパターンはそれほど均一ではありません。 したがって、ブラウザーのキー割り当てとの競合を回避することはより困難です。 競合の影響は、ほぼすべての機能（キーボードでアクセス可能なメニューとキーボードショートカット）への2つのパスを使用できることで軽減される場合がありますが、それでも、頻繁に使用する機能へのショートカットとの競合を回避することが重要です。 次のショートカットとの競合を避けるように特に注意してください。

    Address or location bar
    1. アドレスバーまたはロケーションバー

    Notification bar
    2. 通知バー

    Page refresh
    3. ページの更新

    Bookmark and history functions
    4. ブックマークと履歴機能

    Find functions
    5. ページ内検索機能





6.9.2.4 Intentional Key Conflicts
6.9.2.4 意図的なキーの競合

While avoiding key conflicts is usually desirable, there are circumstances where intentionally conflicting with a browser function is acceptable or even desirable. This can occur when the following combination of conditions arises:
通常、キーの競合を回避することが望ましいですが、ブラウザーの機能と意図的に競合することが許容される、または望ましい場合もあります。 これは、次の条件の組み合わせが発生した場合に生じる可能性があります。

    A web application has a frequently used function that is similar to a browser function.
    ウェブアプリケーションには、頻繁に使用されるブラウザー機能と類似した機能があります。

    Users will often want to execute the web application function.
    ユーザーは多くの場合、ウェブアプリケーション機能を実行したいと思うでしょう。

    Users will rarely execute the browser function.
    ユーザーがブラウザー機能を実行することはめったにありません。

    There is an efficient, alternative path to the browser function.
    ブラウザー機能への効率的な代替パスがあります。

For example, consider a save function that is available when the focus is in an editor. Most browsers use ... to be continued ...
例えば、フォーカスがエディターにあるときに使用できる保存機能について考えてみます。 ほとんどのブラウザーは ... つづく ...




7. Grid and Table Properties
7. グリッドとテーブルのプロパティ

To fully present and describe a grid or table, in addition to parsing the headers, rows, and cells using the roles described in the grid pattern or table pattern, assistive technologies need to be able to determine:
グリッドまたはテーブルを完全に提示および説明するには、グリッドのパターンまたはテーブルのパターンで説明されているロールを使用してヘッダー、行、およびセルを解析することに加えて、支援技術が以下を決定できる必要があります。

    The number of rows and columns.
    行と列の数。

    Whether any columns or rows are hidden, e.g., columns 1 through 3 and 5 through 8 are visible but column 4 is hidden.
    列または行が非表示になっているかどうか。 例えば、列 1 から 3 および 5 から 8 は可視ですが、列 4 は非表示です。

    Whether a cell spans multiple rows or columns.
    セルが複数の行または列にまたがるかどうか。

    Whether and how data is sorted.
    データが並べ替えられているかどうか、およびどのように並べ替えられているか。

Browsers automatically populate their accessibility tree with the number of rows and columns in a grid or table based on the rendered DOM. However, there are many situations where the DOM does not contain the whole grid or table, such as when the data set is too large to fully render. Additionally, some of this information, like skipped columns or rows and how data is sorted, cannot be derived from the DOM structure.
ブラウザーは、レンダリングされた DOM に基づいて、グリッドまたはテーブルの行と列の数をアクセシビリティツリーに自動的に入力します。 ただし、データセットが大きすぎて完全にレンダリングできない場合など、DOM にグリッドまたはテーブル全体が含まれていない状況は数多くあります。 さらに、スキップされた列や行、データの並べ替え方法など、この情報の一部は DOM 構造から導き出すことはできません。

The below sections explain how to use the following properties that ARIA provides for grid and table accessibility.
以下のセクションでは、ARIA がグリッドとテーブルのアクセシビリティのために提供する次のプロパティの使用方法について説明します。

Grid and Table Property Definitions Property 	Definition
グリッドとテーブルのプロパティ定義 	プロパティ 	定義

aria-colcount 	Defines the total number of columns in a table, grid, or treegrid.
aria-colcount 	テーブル、グリッド、またはツリーグリッドの列の総数を定義します。

aria-rowcount 	Defines the total number of rows in a table, grid, or treegrid.
aria-rowcount 	テーブル、グリッド、またはツリーグリッドの行の総数を定義します。

aria-colindex 	

    Defines a cell's position with respect to the total number of columns within a table, grid, or treegrid.
    テーブル、グリッド、またはツリーグリッド内の列の総数に対するセルの位置を定義します。

    Note: Numbering starts with 1, not 0.
    注：番号付けは 0 ではなく 1 から始まります。

aria-rowindex 	

    Defines a cell's position with respect to the total number of rows within a table, grid, or treegrid.
    テーブル、グリッド、またはツリーグリッド内の行の総数に対するセルの位置を定義します。

    Note: Numbering starts with 1, not 0.
    注：番号付けは 0 ではなく 1 から始まります。

aria-colspan 	Defines the number of columns spanned by a cell or gridcell within a table, grid, or treegrid.
aria-colspan 	テーブル、グリッド、またはツリーグリッド内のセルまたはグリッドセルがまたがる列の数を定義します。

aria-rowspan 	Defines the number of rows spanned by a cell or gridcell within a table, grid, or treegrid.
aria-rowspan 	テーブル、グリッド、またはツリーグリッド内のセルまたはグリッドセルがまたがる行数を定義します。

aria-sort 	Indicates if items in a row or column are sorted in ascending or descending order.
aria-sort 	行または列の項目が昇順または降順のどちらで並べ替えられているかを示します。




7.1 Using aria-rowcount and aria-rowindex
7.1 aria-rowcount および aria-rowindex の使用

When the number of rows represented by the DOM structure is not the total number of rows available for a table, grid, or treegrid, the aria-rowcount property is used to communicate the total number of rows available, and it is accompanied by the aria-rowindex property to identify the row indices of the rows that are present in the DOM.
DOM 構造によって表される行数が、テーブル、グリッド、またはツリーグリッドで使用可能な行の総数ではない場合、使用可能な行の総数を伝達するために aria-rowcount プロパティが使用され、DOM に存在する行の行インデックスを識別するために aria-rowindex プロパティが付随します。


The aria-rowcount is specified on the element with the table, grid, or treegrid role. Its value is an integer equal to the total number of rows available, including header rows. If the total number of rows is unknown, a value of -1 may be specified. Using a value of -1 indicates that more rows are available to include in the DOM without specifying the size of the available supply.
aria-rowcount は、テーブル、グリッド、またはツリーグリッドのロールを持つ要素で指定されます。 その値は、ヘッダー行を含む、使用可能な行の総数に等しい整数です。 行の総数が不明な場合は、-1 の値を指定できます。 -1 の値を使用すると、使用可能な行のサイズを指定せずに、DOM に含めることができる行が増えることを示します。

When aria-rowcount is used on a table, grid, or treegrid, a value for aria-rowindex property is specified on each of its descendant rows, including any header rows. The value of aria-rowindex is an integer that is:
aria-rowcount がテーブル、グリッド、またはツリーグリッドで使用される場合、aria-rowindex プロパティの値は、ヘッダー行を含むその子孫の行のそれぞれに指定されます。 aria-rowindex の値は、次の整数です。

    Greater than or equal to 1.
    1. 1 以上。

    Greater than the value of aria-rowindex on any previous rows.
    2. 前の行の aria-rowindex の値よりも大きい。

    Set to the index of the first row in the span if cells span multiple rows.
    3. セルが複数の行にまたがる場合は、スパン内の最初の行のインデックスに設定します。

    Less than or equal to the total number of rows.
    4. 行の総数以下。

WARNING! Missing or inconsistent values of aria-rowindex could have devastating effects on assistive technology behavior. For example, specifying an invalid value for aria-rowindex or setting it on some but not all rows in a table, could cause screen reader table reading functions to skip rows or simply stop functioning.
警告！ aria-rowindex の値が欠落しているか一貫性がない場合、支援技術の振る舞いに壊滅的な影響を与える可能性があります。 例えば、aria-rowindex に無効な値を指定したり、テーブルのすべてではなく一部の行に設定したりすると、スクリーンリーダーのテーブル読み取り機能が行をスキップしたり、単に機能を停止したりする可能性があります。

The following code demonstrates the use of aria-rowcount and aria-rowindex properties on a table containing a hypothetical class list.
次のコードは、架空のクラスのリストを含むテーブルでの aria-rowcount プロパティと aria-rowindex プロパティの使用を示しています。


  <!--

    aria-rowcount tells assistive technologies the actual size of the grid
    aria-rowcount は、マークアップに 4 行しか存在しない場合でも、

    is 463 rows even though only 4 rows are present in the markup.
    グリッドの実際のサイズは 463 行であることを支援技術に伝えます。

  -->

  <table role="grid" aria-rowcount="463">

    aria-label="Student roster for history 101"
    aria-label="歴史101の学生名簿"

    <thead>

      <tr aria-rowindex="1">

        <th>Last Name</th>
        <th>苗字</th>

        <th>First Name</th>
        <th>名</th>

        <th>E-mail</th>
        <th>電子メール</th>

        <th>Major</th>
        <th>専攻</th>

        <th>Minor</th>
        <th>副専攻</th>

        <th>Standing</th>
        <th>等級</th>

      </tr>

    </thead>

    <tbody>

        <!--

          aria-rowindex tells assistive technologies that this
          aria-rowindex は、この行が 463 行のグリッドの

          row is row 51 in the grid of 463 rows.
          行 51 であることを支援技術に通知します。

        -->

      <tr aria-rowindex="51">

        <td>Henderson</td>
        <td>ヘンダーソン</td>

        <td>Alan</td>
        <td>アラン</td>

        <td>ahederson56@myuniveristy.edu</td>

        <td>Business</td>
        <td>ビジネス</td>

        <td>Spanish</td>
        <td>スペイン語</td>

        <td>Junior</td>
        <td>三回生</td>

      </tr>

        <!--

          aria-rowindex tells assistive technologies that this
          aria-rowindex は、この行が 463 行のグリッドの

          row is row 52 in the grid of 463 rows.
          行 52 であることを支援技術に通知します。

        -->

      <tr aria-rowindex="52">

        <td>Henderson</td>
        <td>ヘンダーソン</td>

        <td>Alice</td>
        <td>アリス</td>

        <td>ahederson345@myuniveristy.edu</td>

        <td>Engineering</td>
        <td>工学</td>

        <td>none</td>
        <td>なし</td>

        <td>Sophomore</td>
        <td>二回生</td>

      </tr>

        <!--

          aria-rowindex tells assistive technologies that this
          aria-rowindex は、この行が 463 行のグリッドの

          row is row 53 in the grid of 463 rows.
          行 53 であることを支援技術に通知します。

        -->

      <tr aria-rowindex="53">

        <td>Henderson</td>
        <td>ヘンダーソン</td>

        <td>Andrew</td>

        <td>ahederson75@myuniveristy.edu</td>

        <td>General Studies</td>
        <td>一般教養</td>

        <td>none</td>
        <td>なし</td>

        <td>Freshman</td>
        <td>一回生</td>

      </tr>

    </tbody>

  </table>





7.2 Using aria-colcount and aria-colindex
7.2 aria-colcount および aria-colindex の使用

When the number of columns represented by the DOM structure is not the total number of columns available for a table, grid, or treegrid, the aria-colcount property is used to communicate the total number of columns available, and it is accompanied by the aria-colindex property to identify the column indices of the columns that are present in the DOM.
DOM 構造で表される列の数が、テーブル、グリッド、またはツリーグリッドで使用可能な列の総数ではない場合、使用可能な列の総数を伝達するために aria-colcount プロパティが使用され、DOM に存在する列の列インデックスを識別するために aria-colindex プロパティが付随します。


The aria-colcount is specified on the element with the table, grid, or treegrid role. Its value is an integer equal to the total number of columns available. If the total number of columns is unknown, a value of -1 may be specified. Using a value of -1 indicates that more columns are available to include in the DOM without specifying the size of the available supply.
aria-colcount は、テーブル、グリッド、またはツリーグリッドのロールを持つ要素で指定されます。 その値は、使用可能な列の総数に等しい整数です。 列の総数が不明な場合は、-1 の値を指定できます。 -1 の値を使用すると、使用可能な列のサイズを指定せずに、DOM に含めることができる列が増えることを示します。

When aria-colcount is used on a table, grid, or treegrid, a value for aria-colindex property is either specified on each of its descendant rows or on every cell in each descendant row, depending on whether the columns are contiguous as described below. The value of aria-colindex is an integer that is:
aria-colcount がテーブル、グリッド、またはツリーグリッドで使用される場合、aria-colindex プロパティの値は、以下で説明するように、列が連続しているかどうかに応じて、その子孫の行の各行または各子孫の行のすべてのセルで指定されます。 aria-colindexv の値は、次の整数です。

    Greater than or equal to 1.
    1. 1 以上。

    When set on a cell, greater than the value set on any previous cell within the same row.
    2. セルに設定すると、同じ行内の前のセルに設定された値よりも大きくなります。

    Set to the index of the first column in the span if a cell spans multiple columns.
    3. セルが複数の列にまたがる場合は、スパン内の最初の列のインデックスに設定します。

    Less than or equal to the total number of columns.
    4. 列の総数以下。

WARNING! Missing or inconsistent values of aria-colindex could have devastating effects on assistive technology behavior. For example, specifying an invalid value for aria-colindex or setting it on some but not all cells in a row, could cause screen reader table reading functions to skip cells or simply stop functioning.
警告！ aria-colindex の値が欠落しているか一貫性がない場合、支援技術の振る舞いに壊滅的な影響を与える可能性があります。 例えば、aria-colindex に無効な値を指定したり、行のすべてではなく一部のセルに設定したりすると、スクリーンリーダーのテーブル読み取り機能がセルをスキップしたり、単に機能を停止したりする可能性があります。




7.2.1 Using aria-colindex When Column Indices Are Contiguous
7.2.1 列インデックスが連続している場合の aria-colindex の使用

When all the cells in a row have column index numbers that are consecutive integers, aria-colindex can be set on the row element with a value equal to the index number of the first column in the set. Browsers will then compute a column number for each cell in the row.
行のすべてのセルに連続する整数の列インデックス番号がある場合、aria-colindex は、セットの最初の列インデックス番号と等しい値で行要素に設定できます。 次に、ブラウザーは行の各セルの列番号を計算します。

The following code shows a grid with 16 columns, of which columns 2 through 5 are displayed to the user. Because the set of columns is contiguous, aria-colindex can be placed on each row.
次のコードは、16 列のグリッドを示しており、そのうち列 2 から列 5 がユーザーに表示されます。 列のセットは連続しているため、aria-colindex を各行に配置できます。 

        

<div role="grid" aria-colcount="16">

  <div role="rowgroup">

    <div role="row" aria-colindex="2">

      <span role="columnheader">First Name</span>
      <span role="columnheader">名</span>

      <span role="columnheader">Last Name</span>
      <span role="columnheader">苗字</span>

      <span role="columnheader">Company</span>
      <span role="columnheader">会社</span>

      <span role="columnheader">Address</span>
      <span role="columnheader">住所</span>

    </div>

  </div>

  <div role="rowgroup">

    <div role="row" aria-colindex="2">

      <span role="gridcell">Fred</span>
      <span role="gridcell">フレッド</span>

      <span role="gridcell">Jackson</span>
      <span role="gridcell">ジャクソン</span>

      <span role="gridcell">Acme, Inc.</span>
      <span role="gridcell">株式会社アクメ</span>

      <span role="gridcell">123 Broad St.</span>
      <span role="gridcell">ブロードストリート 123番地</span>

    </div>

    <div role="row" aria-colindex="2">

      <span role="gridcell">Sara</span>
      <span role="gridcell">サラ</span>

      <span role="gridcell">James</span>
      <span role="gridcell">ジェームス</span>

      <span role="gridcell">Acme, Inc.</span>
      <span role="gridcell">株式会社アクメ</span>

      <span role="gridcell">123 Broad St.</span>
      <span role="gridcell">ブロードストリート 123番地</span>

    </div>
    
   …

  </div>

</div>





7.2.2 Using aria-colindex When Column Indices Are Not Contiguous
7.2.2 列インデックスが連続していない場合の aria-colindex の使用

When the cells in a row have column index numbers that are not consecutive integers, aria-colindex needs to be set on each cell in the row. The following example shows a grid for an online grade book where the first two columns contain a student name and subsequent columns contain scores. In this example, the first two columns with the student name are shown, but the score columns have been scrolled to show columns 10 through 13. Columns 3 through 9 are not visible so are not in the DOM.
行のセルに連続する整数ではない列インデックス番号がある場合、aria-colindex を行の各セルに設定する必要があります。 次の例は、最初の 2 列に生徒の名前が含まれ、続く列に得点が含まれるオンライン成績表のグリッドを示しています。 この例では、学生名の最初の 2 列が表示されていますが、得点列がスクロールされて列 10 から列 13 が表示されています。 列 3 から列 9 は可視でないため、DOM にはありません。 


  <table role="grid" aria-rowcount="463" aria-colcount="13">

    aria-label="Student grades for history 101"
    aria-label="歴史101の生徒の成績"

    <!--

      aria-rowcount and aria-colcount tell assistive technologies
      aria-rowcount と aria-colcount は、支援技術にグリッドの

      the actual size of the grid is 463 rows by 13 columns,
      実際のサイズが 463 行 × 13 列であることを示しています。

      which is not the number rows and columns found in the markup.
      これは、マークアップで見つかった行と列の数ではありません。

    -->

    <thead>

      <tr aria-rowindex="1">

        <!--

          aria-colindex tells assistive technologies that the
          aria-colindex は、次の列がデータセット全体の

          following columns represent columns 1 and 2 of the total data set.
          列 1 と列 2 を表すことを支援技術に伝えます。

        -->

        <th aria-colindex="1">Last Name</th>

        <th aria-colindex="2">First Name</th>

        <!--

          aria-colindex tells users of assistive technologies that the
          aria-colindex は、支援技術のユーザーに、

          following columns represent columns 10, 11, 12, and 13 of
          次の列が成績のデータセット全体の

          the overall data set of grades.
          列 10、11、12、および 13 を表すことを伝えます。

        -->

        <th aria-colindex="10">Homework 4</th>
        <th aria-colindex="10">宿題 4</th>

        <th aria-colindex="11">Quiz 2</th>
        <th aria-colindex="11">小テスト 2</th>

        <th aria-colindex="12">Homework 5</th>
        <th aria-colindex="12">宿題 5</th>

        <th aria-colindex="13">Homework 6</th>
        <th aria-colindex="13">宿題 6</th>

      </tr>

    </thead>

    <tbody>

      <tr aria-rowindex="50">

        <!--

          every cell needs to define the aria-colindex attribute
          すべてのセルで aria-colindex 属性を定義する必要があります

        -->

        <td aria-colindex="1">Henderson</td>
        <td aria-colindex="1">ヘンダーソン</td>

        <td aria-colindex="2">Alan</td>
        <td aria-colindex="2">アラン</td>

        <td aria-colindex="10">8</td>

        <td aria-colindex="11">25</td>

        <td aria-colindex="12">9</td>

        <td aria-colindex="13">9</td>

      </tr>

      <tr aria-rowindex="51">

        <td aria-colindex="1">Henderson</td>
        <td aria-colindex="1">ヘンダーソン</td>

        <td aria-colindex="2">Alice</td>
        <td aria-colindex="2">アリス</td>

        <td aria-colindex="10">10</td>

        <td aria-colindex="11">27</td>

        <td aria-colindex="12">10</td>

        <td aria-colindex="13">8</td>

      </tr>

      <tr aria-rowindex="52">

        <td aria-colindex="1">Henderson</td>
        <td aria-colindex="1">ヘンダーソン</td>

        <td aria-colindex="2">Andrew</td>
        <td aria-colindex="2">アンドリュー</td>

        <td aria-colindex="10">9</td>

        <td aria-colindex="11">0</td>

        <td aria-colindex="12">29</td>

        <td aria-colindex="13">8</td>

      </tr>

    </tbody>

  </table>





7.3 Defining cell spans using aria-colspan and aria-rowspan
7.3 aria-colspan および aria-rowspan を使用したセルスパンの定義

For tables, grids, and treegrids created using elements other than HTML table elements, row and column spans are defined with the aria-rowspan and aria-colspan properties.
HTML テーブル要素以外の要素を使用して作成されたテーブル、グリッド、およびツリーグリッドの場合、行と列のスパンは aria-rowspan プロパティと aria-colspan プロパティで定義されます。

The value of aria-colspan is an integer that is:
aria-colspan の値は、次の整数です。

    Greater than or equal to 1.
    1. 1 以上。

    less than the value that would cause the cell to overlap the next cell in the same row.
    2. セルが同じ行の次のセルと重なるような値よりも小さい。

The value of aria-rowspan is an integer that is:
aria-rowspan の値は、次の整数です。

    Greater than or equal to 0.
    1. 0 以上。

    0 means the cell spans all the remaining rows in its row group.
    2. 0 は、セルがその行グループの残りのすべての行にまたがることを意味します。

    less than the value that would cause the cell to overlap the next cell in the same column.
    3. セルが同じ列の次のセルと重なるような値よりも小さい。

The following example grid has a two row header. The first two columns have headers that span both rows of the header. The subsequent 6 columns are grouped into 3 pairs with headers in the first row that each span two columns.
次のグリッド例には、2 行のヘッダーがあります。 最初の 2 列には、ヘッダーの両方の行にまたがるヘッダーがあります。 続く 6 列は 3 つのペアにグループ化され、最初の行には、それぞれが 2 列にまたがるヘッダーがあります。 

  <div role="grid" aria-rowcount="463">

    aria-label="Student grades for history 101"
    aria-label="歴史101の生徒の成績"

    <div role="rowgroup">

      <div role="row" aria-rowindex="1">

          <!--

            aria-rowspan and aria-colspan provide
            aria-rowspan および aria-colspan は、

            assistive technologies with the correct data cell header information
            ヘッダーセルが複数の行または列にまたがる場合に、

            when header cells span more than one row or column.
            正しいデータセルのヘッダー情報を提供する支援技術を提供します。

          -->

          <span role="columnheader" aria-rowspan="2">Last Name</span>
          <span role="columnheader" aria-rowspan="2">苗字</span>

          <span role="columnheader" aria-rowspan="2">First Name</span>
          <span role="columnheader" aria-rowspan="2">名</span>

          <span role="columnheader" aria-colspan="2">Test 1</span>
          <span role="columnheader" aria-colspan="2">試験 1</span>

          <span role="columnheader" aria-colspan="2">Test 2</span>
          <span role="columnheader" aria-colspan="2">試験 2</span>

          <span role="columnheader" aria-colspan="2">Final</span>
          <span role="columnheader" aria-colspan="2">最終試験</span>

      </div>

      <div role="row" aria-rowindex="2">

          <span role="columnheader">Score</span>
          <span role="columnheader">得点</span>

          <span role="columnheader">Grade</span>
          <span role="columnheader">成績</span>

          <span role="columnheader">Score</span>
          <span role="columnheader">得点</span>

          <span role="columnheader">Grade</span>
          <span role="columnheader">成績</span>

          <span role="columnheader">Total</span>
          <span role="columnheader">総得点</span>

          <span role="columnheader">Grade</span>
          <span role="columnheader">成績</span>

      </div>

    </div>

    <div role="rowgroup">

      <div role="row" aria-rowindex="50">

        <span role="cell">Henderson</span>
        <span role="cell">ヘンダーソン</span>

        <span role="cell">Alan</span>
        <span role="cell">アラン</span>

        <span role="cell">89</span>

        <span role="cell">B+</span>

        <span role="cell">72</span>

        <span role="cell">C</span>

        <span role="cell">161</span>

        <span role="cell">B-</span>

      </div>

      <div role="row"  aria-rowindex="51">

        <span role="cell">Henderson</span>
        <span role="cell">ヘンダーソン</span>

        <span role="cell">Alice</span>
        <span role="cell">アリス</span>

        <span role="cell">94</span>

        <span role="cell">A</span>

        <span role="cell">86</span>

        <span role="cell">B</span>

        <span role="cell">180</span>

        <span role="cell">A-</span>

      </div>

      <div role="row"  aria-rowindex="52">

        <span role="cell">Henderson</span>
        <span role="cell">ヘンダーソン</span>

        <span role="cell">Andrew</span>
        <span role="cell">アンドリュー</span>

        <span role="cell">82</span>

        <span role="cell">B-</span>

        <span role="cell">95</span>

        <span role="cell">A</span>

        <span role="cell">177</span>

        <span role="cell">B+</span>

      </div>

    </div>

  </div>

Note: When using HTML table elements, use the native semantics of the th and td elements to define row and column spans by using the rowspan and colspan attributes.
注：HTML テーブル要素を使用する場合は、テーブルヘッダーセル（th）要素とテーブルデータセル（td）要素のネイティブな意味論を使用して、rowspan 属性と colspan 属性を使用して行と列のスパンを定義します。



7.4 Indicating sort order with aria-sort
7.4 aria-sort による並べ替え順の表示

When rows or columns are sorted, the aria-sort property can be applied to a column or row header to indicate the sorting method. The following table describes allowed values for aria-sort.
行または列を並べ替えるときに、aria-sort プロパティを列ヘッダーまたは行ヘッダーに適用して、並べ替え方法を示すことができます。 次の表に、aria-sort の許容値を示します。

Description of values for aria-sort Value 	Description
aria-sort の値の説明 	値 	説明

ascending 	Data are sorted in ascending order.
ascending 	データは昇順で並べ替えられます。

descending 	Data are sorted in descending order.
descending 	データは降順で並べ替えられます。

other 	Data are sorted by an algorithm other than ascending or descending.
other 	データは、昇順または降順以外のアルゴリズムによって並べ替えられます。

none 	Default (no sort applied).
none 	デフォルト（並べ替えは適用されません）。

It is important to note that ARIA does not provide a way to indicate levels of sort for data sets that have multiple sort keys. Thus, there is limited value to applying aria-sort with a value other than none to more than one column or row.
ARIA は、複数の並べ替えキーを持つデータセットの並べ替えレベルを示す方法を提供していないことに注意することが重要です。 したがって、値が none 以外の aria-sort を複数の列または行に適用することには、限られた価値しかありません。

The following example grid uses aria-sort to indicate the rows are sorted from the highest "Quiz 2" score to the lowest "Quiz 2" score.
次のグリッド例では、aria-sort を使用して、行が「小テスト 2」の最高得点から「小テスト 2」の最低得点に並べ替えられていることを示しています。 


  <table role="grid" aria-rowcount="463" aria-colcount="13"

    aria-label="Student grades for history 101">
    aria-label="歴史101の生徒の成績">

    <thead>

      <tr aria-colindex="10" aria-rowindex="1">

        <th>Homework 4</th>
        <th>宿題 4</th>

        <!--

          aria-sort indicates the column with the heading
          aria-sort は、「小テスト 2」という見出しの列が

          "Quiz 2" has been used to sort the rows of the grid.
          グリッドの行の並べ替えに使用されたことを示します。

        -->

        <th aria-sort="descending">Quiz 2</th>
        <th aria-sort="descending">小テスト 2</th>

        <th>Homework 5</th>
        <th>宿題 5</th>

        <th>Homework 6</th>
        <th>宿題 6</th>

      </tr>

    </thead>

    <tbody>

      <tr aria-colindex="10" aria-rowindex="50">

        <td>8</td>

        <td>30</td>

        <td>9</td>

        <td>9</td>

      </tr>

      <tr aria-colindex="10"  aria-rowindex="51">

        <td>10</td>

        <td>29</td>

        <td>10</td>

        <td>8</td>

      </tr>

      <tr aria-colindex="10"  aria-rowindex="52">

        <td>9</td>

        <td>9</td>

        <td>27</td>

        <td>6</td>

      </tr>

      <tr aria-colindex="10"  aria-rowindex="53">

        <td>9</td>

        <td>10</td>

        <td>26</td>

        <td>8</td>

      </tr>

      <tr aria-colindex="10"  aria-rowindex="54">

        <td>9</td>

        <td>7</td>

        <td>24</td>

        <td>6</td>

      </tr>

    </tbody>

  </table>





8. Intentionally Hiding Semantics with the presentation Role
8. プレゼンテーションロールで意味論を意図的に隠す

While ARIA is primarily used to express semantics, there are some situations where hiding an element’s semantics from assistive technologies is helpful. This is done with the presentation role, which declares that an element is being used only for presentation and therefore does not have any accessibility semantics. The ARIA 1.1 specification also includes role none, which serves as a synonym for presentation.
ARIA は主に意味論を表現するために使用されますが、要素の意味論を支援技術から隠すことが役立つ場合があります。 これは、要素がプレゼンテーション（表現）にのみ使用されているため、アクセシビリティの意味論がないことを宣言するプレゼンテーション（presentation）ロールを使用して行われます。 ARIA 1.1 仕様には、プレゼンテーションの同義語として機能する none ロールも含まれています。

For example, consider a tabs widget built using an HTML ul element.
例えば、HTML 順序なしリスト（ul）要素を使用して構築されたタブウィジェットについて考えてみます。 

<ul role="tablist">

  <li role="presentation">

    <a role="tab" href="#">Tab 1</a>
    <a role="tab" href="#">タブ 1</a>

  </li>

  <li role="presentation">

    <a role="tab" href="#">Tab 2</a>
    <a role="tab" href="#">タブ 2</a>

  </li>

  <li role="presentation">

    <a role="tab" href="#">Tab 3</a>
    <a role="tab" href="#">タブ 3</a>

  </li>

</ul>

Because the list is declared to be a tablist, the list items are not in a list context. It could confuse users if an assistive technology were to render those list items. Applying role presentation to the li elements tells browsers to leave those elements out of their accessibility tree. Assistive technologies will thus be unaware of the list item elements and see the tab elements as immediate children of the tablist.
リストはタブリストとして宣言されているため、リスト項目はリストのコンテキストにありません。 支援技術がこれらのリスト項目をレンダリングする場合、ユーザーを混乱させる可能性があります。 リスト項目（li）要素にプレゼンテーションロールを適用すると、ブラウザーはそれらの要素をアクセシビリティツリーから除外するように指示されます。 したがって、支援技術はリスト項目要素を認識せず、タブ要素をタブリストの直接の子と見なします。

Three common uses of role presentation are:
プレゼンテーションロールの3つの一般的な使用法は次のとおりです。

    Hiding a decorative image; it is equivalent to giving the image null alt text.
    1. 装飾的な画像を隠します。 これは、画像に空の代替テキストを与えることと同じです。

    Suppressing table semantics of tables used for layout in circumstances where the table semantics do not convey meaningful relationships.
    2. テーブルの意味論が意味のある関係を伝えない状況で、レイアウトに使用されるテーブルのテーブルの意味論を抑制します。

    Eliminating semantics of intervening orphan elements in the structure of a composite widget, such as a tablist, menu, or tree as demonstrated in the example above.
    3. 上記の例に示されているように、タブリスト、メニュー、ツリーなど、複合ウィジェットの構造に介在する孤立した要素の意味論を排除します。 





8.1 Effects of Role presentation
8.1 プレゼンテーションロールの効果

When role="presentation" is specified on an element, if a condition that requires a browser to ignore the presentation role does not exist, it has the following three effects.
要素に role="presentation" が指定されている場合、ブラウザーがプレゼンテーションロールを無視する必要がある条件が存在しない場合、次の3つの効果があります。

    The element’s implied ARIA role and any ARIA states and properties associated with that role are hidden from assistive technologies.
    1. 要素の暗黙の ARIA ロール、およびそのロールに関連付けられている ARIA の状態とプロパティは、支援技術から隠されています。

    Text contained by the element, i.e., inner text, as well as inner text of all its descendant elements remains visible to assistive technologies except, of course, when the text is explicitly hidden, e.g., styled with display: none or has aria-hidden="true".
    2. 要素に含まれるテキスト、つまり内部テキスト、およびそのすべての子孫要素の内部テキストは、もちろん、テキストが明示的に非表示になっている場合（例えば、スタイルを display: none または aria-hidden="true" で設定）を除いて、支援技術に可視のままになります。

    The roles, states, and properties of each descendant element remain visible to assistive technologies unless the descendant requires the context of the presentational element. For example:
    3. 各子孫要素のロール、状態、およびプロパティは、子孫がプレゼンテーション化した要素のコンテキストを必要としない限り、支援技術に可視のままになります。 例えば：

        If presentation is applied to a ul or ol element, each child li element inherits the presentation role because ARIA requires the listitem elements to have the parent list element. So, the li elements are not exposed to assistive technologies, but elements contained inside of those li elements, including nested lists, are visible to assistive technologies.
        プレゼンテーションロールが順序なしリスト（ul）要素または順序付きリスト（ol）要素に適用される場合、ARIA ではリスト項目要素に親リスト要素が必要であるため、各子リスト項目（li）要素はプレゼンテーションロールを継承します。 したがって、リスト項目要素は支援技術に公開されませんが、ネストされたリストなど、それらのリスト項目要素内に含まれる要素は支援技術に可視になります。

        Similarly, if presentation is applied to a table element, the descendant caption, thead, tbody, tfoot, tr, th, and td elements inherit role presentation and are thus not exposed to assistive technologies. But, elements inside of the th and td elements, including nested tables, are exposed to assistive technologies.
        同様に、プレゼンテーションロールがテーブル要素に適用される場合、子孫のキャプション（caption）、テーブルヘッダー（thead）、テーブルボディ（tbody）、テーブルフッター（tfoot）、テーブル行（tr）、テーブルヘッダーセル（th）、およびテーブルデータセル（td）要素はプレゼンテーションロールを継承するため、支援技術にさらされません。 ただし、ネストされたテーブルを含む、テーブルヘッダーセル要素とテーブルデータセル要素の内部の要素は、支援技術にさらされています。





8.2 Conditions That Cause Role presentation to be Ignored
8.2 プレゼンテーションロールが無視される原因となる条件

Browsers ignore role="presentation", and it therefore has no effect, if either of the following are true about the element to which it is applied:
適用される要素について次のいずれかに該当する場合は、ブラウザーは role="presentation" を無視するため、効果がありません。

    The element is focusable, e.g. it is natively focusable like an HTML link or input, or it has a tabindex attribute.
    要素はフォーカス可能です（例：HTML のリンクや入力のようにネイティブにフォーカスできるか、タブインデックス属性があります）。

    The element has any of the twenty-one global ARIA states and properties, e.g., aria-label.
    この要素には、21個の ARIA のグローバルな状態とプロパティのいずれかがあります（例：aria-label）。 





8.3 Example Demonstrating Effects of the presentation Role
8.3 プレゼンテーションロールの効果を示す例

This code:
このコードは： 

<ul role="presentation">

  <li>Date of birth:</li>
  <li>生年月日：</li>

  <li>January 1, 3456</li>
  <li>3456年1月1日</li>

</ul>

when parsed by a browser, is equivalent to the following from the perspective of a screen reader or other assistive technology that relies on the browser's accessibility tree:
ブラウザーで解析すると、スクリーンリーダーまたはブラウザーのアクセシビリティツリーに依存するその他の支援技術の観点から、次と同等になります。

<div>Date of birth:</div>
<div>生年月日：</div>

  <div>January 1, 3456</div>
  <div>3456年1月1日</div>





9. Roles That Automatically Hide Semantics by Making Their Descendants Presentational
9. 子孫をプレゼンテーション化することによって意味論を自動的に隠すロール

There are some types of user interface components that, when represented in a platform accessibility API, can only contain text. For example, accessibility APIs do not have a way of representing semantic elements contained in a button. To deal with this limitation, WAI-ARIA requires browsers to automatically apply role presentation to all descendant elements of any element with a role that cannot support semantic children.
プラットフォームのアクセシビリティ API で表される場合、テキストのみを含めることができるユーザーインターフェイスコンポーネントの種類がいくつかあります。 例えば、アクセシビリティ API には、ボタンに含まれる意味論的な要素を表す方法がありません。 この制限に対処するために、WAI-ARIA は、意味論的な子をサポートできないロールを持つ要素のすべての子孫要素にプレゼンテーションロールを自動的に適用することをブラウザーに要求します。

The roles that require all children to be presentational are:
すべての子にプレゼンテーション化を行うことが求められるロールは次のとおりです。 

    ボタン（button）

    チェックボックス（checkbox）

    画像（img）

    数学（math）

    メニュー項目チェックボックス（menuitemcheckbox）

    メニュー項目ラジオボタン（menuitemradio）

    オプション（option）

    プログレスバー（progressbar）

    ラジオボタン（radio）

    スクロールバー（scrollbar）

    区切り（separator）

    スライダー（slider）

    スイッチ（switch）

    タブ（tab）

For instance, consider the following tab element, which contains a heading.
例えば、見出しを含む次のタブ要素について考えてみます。

<li role="tab"><h3>Title of My Tab</h3></li>
<li role="tab"><h3>マイタブのタイトル</h3></li>

Because WAI-ARIA requires descendants of tab to be presentational, the following code is equivalent.
WAI-ARIA ではタブの子孫にプレゼンテーション化を行うことが求められるため、次のコードと同等です。

<li role="tab"><h3 role="presentation">Title of My Tab</h3></li>
<li role="tab"><h3 role="presentation">マイタブのタイトル</h3></li>

And, from the perspective of anyone using a technology that relies on an accessibility API, such as a screen reader, the heading does not exist since the previous code is equivalent to the following.
また、スクリーンリーダーなどのアクセシビリティ API に依存するテクノロジーを使用している人の観点からは、前のコードは次のコードと同等であるため、見出しは存在しません。

<li role="tab">Title of My Tab</li>
<li role="tab">マイタブのタイトル</li>

See the section about role presentation for a detailed explanation of what it does.
何をするかの詳細な説明については、プレゼンテーションロールに関するセクションを参照してください。



A. Indexes
A. インデックス

    Design Pattern Examples by Role
    ロール別のデザインパターンの例

    Design Pattern Examples by Properties and States
    プロパティと状態によるデザインパターンの例 





B. Change History
B. 変更履歴



B.1 Changes in July 2019 Publication of Note Release 4
B.1 2019年7月のノートリリース4の発行における変更

    Major additions and revisions:
    主な追加と改訂：

        Added section providing guidance on coding and composing accessible names and descriptions. This section comprehensively covers ARIA and HTML naming and describing techniques as well as specific guidance for every ARIA role.
        アクセス可能な名前と説明のコーディングと構成に関するガイダンスを提供するセクションを追加しました。 このセクションでは、ARIA と HTML の命名と説明の手法、およびすべての ARIA ロールに関する具体的なガイダンスについて包括的に説明します。

        Added example of a site navigation bar ("menu system") with dropdown lists of links coded using the disclosure pattern.
        開示のパターンを使用してコード化されたリンクのドロップダウンリストを備えたサイトナビゲーションバー（「メニューシステム」）の例を追加しました。

        Added an example of a date picker based on the dialog and grid patterns. A modal dialog contains a calendar grid that presents buttons for each day of a month.
        ダイアログとグリッドのパターンに基づく日付ピッカーの例を追加しました。 モーダルダイアログには、月の各日のボタンを提示するカレンダーグリッドが含まれています。

        Added an example of a date picker that uses three spin buttons for day, month, and year.
        日、月、年に3つのスピンボタンを使用する日付ピッカーの例を追加しました。

        Image Carousel Example: Updated the example so that the rotation control is always visible instead of only being visible for keyboard users who move focus into the carousel region. Also changed the controls so they are implemented with HTML button elements instead of links with the button role.
        画像カルーセルの例：カルーセルリージョンにフォーカスを移動するキーボードユーザーにのみ可視になるのではなく、回転コントロールが常に可視になるように例を更新しました。 また、ボタンロールを持つリンクではなく、HTML ボタン要素で実装されるようにコントロールを変更しました。

        Toolbar Example: Added popup text labels for icons that are displayed on both hover and focus.
        ツールバーの例：ホバーとフォーカスの両方に表示されるアイコンのポップアップテキストラベルを追加しました。

    Minor revisions of guidance or implementation were made to the following design patterns and examples:
    ガイダンスまたは実装のマイナーな改訂が、次のデザインパターンと例に対して行われました。

        Editor Menubar Example: Updated example so that meta data used by the scripts is specified using data- attributes instead of with rel attributes.
        エディターのメニューバーの例：スクリプトで使用されるメタデータが rel 属性ではなくdata- 属性を使用して指定されるように、例を更新しました。

        Radio Group with Active Descendant Example: Removed unused keycodes and fixed linting issues.
        アクティブな子孫を持つラジオグループの例：未使用のキーコードを削除し、リンティングの問題を修正しました。

Also see:
参照：

    The APG 1.1 Release 4 Milestone: which lists the GitHub issues that document discussions and reviews of changes included in the July 2019 publication.
    APG 1.1 リリース4マイルストーン：2019年7月の出版物に含まれる変更のディスカッションとレビューを文書化した GitHub issues を一覧表示します。

    Detailed change log with links to all commits that are new in the July 2019 publication since the January 2019 publication.
    2019年1月の発行以降、2019年7月の発行で新しくなったすべてのコミットへのリンクを含む詳細な変更ログ。





B.2 Changes in January 2019 Publication of Note Release 3
B.2 2019年1月のノートリリース3の発行における変更

    Major additions and revisions:
    主な追加と改訂：

        Added indexes that allow lookup of examples by role, state, or property.
        ロール、状態、またはプロパティによる例のルックアップを可能にするインデックスが追加されました。

        Added a carousel design pattern and example implementation.
        カルーセルのデザインパターンと実装例を追加しました。

        Revised radio group pattern to accommodate radio groups nested in toolbars: left and right arrow keys do not change the checked state and can move focus outside the group.
        ツールバーにネストされたラジオグループに対応するようにラジオグループのパターンが改訂されました。 左右の矢印キーはチェックされた状態を変更せず、フォーカスをグループの外に移動できます。

        Redesigned toolbar example to demonstrate an editor toolbar that includes a nested radio group, toggle buttons, menu button, spin button, checkbox, and link. Also fixed several bugs.
        ネストされたラジオグループ、トグルボタン、メニューボタン、スピンボタン、チェックボックス、およびリンクを含むエディターツールバーを示すために、再設計されたツールバーの例。 また、いくつかのバグを修正しました。

        Restructured the accordion example to use HTML heading elements containing HTML button elements.
        HTML ボタン要素を含む HTML 見出し要素を使用するようにアコーディオンの例を再構築しました。

        Added a regression test framework and suite of regression tests that test all documented keyboard behaviors, roles, states, and properties for each example implementation of a pattern.
        パターンの実装例ごとに、文書化されたすべてのキーボードの振る舞い、ロール、状態、およびプロパティをテストする回帰テストフレームワークと一連の回帰テストを追加しました。

    Minor revisions of guidance or implementation were made to the following design patterns and examples:
    ガイダンスまたは実装のマイナーな改訂が、次のデザインパターンと例に対して行われました。

        Alert dialog example: Replaced lorem ipsum placeholder with text that describes actions that trigger the alert dialog and alert message.
        アラートダイアログの例：lorem ipsum プレースホルダーを、アラートダイアログとアラートメッセージをトリガーするアクションを説明するテキストに置き換えました。

        Button Example: Button activation now happens on keyup for space key and aria-hidden was removed from child svg.
        ボタンの例：ボタンのアクティブ化は、スペースキーのキーアップで発生し、aria-hidden が子 svg から削除されました。

        Legacy Combobox examples: Fixed enter key documentation, made Up Arrow set activedescendant to last match in list, corrected up arrow documentation for the textbox.
        従来のコンボボックスの例：Enter キーの文書を修正し、上矢印が activedescendant をリスト内の最後の一致に設定するようにし、テキストボックスの上矢印の文書を修正しました。

        Dialog Examples: Fixed IE11 incompatibility in role validity check.
        ダイアログの例：ロールの有効性チェックにおける IE11 の非互換性を修正しました。

        Single-select listbox example: Fix a bug with aria-selected.
        単一選択リストボックスの例：aria-selected のバグを修正しました。

        Grid Examples: Fixed how event listeners were cleaned up.
        グリッドの例：イベントリスナーがクリーンアップされる方法を修正しました。

        Menubar Examples: Applied role="none" where missing from elements in menubar and changed visual design to better distinguish between menuitemradio and meuitemcheckbox elements.
        メニューバーの例：メニューバーの要素に欠落している role="none" を適用し、menuitemradio 要素と meuitemcheckbox 要素をより適切に区別するためにビジュアルデザインを変更しました。

        Radio Group Example: Fixed documentation of elements used in attributes table.
        ラジオグループの例：属性テーブルで使用される要素の文書を修正しました。

        Spin Button Pattern: Added aria-invalid guidance for values outside allowed range.
        スピンボタンのパターン：許容範囲外の値に対して aria-invalid のガイダンスを追加しました。

        Toolbar Pattern: Clarified keyboard guidance for Tab and Shift+Tab and revised description to remove guidance that conflicted with updated radio group pattern.
        ツールバーのパターン：Tab キーおよび Shift + Tab キーのキーボードガイダンスを明確にし、説明を改訂して、更新されたラジオグループのパターンと競合するガイダンスを削除しました。

Also see:
参照：

    The APG 1.1 Release 3 Milestone: which lists the GitHub issues that document discussions and reviews of changes included in the January 2019 publication.
    APG 1.1 リリース3マイルストーン：2019年1月の出版物に含まれる変更のディスカッションとレビューを文書化した GitHub issues を一覧表示します。

    Detailed change log with links to all commits that are new in the January 2019 publication since the July 2018 publication.
    2018年7月の発行以降、2019年1月の発行で新しくなったすべてのコミットへのリンクを含む詳細な変更ログ。





B.3 Changes in July 2018 Publication of Note Release 2
B.3 2018年7月のノートリリース2の発行における変更

    Added the following:
    以下を追加しました：

        Treegrid design pattern and example
        ツリーグリッドのデザインパターンと例

        Alert dialog example
        アラートダイアログの例

    Significant revisions of guidance or implementation were made to the following design patterns and examples:
    ガイダンスまたは実装の大幅な改訂が、次のデザインパターンと例に対して行われました。

        Accordion pattern and example, including removing two optional key commands from the pattern.
        アコーディオンのパターンと例。 パターンから2つの任意のキーコマンドを削除します。

        Checkbox example bug fixes
        チェックボックスの例のバグ修正

        ARIA 1.0 Combobox example, including escape key behavior
        エスケープキーの振る舞いを含む ARIA 1.0 コンボボックスの例

        ARIA 1.1 Combobox example labeling
        ARIA 1.1 コンボボックスの例のラベル付け

        Modal dialog example, primarily code refactoring when adding alert dialog
        モーダルダイアログの例、主にアラートダイアログを追加する際のコードリファクタリング

        Grid pattern, including guidance on column selection
        列選択のガイダンスを含むグリッドのパターン

        Listbox examples
        リストボックスの例

        Menu pattern, including guidance on menu/submenu structure
        メニュー/サブメニュー構造に関するガイダンスを含むメニューのパターン

        editor menubar example, including significant improvement to mouse behaviors.
        マウスの振る舞いの大幅な改善を含む、エディターのメニューバーの例。

        Menu button example bug fixes
        メニューボタンの例のバグ修正

        Navigation menubar example bug fixes
        ナビゲーションメニューバーの例のバグ修正

        Radio group example styling
        ラジオグループの例のスタイリング

        Tabs pattern, including labeling guidance
        ラベル付けガイダンスを含むタブのパターン

        Tree view pattern, including multi-select guidance
        複数選択ガイダンスを含むツリービューのパターン

        Tree view example bug fixes
        ツリービューの例のバグ修正

Also see:
参照：

    The APG 1.1 Release 2 Milestone: which lists the GitHub issues that document discussions and reviews of changes included in the July 2018 publication.
    APG 1.1 リリース2マイルストーン：2018年7月の出版物に含まれる変更のディスカッションとレビューを文書化した GitHub issues を一覧表示します。

    Detailed change log with links to all commits that are new in the July 2018 publication since the December 2017 publication of the Note.
    ノートの2017年12月の発行以降、2018年7月の発行で新しくなったすべてのコミットへのリンクを含む詳細な変更ログ。





B.4 Changes in December 2017 Publication as Note
B.4 2017年12月の発行におけるノートとしての変更

    Added the following:
    以下を追加しました：

        Read Me First section
        最初に私を読んでくださいのセクション

        Combobox pattern
        コンボボックスのパターン

        Combobox examples: 3 ARIA 1.0 style and 4 ARIA 1.1 style
        コンボボックスの例：3つの ARIA 1.0 スタイルと4つの ARIA 1.1 スタイル

        Disclosure pattern
        開示のパターン

        Feed example display page
        フィードの例の表示ページ

        Grid and table properties guidance section
        グリッドとテーブルのプロパティのガイダンスのセクション

        Collapsible dropdown listbox example
        折りたたみ可能なドロップダウンリストボックスの例

        Multi-thumb slider examples
        複数つまみスライダーの例

        Table pattern and example
        テーブルのパターンと例

    The top of each example page now includes a set of four related links to:
    各サンプルページの上部には、次の4つの関連リンクのセットが含まれています。

        "Browser and Assistive Technology Support" section of "Read Me First"
        「最初に私を読んでください」の「ブラウザーと支援技術のサポート」セクション

        "Report Issue" page in the Github repository
        Github リポジトリーの「問題の報告」ページ

        "Related Issues" listed in the Github project for the example
        例として Github プロジェクトにリストされている「関連する問題」

        "Design Pattern" section that applies to the example
        例に適用される「デザインパターン」セクション

    All Javascript and CSS files used by the examples include the correct license and copyright statements.
    例で使用されているすべての Javascript ファイルと CSS ファイルには、正しいライセンスと著作権情報が含まれています。

    Significant revisions of guidance and implementation were made to the following sections, design patterns, and examples:
    次のセクション、デザインパターン、および例に対して、ガイダンスと実装が大幅に改訂されました。

        Introduction
        序文

        Keyboard guidance for Mac OS
        MacOS のキーボードガイダンス

        Accordion example
        アコーディオンの例

        Mixed checkbox examples
        混合チェックボックスの例

        Scrollable layout grid example
        スクロール可能なレイアウトグリッドの例

        Listbox examples
        リストボックスの例

        Modal dialog example
        モーダルダイアログの例

        editor menubar example
        エディターメニューバーの例

        Navigation menubar example
        ナビゲーションメニューバーの例

        Menu button examples
        メニューボタンの例

        Spinbutton pattern
        スピンボタンのパターン

        Toolbar example
        ツールバーの例

        Tree view examples
        ツリービューの例

Also see:
参照：

    1.1 APG Release 1 milestone, which lists the GitHub issues that document discussions and reviews of changes included in the December 2017 publication.
    1.1 APG リリース1マイルストーン。 2017年12月の出版物に含まれる変更のディスカッションとレビューを文書化した GitHub issues がリストされています。

    Detailed change log with links to all commits that are new in the December 2017 publication as a Note since the June 2017 working draft.
    2017年6月のワーキングドラフト以降のメモとして、2017年12月の発行で新しいすべてのコミットへのリンクを含む詳細な変更ログ。





B.5 Changes in June 2017 Working Draft
B.5 2017年6月のワーキングドラフトでの変更

    Added the following:
    以下を追加しました：

        Modal dialog example
        モーダルダイアログの例

        Disclosure design pattern
        開示のデザインパターン

        Example disclosure for FAQ
        FAQの開示の例

        Example disclosure for image description
        画像説明の開示の例

        Draft of feed pattern
        フィードのパターンのドラフト

        Example feed implementation
        フィードの実装の例

        Example of menu button using aria-activedescendant
        aria-activedescendant を使用したメニューボタンの例

        Example of tabs with manual activation
        手動アクティブ化のあるタブの例

    Design pattern section: moved examples subsection of each design pattern to be the first subsection.
    デザインパターンのセクション：各デザインパターンの例のサブセクションを最初のサブセクションに移動しました。

    Across all example pages:
    例のページのすべてにわたって：

        Improved visual design of tables that document keyboard implementation, roles, states, and properties.
        キーボードの実装、ロール、状態、およびプロパティを文書化するテーブルのビジュアルデザインが改善されました。

        Improved consistency of editorial style.
        編集スタイルの一貫性が向上しました。

    Significant revisions of guidance and implementation were made to the following design patterns and example pages:
    ガイダンスと実装の大幅な改訂が、次のデザインパターンとサンプルページに加えられました。

        Accordion example
        アコーディオンの例

        Alert example
        アラートの例

        Breadcrumb example
        パンくずリストの例

        Button example
        ボタンの例

        Checkbox examples
        チェックボックスの例

        Dialog (modal) design pattern
        ダイアログ（モーダル）のデザインパターン

        Grid examples
        グリッドの例

        Landmark examples
        ランドマークの例


        Link example
        リンクの例

        Listbox example
        リストボックスの例

        Menubar examples
        メニューバーの例

        Menu button examples
        メニューボタンの例

        Radio group example
        ラジオグループの例

        Slider design pattern
        スライダーのデザインパターン

        Slider example
        スライダーの例

        Example of tabs with automatic activation
        自動アクティブ化のあるタブの例

        Tree view examples
        ツリービューの例

Also see:
参照：

    January 2017 Clean Up Milestone, which lists the GitHub issues that document discussions and reviews of changes included in the June 2017 working draft.
    2017年1月のクリーンアップマイルストーン。 2017年6月のワーキングドラフトに含まれる変更のディスカッションとレビューを文書化した GitHub issues がリストされています。

    Detailed change log with links to all commits that are new in the June 2017 working draft.
    2017年6月のワーキングドラフトで新しく追加されたすべてのコミットへのリンクを含む詳細な変更ログ。





C. Acknowledgements
C. 謝辞



C.1 Major Contributors to Version 1.1
C.1 バージョン1.1の主な貢献者

While WAI-ARIA Authoring Practices 1.1 is the work of the entire Authoring Practices Task Force and also benefits from many people throughout the open source community who both contribute significant work and provide valuable feedback, special thanks goes to the following people who provided distinctly large portions of the content and code in version 1.1.
WAI-ARIA の著作の実践 1.1 は、著作の実践のタスクフォース全体の作業であり、重要な作業に貢献し、貴重なフィードバックを提供するオープンソースコミュニティ全体の多くの人々からも恩恵を受けていますが、バージョン 1.1 のコンテンツとコードの明らかに大きな部分を提供してくれた次の人々に特に感謝します。

    Jon Gunderson and Nicholas Hoyt of the Division of Disability Resources and Education Services at the University of Illinois Urbana/Champaign and the students Max Foltz, Sulaiman Sanaullah, Mark McCarthy, and Jinyuan Zhou for their contributions to the development of many of the design pattern examples.
    イリノイ大学アーバナ/シャンペーン校の障害者資源教育サービス部門の Jon Gunderson と Nicholas Hoyt、および学生の Max Foltz、Sulaiman Sanaullah、Mark McCarthy、Jinyuan Zhou は、多くのデザインパターンの例の開発に貢献してくれました。

    Valerie Young of Bocoup and her sponsor, Facebook, for development of the example test framework and regressions tests for more than 50 examples.
    Bocoup の Valerie Young と彼女のスポンサーである Facebook は、50を超える例のテストフレームワークと回帰テストの例を開発してくれました。

    Simon Pieters of Bocoup and his sponsor, Facebook, for authoring of significant guidance sections, including comprehensive treatement of the topic of accessible names and descriptions.
    Bocoup の Simon Pieters と彼のスポンサーである Facebook は、アクセス可能な名前と説明のトピックの包括的な取り扱いを含む、重要なガイダンスのセクションを作成してくれました。





C.2 Participants active in the ARIA Authoring Practices Task Force
C.2 ARIA の著作の実践のタスクフォースで活動している参加者

    Ann Abbott (Invited Expert)

    Shirisha Balusani (Microsoft Corporation)

    Dorothy Bass (Wells Fargo Bank N.A.)

    Curt Bellew (Oracle)

    Zoë Bijl (Invited Expert)

    Michael Cooper (W3C)

    Bryan Garaventa (Level Access)

    Jon Gunderson (University of Illinois at Urbana-Champaign)

    Jesse Hausler(Salesforce)

    Sarah Higley (Microsoft Corporation)

    Hans Hillen (The Paciello Group, LLC)

    Matt King (Facebook)

    Jaeun Ku (University of Illinois at Urbana-Champaign)

    Aaron Leventhal (Google)

    Carolyn MacLeod (IBM Corporation)

    Mark McCarthy (University of Illinois at Urbana-Champaign)

    James Nurthen (Adobe)

    Scott O'Hara (The Paciello Group, LLC)

    Simon Pieters (Bocoup)

    Scott Vinkle (Shopify)

    Evan Yamanishi (W. W. Norton)

    Valerie Young (Bocoup)





C.3 Other commenters and contributors to Version 1.1
C.3 その他のバージョン 1.1 へのコメント投稿者および寄稿者

    Vyacheslav Aristov

    J. Renée Beach

    Kasper Christensen

    Gerard K. Cohen

    Anne-Gaelle Colom

    Kevin Coughlin

    Cameron Cundiff

    Manish Dahamiwal

    Gilmore Davidson

    Boris Dušek

    Michael Fairchild

    Jeremy Felt

    Rob Fentress

    Geppy

    Tatiana Iskandar

    Patrick Lauke

    Marek Lewandowski

    Dan Matthew

    Shane McCarron

    Victor Meyer

    Jonathan Neal

    Philipp Rudloff

    Joseph Scheuhammer

    Nick Schonning

    thomascorthals

    Christopher Tryens





C.4 Enabling funders
C.4 可能にする資金提供者

This publication has been funded in part with U.S. Federal funds from the Department of Education, National Institute on Disability, Independent Living, and Rehabilitation Research (NIDILRR), initially under contract number ED-OSE-10-C-0067 and currently under contract number HHSP23301500054C. The content of this publication does not necessarily reflect the views or policies of the U.S. Department of Education, nor does mention of trade names, commercial products, or organizations imply endorsement by the U.S. Government.
この出版物は、当初は契約番号 ED-OSE-10-C-0067 で、現在は契約番号 HHSP23301500054C で、米国教育省、国立障害者自立生活リハビリテーション研究所（NIDILRR）からの米国連邦資金によって部分的に資金提供されています。 この出版物の内容は、必ずしも米国教育省の見解や方針を反映しているわけではなく、商号、商品、または組織についての言及は、米国政府による承認を意味するものでもありません。 




D. References
D. 参考文献



D.1 Informative references
D.1 参考資料

[HTML]

    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/

[HTML-AAM]

    HTML Accessibility API Mappings 1.0. Steve Faulkner; Alexander Surkov; Scott O'Hara; Bogdan Brinza; Jason Kiss; Cynthia Shelly. W3C. 10 July 2019. W3C Working Draft. URL: https://www.w3.org/TR/html-aam-1.0/

[HTML-ARIA]

    ARIA in HTML. Steve Faulkner. W3C. 5 July 2019. W3C Working Draft. URL: https://www.w3.org/TR/html-aria/

[SVG2]

    Scalable Vector Graphics (SVG) 2. Amelia Bellamy-Royds; Bogdan Brinza; Chris Lilley; Dirk Schulze; David Storey; Eric Willigers. W3C. 4 October 2018. W3C Candidate Recommendation. URL: https://www.w3.org/TR/SVG2/

[WAI-ARIA]

    Accessible Rich Internet Applications (WAI-ARIA) 1.1. Joanmarie Diggs; Shane McCarron; Michael Cooper; Richard Schwerdtfeger; James Craig. W3C. 14 December 2017. W3C Recommendation. URL: https://www.w3.org/TR/wai-aria-1.1/

↑